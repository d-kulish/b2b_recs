{% extends 'base_model.html' %}
{% load humanize %}
{% load static %}

{% block title %}{{ model.name }} - Dataset Manager{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/cards.css' %}?v=4">
<link rel="stylesheet" href="{% static 'css/modals.css' %}?v=2">
{% endblock %}

{% block model_content %}
<div class="space-y-6">
    <!-- Dataset Manager Container -->
    <div class="bg-white rounded-xl border border-black shadow-lg p-6">
        <div class="flex items-center justify-between mb-6">
            <h2 class="text-2xl font-bold text-gray-900">Dataset Manager</h2>
            <div class="btn-group">
                <button onclick="refreshDatasets()" class="btn btn-secondary btn-sm" style="width: 140px;">
                    <i class="fas fa-sync-alt"></i>Refresh
                </button>
                <button onclick="openWizard()" class="btn btn-primary btn-sm" style="width: 140px;">
                    <i class="fas fa-plus"></i>New Dataset
                </button>
            </div>
        </div>

        <!-- Filter Bar -->
        <div class="flex items-center gap-4 mb-4">
            <div class="flex items-center gap-2">
                <label class="text-sm font-medium text-gray-600">Status:</label>
                <select id="statusFilter" onchange="filterDatasets()" class="form-select text-sm" style="width: 120px;">
                    <option value="">All</option>
                    <option value="draft">Draft</option>
                    <option value="active">Active</option>
                </select>
            </div>
            <div class="flex-1">
                <input type="text" id="searchInput" placeholder="Search datasets..."
                       class="form-input w-full text-sm" onkeyup="debounceSearch()">
            </div>
        </div>

        <!-- Datasets List Container -->
        <div id="datasetsList" class="space-y-3" style="min-height: 200px;">
            <!-- Dataset cards will be inserted here by JavaScript -->
            <div class="card-empty-state">
                <p class="card-empty-state-title">No datasets configured</p>
                <p class="card-empty-state-text">Create your first dataset to define training data for your ML models</p>
            </div>
        </div>

        <!-- Pagination -->
        <div id="paginationContainer" class="hidden mt-4 pt-4 border-t border-gray-200">
            <div class="flex items-center justify-between">
                <div id="paginationInfo" class="text-sm text-gray-600"></div>
                <div id="paginationButtons" class="flex items-center gap-2"></div>
            </div>
        </div>
    </div>
</div>

<!-- Dataset Wizard Modal -->
<div id="datasetWizardModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-wizard modal-dataset-wizard">
        <!-- Modal Header -->
        <div class="modal-header-wizard">
            <div class="modal-header-content">
                <div class="modal-header-icon info">
                    <i class="fas fa-table text-lg"></i>
                </div>
                <div class="modal-header-info">
                    <h3 class="modal-header-title" id="wizardTitle">Create Dataset</h3>
                    <p class="modal-step-counter">Step <span id="currentStep">1</span> of 4</p>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="progress-bar-pills">
                <div id="progress1" class="progress-step-pill current">Info</div>
                <div id="progress2" class="progress-step-pill future">Tables</div>
                <div id="progress3" class="progress-step-pill future">Schema</div>
                <div id="progress4" class="progress-step-pill future">Filters</div>
            </div>
        </div>

        <!-- Modal Body -->
        <div class="modal-body-wizard">
            <!-- Step 1: Basic Info -->
            <div id="step1" class="wizard-step active">
                <h4 class="wizard-section-title">Basic Information</h4>

                <!-- Dataset Name -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Dataset Name <span class="required">*</span></label>
                    <input type="text" id="datasetName" placeholder="e.g., Transactions Q4 2024"
                           class="form-input w-full" oninput="validateDatasetName()">
                    <p id="nameError" class="text-xs text-red-600 mt-1 hidden"></p>
                    <p id="nameSuccess" class="text-xs text-green-600 mt-1 hidden">
                        <i class="fas fa-check-circle mr-1"></i>Name is available
                    </p>
                </div>

                <!-- Description -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Description <span class="optional">(optional)</span></label>
                    <textarea id="datasetDescription" placeholder="Describe the purpose of this dataset..."
                              class="form-textarea w-full" rows="3"></textarea>
                </div>

                <div class="wizard-info-box info">
                    <i class="fas fa-info-circle"></i>
                    <div>
                        <strong>What is a Dataset?</strong><br>
                        A dataset defines which BigQuery tables, columns, and filters to use for training your ML models.
                    </div>
                </div>
            </div>

            <!-- Step 2: Source Tables -->
            <div id="step2" class="wizard-step">
                <h4 class="wizard-section-title">Select Source Tables</h4>
                <p class="wizard-section-subtitle">Choose tables from your BigQuery raw_data dataset.</p>

                <!-- Primary Table -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Primary Table <span class="required">*</span></label>
                    <div class="wizard-list-container">
                        <div id="primaryTableList" class="list-content" style="max-height: 160px;">
                            <p class="text-center text-gray-500 py-4">
                                <i class="fas fa-spinner fa-spin mr-2"></i>Loading tables...
                            </p>
                        </div>
                    </div>
                    <p class="wizard-field-hint">
                        <i class="fas fa-info-circle mr-1"></i>
                        The primary table contains your main transaction/interaction data.
                    </p>
                </div>

                <!-- Secondary Tables -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Secondary Tables <span class="optional">(optional)</span></label>
                    <div class="wizard-list-container">
                        <div id="secondaryTableList" class="list-content" style="max-height: 140px;">
                            <p class="text-center text-gray-500 py-4">Select a primary table first</p>
                        </div>
                    </div>
                    <p class="wizard-field-hint">
                        <i class="fas fa-link mr-1"></i>
                        Additional tables to join (e.g., products, customers). You'll configure joins in the next step.
                    </p>
                </div>
            </div>

            <!-- Step 3: Visual Schema Builder -->
            <div id="step3" class="wizard-step">
                <div class="schema-builder-container">
                    <!-- Header with title -->
                    <div class="schema-builder-header">
                        <div>
                            <h4 class="wizard-section-title" style="margin-bottom: 2px;">Schema Builder</h4>
                            <p class="wizard-section-subtitle" style="margin-bottom: 0;">Connect tables and select columns for your dataset.</p>
                        </div>
                    </div>

                    <!-- Table Cards Area -->
                    <div class="schema-cards-area" id="schemaCardsArea">
                        <!-- SVG for connection lines -->
                        <svg class="schema-connections-svg" id="connectionsSvg"></svg>

                        <!-- Table cards container -->
                        <div class="schema-cards-container" id="schemaCardsContainer">
                            <!-- Loading state -->
                            <div class="schema-loading" id="schemaLoading">
                                <i class="fas fa-spinner fa-spin"></i>
                                Loading table samples...
                            </div>
                        </div>
                    </div>

                    <!-- Preview Section -->
                    <div class="schema-preview-section">
                        <!-- Stats bar -->
                        <div class="schema-preview-stats" id="previewStats">
                            <div class="stat-item">
                                <span>Preview:</span>
                                <span class="stat-value" id="previewRowCount">-</span>
                                <span>rows</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value" id="previewColCount">-</span>
                                <span>columns</span>
                            </div>
                            <div class="stat-item" id="previewWarnings" style="display: none;">
                                <i class="fas fa-exclamation-triangle stat-warning"></i>
                                <span class="stat-warning" id="previewWarningText"></span>
                            </div>
                        </div>

                        <!-- Preview table -->
                        <div class="schema-preview-table-container" id="previewTableContainer">
                            <div class="schema-preview-empty" id="previewEmpty">
                                <i class="fas fa-table"></i>
                                Select columns to see a preview of your dataset
                            </div>
                            <table class="schema-preview-table" id="previewTable" style="display: none;">
                                <thead id="previewTableHead"></thead>
                                <tbody id="previewTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Join Popover (hidden by default) -->
                <div class="join-popover hidden" id="joinPopover">
                    <div class="join-popover-header">Join Type</div>
                    <div class="join-popover-warning hidden" id="joinPopoverWarning">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span id="joinPopoverWarningText">Non-unique join key</span>
                    </div>
                    <div class="join-popover-option" data-type="left" onclick="setJoinType('left')">
                        <i class="fas fa-check"></i> LEFT JOIN
                    </div>
                    <div class="join-popover-option" data-type="inner" onclick="setJoinType('inner')">
                        <i class="fas fa-check"></i> INNER JOIN
                    </div>
                    <div class="join-popover-option danger" onclick="removeSelectedJoin()">
                        <i class="fas fa-trash"></i> Remove
                    </div>
                </div>

                <!-- Column Info Popover for connect mode (hidden by default) -->
                <div class="column-info-popover hidden" id="columnInfoPopover">
                    <div class="column-info-name" id="columnInfoName">column_name</div>
                    <div class="column-info-type" id="columnInfoType">
                        <span class="column-info-label">Type:</span>
                        <span class="column-info-value" id="columnInfoTypeValue">STRING</span>
                    </div>
                    <div class="column-info-samples" id="columnInfoSamples">
                        <span class="column-info-label">Samples:</span>
                        <span class="column-info-value" id="columnInfoSamplesValue"></span>
                    </div>
                    <div class="column-info-hint" id="columnInfoHint">
                        Click a column in another table to connect
                    </div>
                    <div class="column-info-warning hidden" id="columnInfoWarning">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span id="columnInfoWarningText">Type mismatch</span>
                    </div>
                    <div class="column-info-compatible hidden" id="columnInfoCompatible">
                        <i class="fas fa-check-circle"></i>
                        <span>Compatible</span>
                    </div>
                </div>
            </div>

            <!-- Step 4: Filtering -->
            <div id="step4" class="wizard-step">
                <h4 class="wizard-section-title">Filtering</h4>
                <p class="wizard-section-subtitle">Configure filters to select the data for your dataset.</p>

                <!-- Sub-chapter 1: Dates -->
                <div class="filter-subchapter" id="historySubchapter">
                    <div class="subchapter-header-tablet" onclick="toggleSubchapter('history')">
                        <span class="subchapter-title">Dates</span>
                        <span class="subchapter-filter-status" id="datesFilterStatus"></span>
                        <i id="historyChevron" class="fas fa-chevron-right subchapter-chevron"></i>
                    </div>
                    <div id="historyContent" class="subchapter-content-outside hidden">
                        <!-- Filter Buttons Row -->
                        <div class="filter-buttons-row">
                            <!-- Timestamp Column Dropdown -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Select timestamp column</span>
                                <div class="timestamp-column-select-wrapper">
                                    <select id="timestampColumn" class="form-select timestamp-column-select" onchange="onTimestampColumnChange();">
                                        <option value="">Select column...</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Rolling Window Button -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Set number of days</span>
                                <button type="button" class="filter-button" id="rollingWindowBtn" onclick="toggleFilterPopup('rollingWindow')">
                                    <i class="fas fa-history"></i>
                                    <span>Rolling Window</span>
                                </button>
                                <div class="filter-popup" id="rollingWindowPopup">
                                    <div class="filter-popup-header">Set Rolling Window</div>
                                    <div class="flex items-center gap-2">
                                        <input type="number" id="rollingDays" value="30" min="1" max="365"
                                               class="form-input w-20 text-sm" onchange="onRollingDaysChange()">
                                        <span class="text-sm text-gray-600">days</span>
                                        <button type="button" class="btn btn-sm btn-primary" onclick="applyRollingWindow()">Apply</button>
                                    </div>
                                    <p class="filter-popup-hint">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Days from the latest available date
                                    </p>
                                </div>
                            </div>

                            <!-- Start Date Button -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Select start date</span>
                                <button type="button" class="filter-button" id="startDateBtn" onclick="toggleFilterPopup('startDate')">
                                    <i class="fas fa-calendar-alt"></i>
                                    <span>Start Date</span>
                                </button>
                                <div class="filter-popup" id="startDatePopup">
                                    <div class="filter-popup-header">Select Start Date</div>
                                    <input type="date" id="startDateInput" class="form-input w-full text-sm" onchange="onStartDateChange(); closeFilterPopup('startDate');">
                                    <p class="filter-popup-hint">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Fixed start date for the dataset
                                    </p>
                                </div>
                            </div>

                            <!-- Refresh Dataset Button -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">&nbsp;</span>
                                <button type="button" class="filter-button filter-button-refresh filter-button-disabled" id="refreshDatasetBtn" onclick="refreshDatasetHistory()" disabled>
                                    <i class="fas fa-sync-alt"></i>
                                    <span>Refresh Dataset</span>
                                </button>
                            </div>
                        </div>

                        <!-- Summary Line -->
                        <div class="filter-summary-line" id="datesFilterSummary">
                            <div class="filter-summary-items" id="datesFilterSummaryItems">
                                <span class="filter-summary-empty">No filters selected</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sub-chapter 2: Customers -->
                <div class="filter-subchapter" id="customersSubchapter">
                    <div class="subchapter-header-tablet" onclick="toggleSubchapter('customers')">
                        <span class="subchapter-title">Customers</span>
                        <span class="subchapter-filter-status" id="customersFilterStatus"></span>
                        <i id="customersChevron" class="fas fa-chevron-right subchapter-chevron"></i>
                    </div>
                    <div id="customersContent" class="subchapter-content-outside hidden">
                        <!-- Filter Buttons Row -->
                        <div class="filter-buttons-row">
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Filter by revenue</span>
                                <button type="button" class="filter-button" onclick="openTopCustomersModal()">
                                    <i class="fas fa-chart-line"></i>
                                    Top Customers
                                </button>
                            </div>
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Filter by metrics</span>
                                <button type="button" class="filter-button" onclick="openCustomerMetricsModal()">
                                    <i class="fas fa-calculator"></i>
                                    Customer Metrics
                                </button>
                            </div>
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Filter by columns</span>
                                <button type="button" class="filter-button" onclick="openCustomerFilterColumnsModal()">
                                    <i class="fas fa-filter"></i>
                                    Filter Columns
                                </button>
                            </div>
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">&nbsp;</span>
                                <button type="button" class="filter-button filter-button-refresh filter-button-disabled" onclick="refreshCustomerFilters()" id="refreshCustomerFiltersBtn" disabled>
                                    <i class="fas fa-sync-alt"></i>
                                    Refresh Dataset
                                </button>
                            </div>
                        </div>

                        <!-- Summary Line -->
                        <div class="filter-summary-line" id="customersFilterSummary">
                            <div class="filter-summary-items" id="customersFilterSummaryItems">
                                <span class="filter-summary-empty">No filters selected</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sub-chapter 3: Products -->
                <div class="filter-subchapter" id="productsSubchapter">
                    <div class="subchapter-header-tablet" onclick="toggleSubchapter('products')">
                        <span class="subchapter-title">Products</span>
                        <span class="subchapter-filter-status" id="productsFilterStatus"></span>
                        <i id="productsChevron" class="fas fa-chevron-right subchapter-chevron"></i>
                    </div>
                    <div id="productsContent" class="subchapter-content-outside hidden">
                        <!-- Filter Buttons Row -->
                        <div class="filter-buttons-row">
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Filter by revenue</span>
                                <button type="button" class="filter-button" onclick="openTopProductsModal()">
                                    <i class="fas fa-chart-line"></i>
                                    Top Products
                                </button>
                            </div>
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Filter by metrics</span>
                                <button type="button" class="filter-button" onclick="openProductMetricsModal()">
                                    <i class="fas fa-calculator"></i>
                                    Product Metrics
                                </button>
                            </div>
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Filter by columns</span>
                                <button type="button" class="filter-button" onclick="openFilterColumnsModal()">
                                    <i class="fas fa-filter"></i>
                                    Filter Columns
                                </button>
                            </div>
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">&nbsp;</span>
                                <button type="button" class="filter-button filter-button-refresh filter-button-disabled" onclick="refreshProductFilters()" id="refreshProductFiltersBtn" disabled>
                                    <i class="fas fa-sync-alt"></i>
                                    Refresh Dataset
                                </button>
                            </div>
                        </div>

                        <!-- Summary Line -->
                        <div class="filter-summary-line" id="productsFilterSummary">
                            <div class="filter-summary-items" id="productsFilterSummaryItems">
                                <span class="filter-summary-empty">No filters selected</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Products Modal -->
                <div class="modal-overlay hidden" id="topProductsModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-chart-line"></i>
                            </div>
                            <h3 class="modal-header-title">Top Products by Revenue</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Hidden checkbox to maintain state compatibility -->
                            <input type="checkbox" id="enableTopProducts" style="display: none;">

                            <!-- Top Products Configuration (always visible) -->
                            <div id="topProductsConfig">
                                <!-- Row: Product ID, Revenue Column, Analyze Button -->
                                <div class="top-products-config-row">
                                    <div class="top-products-field">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">Product ID Column</label>
                                        <select id="productIdColumn" class="form-select text-sm" onchange="onProductColumnChange()">
                                            <option value="">Select column...</option>
                                        </select>
                                    </div>
                                    <div class="top-products-field">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">Revenue Column</label>
                                        <select id="revenueColumn" class="form-select text-sm" onchange="onRevenueColumnChange()">
                                            <option value="">Select column...</option>
                                        </select>
                                    </div>
                                    <div class="top-products-field top-products-field-btn">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">&nbsp;</label>
                                        <button type="button" id="analyzeProductsBtn" onclick="analyzeProductRevenue()"
                                                class="filter-button filter-button-refresh filter-button-disabled" disabled>
                                            <i class="fas fa-sync-alt"></i>
                                            <span>Analyze</span>
                                        </button>
                                    </div>
                                </div>

                                <!-- Analysis Results (hidden until analyzed) -->
                                <div id="productAnalysisResults" class="hidden">
                                    <!-- Revenue Distribution Chart -->
                                    <div class="wizard-field-group">
                                        <label class="text-xs font-medium text-gray-600 mb-2 block">Cumulative Revenue Distribution</label>
                                        <div id="revenueChartContainer" class="revenue-chart-container">
                                            <svg id="revenueDistributionChart"></svg>
                                        </div>
                                    </div>

                                    <!-- Threshold Input -->
                                    <div class="wizard-field-group">
                                        <div class="flex items-center gap-2">
                                            <span class="text-sm text-gray-600">Include products covering up to</span>
                                            <input type="number" id="revenueThreshold" value="80" min="1" max="100"
                                                   class="form-input w-20 text-sm text-center" onchange="onThresholdChange()">
                                            <span class="text-sm text-gray-600">% of cumulative revenue</span>
                                        </div>
                                    </div>

                                    <!-- Analysis Summary -->
                                    <div id="productAnalysisSummary" class="analysis-summary-box">
                                        <div class="analysis-summary-header">
                                            <i class="fas fa-chart-pie mr-2"></i>
                                            Analysis Results
                                        </div>
                                        <div class="analysis-summary-content">
                                            <div class="analysis-stat">
                                                <span class="stat-label">Total products:</span>
                                                <span id="totalProductsCount" class="stat-value">-</span>
                                            </div>
                                            <div class="analysis-stat">
                                                <span class="stat-label">Selected products:</span>
                                                <span id="selectedProductsCount" class="stat-value">-</span>
                                                <span id="selectedProductsPercent" class="stat-percent"></span>
                                            </div>
                                            <div class="analysis-stat">
                                                <span class="stat-label">Revenue coverage:</span>
                                                <span id="revenueCoverage" class="stat-value">-</span>
                                                <span id="revenueCoverageAmount" class="stat-amount"></span>
                                            </div>
                                        </div>
                                        <div class="analysis-summary-footer">
                                            <i class="fas fa-info-circle mr-1"></i>
                                            Product list computed dynamically at training time
                                        </div>
                                    </div>
                                </div>

                                <!-- Analysis Error -->
                                <div id="productAnalysisError" class="hidden">
                                    <div class="wizard-info-box error">
                                        <i class="fas fa-exclamation-circle"></i>
                                        <span id="productAnalysisErrorText">Analysis failed</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="applyTopProductsFilter()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Apply</span>
                                </button>
                                <button onclick="closeTopProductsModal()" class="btn-neu btn-neu-action btn-neu-cancel">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Product Metrics Modal -->
                <div class="modal-overlay hidden" id="productMetricsModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-calculator"></i>
                            </div>
                            <h3 class="modal-header-title">Product Metrics Filters</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Existing Aggregation Filters List -->
                            <div id="existingProductAggregationFiltersSection" class="hidden">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Existing Filters</label>
                                <div class="existing-filters-list" id="existingProductAggregationFiltersList">
                                    <!-- Filter items will be inserted here dynamically -->
                                </div>
                                <div class="existing-filters-divider"></div>
                            </div>

                            <!-- Transaction Count Filter Section -->
                            <div class="customer-metrics-section">
                                <div class="customer-metrics-section-header">
                                    <i class="fas fa-shopping-cart"></i>
                                    <span>Transaction Count Filter</span>
                                </div>
                                <div class="customer-metrics-section-body">
                                    <p class="wizard-field-hint mb-3">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Filter products based on their number of transactions
                                    </p>
                                    <div class="customer-metrics-form-row">
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Product ID Column</label>
                                            <select id="productTxnCountProductColumn" class="form-select text-sm">
                                                <option value="">Select column...</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Filter Type</label>
                                            <select id="productTxnCountFilterType" class="form-select text-sm" onchange="updateProductTxnCountInputs()">
                                                <option value="greater_than">Greater than</option>
                                                <option value="less_than">Less than</option>
                                                <option value="range">Range</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field" id="productTxnCountValueContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Value</label>
                                            <input type="number" id="productTxnCountValue" class="form-input text-sm" min="1" placeholder="e.g., 5">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="productTxnCountMinContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Min</label>
                                            <input type="number" id="productTxnCountMin" class="form-input text-sm" min="0" placeholder="Min">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="productTxnCountMaxContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Max</label>
                                            <input type="number" id="productTxnCountMax" class="form-input text-sm" min="0" placeholder="Max">
                                        </div>
                                        <div class="customer-metrics-field customer-metrics-field-btn">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">&nbsp;</label>
                                            <button type="button" class="filter-button" onclick="addProductTransactionCountFilter()">
                                                <i class="fas fa-plus"></i>
                                                Add Filter
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Revenue Filter Section -->
                            <div class="customer-metrics-section">
                                <div class="customer-metrics-section-header">
                                    <i class="fas fa-dollar-sign"></i>
                                    <span>Revenue Filter</span>
                                </div>
                                <div class="customer-metrics-section-body">
                                    <p class="wizard-field-hint mb-3">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Filter products based on their total revenue
                                    </p>
                                    <div class="customer-metrics-form-row">
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Product ID Column</label>
                                            <select id="productRevenueProductColumn" class="form-select text-sm">
                                                <option value="">Select column...</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Amount Column</label>
                                            <select id="productRevenueAmountColumn" class="form-select text-sm">
                                                <option value="">Select column...</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Filter Type</label>
                                            <select id="productRevenueFilterType" class="form-select text-sm" onchange="updateProductRevenueInputs()">
                                                <option value="greater_than">Greater than</option>
                                                <option value="less_than">Less than</option>
                                                <option value="range">Range</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="customer-metrics-form-row mt-3">
                                        <div class="customer-metrics-field" id="productRevenueValueContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Value</label>
                                            <input type="number" id="productRevenueValue" class="form-input text-sm" min="0" step="0.01" placeholder="e.g., 1000">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="productRevenueMinContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Min</label>
                                            <input type="number" id="productRevenueMin" class="form-input text-sm" min="0" step="0.01" placeholder="Min">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="productRevenueMaxContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Max</label>
                                            <input type="number" id="productRevenueMax" class="form-input text-sm" min="0" step="0.01" placeholder="Max">
                                        </div>
                                        <div class="customer-metrics-field customer-metrics-field-btn">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">&nbsp;</label>
                                            <button type="button" class="filter-button" onclick="addProductRevenueFilter()">
                                                <i class="fas fa-plus"></i>
                                                Add Filter
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="applyProductMetricsFilters()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Apply</span>
                                </button>
                                <button onclick="cancelProductMetricsModal()" class="btn-neu btn-neu-action btn-neu-cancel">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Filter Columns Modal -->
                <div class="modal-overlay hidden" id="filterColumnsModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-filter"></i>
                            </div>
                            <h3 class="modal-header-title">Filter Columns</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Existing Filters List -->
                            <div id="existingFiltersSection" class="hidden">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Existing Filters</label>
                                <div class="existing-filters-list" id="existingFiltersList">
                                    <!-- Filter items will be inserted here dynamically -->
                                </div>
                                <div class="existing-filters-divider"></div>
                            </div>

                            <!-- Add New Filter Section -->
                            <div id="addFilterSection">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Add New Filter</label>
                                <div class="add-filter-form-group">
                                    <select id="filterColumnSelect" class="form-select w-full text-sm" onchange="onFilterColumnSelect()">
                                        <option value="">Select column...</option>
                                    </select>
                                </div>

                                <!-- Inline Filter Configuration (appears based on column type) -->
                                <div id="filterConfigContainer" class="hidden">
                                    <!-- Category Filter Config -->
                                    <div id="categoryFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="categoryFilterColumnName" class="filter-config-column-name"></span>
                                            <span class="filter-config-type-badge">STRING</span>
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="category-filter-mode" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="newCategoryMode" value="include" checked>
                                                    Include selected
                                                </label>
                                                <label>
                                                    <input type="radio" name="newCategoryMode" value="exclude">
                                                    Exclude selected
                                                </label>
                                            </div>
                                            <div class="category-filter-values-container" id="newCategoryValuesContainer">
                                                <!-- List mode or autocomplete will be rendered here -->
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Numeric Filter Config -->
                                    <div id="numericFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="numericFilterColumnName" class="filter-config-column-name"></span>
                                            <span id="numericFilterTypeBadge" class="filter-config-type-badge">INTEGER</span>
                                        </div>
                                        <div class="filter-config-stats" id="numericFilterStats">
                                            <!-- Range: X - Y | Nulls: Z% -->
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="numeric-filter-type" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="newNumericType" value="range" checked onchange="updateNumericFilterInputs()">
                                                    Range
                                                </label>
                                                <label>
                                                    <input type="radio" name="newNumericType" value="greater_than" onchange="updateNumericFilterInputs()">
                                                    Greater than
                                                </label>
                                                <label>
                                                    <input type="radio" name="newNumericType" value="less_than" onchange="updateNumericFilterInputs()">
                                                    Less than
                                                </label>
                                                <label>
                                                    <input type="radio" name="newNumericType" value="equals" onchange="updateNumericFilterInputs()">
                                                    Equals
                                                </label>
                                                <label>
                                                    <input type="radio" name="newNumericType" value="not_equals" onchange="updateNumericFilterInputs()">
                                                    Not Equals
                                                </label>
                                            </div>
                                            <div class="numeric-filter-inputs" id="newNumericInputs">
                                                <div class="numeric-filter-input-group">
                                                    <label class="numeric-filter-input-label">Min</label>
                                                    <input type="number" class="numeric-filter-input" id="newNumericMin" placeholder="">
                                                </div>
                                                <div class="numeric-filter-input-group">
                                                    <label class="numeric-filter-input-label">Max</label>
                                                    <input type="number" class="numeric-filter-input" id="newNumericMax" placeholder="">
                                                </div>
                                            </div>
                                            <div class="numeric-filter-null-handling" id="newNumericNullHandling">
                                                <label>
                                                    <input type="checkbox" id="newNumericIncludeNulls" checked>
                                                    Include NULL values
                                                </label>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Date Filter Config -->
                                    <div id="dateFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="dateFilterColumnName" class="filter-config-column-name"></span>
                                            <span class="filter-config-type-badge">DATE</span>
                                        </div>
                                        <div class="filter-config-stats" id="dateFilterStats">
                                            <!-- Range: YYYY-MM-DD - YYYY-MM-DD -->
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="date-filter-type" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="newDateType" value="relative" checked onchange="updateDateFilterInputs()">
                                                    Relative
                                                </label>
                                                <label>
                                                    <input type="radio" name="newDateType" value="range" onchange="updateDateFilterInputs()">
                                                    Date Range
                                                </label>
                                            </div>
                                            <!-- Relative Date Options -->
                                            <div class="date-filter-relative" id="newDateRelativeInputs">
                                                <select id="newDateRelativeOption" class="form-select w-full text-sm">
                                                    <option value="last_7_days">Last 7 days</option>
                                                    <option value="last_30_days" selected>Last 30 days</option>
                                                    <option value="last_90_days">Last 90 days</option>
                                                    <option value="this_month">This month</option>
                                                    <option value="this_quarter">This quarter</option>
                                                    <option value="this_year">This year</option>
                                                </select>
                                            </div>
                                            <!-- Date Range Inputs -->
                                            <div class="date-filter-range hidden" id="newDateRangeInputs">
                                                <div class="date-filter-input-group">
                                                    <label class="date-filter-input-label">Start Date</label>
                                                    <input type="date" class="form-input text-sm" id="newDateStart">
                                                </div>
                                                <div class="date-filter-input-group">
                                                    <label class="date-filter-input-label">End Date</label>
                                                    <input type="date" class="form-input text-sm" id="newDateEnd">
                                                </div>
                                            </div>
                                            <div class="date-filter-null-handling" id="newDateNullHandling" style="margin-top: 12px;">
                                                <label>
                                                    <input type="checkbox" id="newDateIncludeNulls" checked>
                                                    Include NULL values
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="applyFilterColumnsModal()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Apply</span>
                                </button>
                                <button onclick="closeFilterColumnsModal()" class="btn-neu btn-neu-action btn-neu-cancel">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Customers Modal -->
                <div class="modal-overlay hidden" id="topCustomersModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-chart-line"></i>
                            </div>
                            <h3 class="modal-header-title">Top Customers by Revenue</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Hidden checkbox to maintain state compatibility -->
                            <input type="checkbox" id="enableTopCustomers" style="display: none;">

                            <!-- Top Customers Configuration (always visible) -->
                            <div id="topCustomersConfig">
                                <!-- Row: Customer ID, Revenue Column, Analyze Button -->
                                <div class="top-products-config-row">
                                    <div class="top-products-field">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">Customer ID Column</label>
                                        <select id="customerIdColumn" class="form-select text-sm" onchange="onCustomerColumnChange()">
                                            <option value="">Select column...</option>
                                        </select>
                                    </div>
                                    <div class="top-products-field">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">Revenue Column</label>
                                        <select id="customerRevenueColumn" class="form-select text-sm" onchange="onCustomerRevenueColumnChange()">
                                            <option value="">Select column...</option>
                                        </select>
                                    </div>
                                    <div class="top-products-field top-products-field-btn">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">&nbsp;</label>
                                        <button type="button" id="analyzeCustomersBtn" onclick="analyzeCustomerRevenue()"
                                                class="filter-button filter-button-refresh filter-button-disabled" disabled>
                                            <i class="fas fa-sync-alt"></i>
                                            <span>Analyze</span>
                                        </button>
                                    </div>
                                </div>

                                <!-- Analysis Results (hidden until analyzed) -->
                                <div id="customerAnalysisResults" class="hidden">
                                    <!-- Revenue Distribution Chart -->
                                    <div class="wizard-field-group">
                                        <label class="text-xs font-medium text-gray-600 mb-2 block">Cumulative Revenue Distribution</label>
                                        <div id="customerRevenueChartContainer" class="revenue-chart-container">
                                            <svg id="customerRevenueDistributionChart"></svg>
                                        </div>
                                    </div>

                                    <!-- Threshold Input -->
                                    <div class="wizard-field-group">
                                        <div class="flex items-center gap-2">
                                            <span class="text-sm text-gray-600">Include customers covering up to</span>
                                            <input type="number" id="customerRevenueThreshold" value="80" min="1" max="100"
                                                   class="form-input w-20 text-sm text-center" onchange="onCustomerThresholdChange()">
                                            <span class="text-sm text-gray-600">% of cumulative revenue</span>
                                        </div>
                                    </div>

                                    <!-- Analysis Summary -->
                                    <div id="customerAnalysisSummary" class="analysis-summary-box">
                                        <div class="analysis-summary-header">
                                            <i class="fas fa-chart-pie mr-2"></i>
                                            Analysis Results
                                        </div>
                                        <div class="analysis-summary-content">
                                            <div class="analysis-stat">
                                                <span class="stat-label">Total customers:</span>
                                                <span id="totalCustomersCount" class="stat-value">-</span>
                                            </div>
                                            <div class="analysis-stat">
                                                <span class="stat-label">Selected customers:</span>
                                                <span id="selectedCustomersCount" class="stat-value">-</span>
                                                <span id="selectedCustomersPercent" class="stat-percent"></span>
                                            </div>
                                            <div class="analysis-stat">
                                                <span class="stat-label">Revenue coverage:</span>
                                                <span id="customerRevenueCoverage" class="stat-value">-</span>
                                                <span id="customerRevenueCoverageAmount" class="stat-amount"></span>
                                            </div>
                                        </div>
                                        <div class="analysis-summary-footer">
                                            <i class="fas fa-info-circle mr-1"></i>
                                            Customer list computed dynamically at training time
                                        </div>
                                    </div>
                                </div>

                                <!-- Analysis Error -->
                                <div id="customerAnalysisError" class="hidden">
                                    <div class="wizard-info-box error">
                                        <i class="fas fa-exclamation-circle"></i>
                                        <span id="customerAnalysisErrorText">Analysis failed</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="applyTopCustomersFilter()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Apply</span>
                                </button>
                                <button onclick="closeTopCustomersModal()" class="btn-neu btn-neu-action btn-neu-cancel">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Customer Metrics Modal -->
                <div class="modal-overlay hidden" id="customerMetricsModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-calculator"></i>
                            </div>
                            <h3 class="modal-header-title">Customer Metrics Filters</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Existing Aggregation Filters List -->
                            <div id="existingAggregationFiltersSection" class="hidden">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Existing Filters</label>
                                <div class="existing-filters-list" id="existingAggregationFiltersList">
                                    <!-- Filter items will be inserted here dynamically -->
                                </div>
                                <div class="existing-filters-divider"></div>
                            </div>

                            <!-- Transaction Count Filter Section -->
                            <div class="customer-metrics-section">
                                <div class="customer-metrics-section-header">
                                    <i class="fas fa-shopping-cart"></i>
                                    <span>Transaction Count Filter</span>
                                </div>
                                <div class="customer-metrics-section-body">
                                    <p class="wizard-field-hint mb-3">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Filter customers based on their number of transactions
                                    </p>
                                    <div class="customer-metrics-form-row">
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Customer ID Column</label>
                                            <select id="txnCountCustomerColumn" class="form-select text-sm">
                                                <option value="">Select column...</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Filter Type</label>
                                            <select id="txnCountFilterType" class="form-select text-sm" onchange="updateTxnCountInputs()">
                                                <option value="greater_than">Greater than</option>
                                                <option value="less_than">Less than</option>
                                                <option value="range">Range</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field" id="txnCountValueContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Value</label>
                                            <input type="number" id="txnCountValue" class="form-input text-sm" min="1" placeholder="e.g., 5">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="txnCountMinContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Min</label>
                                            <input type="number" id="txnCountMin" class="form-input text-sm" min="0" placeholder="Min">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="txnCountMaxContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Max</label>
                                            <input type="number" id="txnCountMax" class="form-input text-sm" min="0" placeholder="Max">
                                        </div>
                                        <div class="customer-metrics-field customer-metrics-field-btn">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">&nbsp;</label>
                                            <button type="button" class="filter-button" onclick="addTransactionCountFilter()">
                                                <i class="fas fa-plus"></i>
                                                Add Filter
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Spending Filter Section -->
                            <div class="customer-metrics-section">
                                <div class="customer-metrics-section-header">
                                    <i class="fas fa-dollar-sign"></i>
                                    <span>Spending Filter</span>
                                </div>
                                <div class="customer-metrics-section-body">
                                    <p class="wizard-field-hint mb-3">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Filter customers based on their total spending
                                    </p>
                                    <div class="customer-metrics-form-row">
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Customer ID Column</label>
                                            <select id="spendingCustomerColumn" class="form-select text-sm">
                                                <option value="">Select column...</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Amount Column</label>
                                            <select id="spendingAmountColumn" class="form-select text-sm">
                                                <option value="">Select column...</option>
                                            </select>
                                        </div>
                                        <div class="customer-metrics-field">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Filter Type</label>
                                            <select id="spendingFilterType" class="form-select text-sm" onchange="updateSpendingInputs()">
                                                <option value="greater_than">Greater than</option>
                                                <option value="less_than">Less than</option>
                                                <option value="range">Range</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="customer-metrics-form-row mt-3">
                                        <div class="customer-metrics-field" id="spendingValueContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Value</label>
                                            <input type="number" id="spendingValue" class="form-input text-sm" min="0" step="0.01" placeholder="e.g., 1000">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="spendingMinContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Min</label>
                                            <input type="number" id="spendingMin" class="form-input text-sm" min="0" step="0.01" placeholder="Min">
                                        </div>
                                        <div class="customer-metrics-field hidden" id="spendingMaxContainer">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">Max</label>
                                            <input type="number" id="spendingMax" class="form-input text-sm" min="0" step="0.01" placeholder="Max">
                                        </div>
                                        <div class="customer-metrics-field customer-metrics-field-btn">
                                            <label class="text-xs font-medium text-gray-600 mb-1 block">&nbsp;</label>
                                            <button type="button" class="filter-button" onclick="addSpendingFilter()">
                                                <i class="fas fa-plus"></i>
                                                Add Filter
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="applyCustomerMetricsFilters()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Apply</span>
                                </button>
                                <button onclick="cancelCustomerMetricsModal()" class="btn-neu btn-neu-action btn-neu-cancel">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Customer Filter Columns Modal (reuses Products modal pattern) -->
                <div class="modal-overlay hidden" id="customerFilterColumnsModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-filter"></i>
                            </div>
                            <h3 class="modal-header-title">Filter Columns (Customers)</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Existing Filters List -->
                            <div id="customerExistingFiltersSection" class="hidden">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Existing Filters</label>
                                <div class="existing-filters-list" id="customerExistingFiltersList">
                                    <!-- Filter items will be inserted here dynamically -->
                                </div>
                                <div class="existing-filters-divider"></div>
                            </div>

                            <!-- Add New Filter Section -->
                            <div id="customerAddFilterSection">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Add New Filter</label>
                                <div class="add-filter-form-group">
                                    <select id="customerFilterColumnSelect" class="form-select w-full text-sm" onchange="onCustomerFilterColumnSelect()">
                                        <option value="">Select column...</option>
                                    </select>
                                </div>

                                <!-- Inline Filter Configuration (appears based on column type) -->
                                <div id="customerFilterConfigContainer" class="hidden">
                                    <!-- Category Filter Config -->
                                    <div id="customerCategoryFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="customerCategoryFilterColumnName" class="filter-config-column-name"></span>
                                            <span class="filter-config-type-badge">STRING</span>
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="category-filter-mode" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="customerCategoryMode" value="include" checked>
                                                    Include selected
                                                </label>
                                                <label>
                                                    <input type="radio" name="customerCategoryMode" value="exclude">
                                                    Exclude selected
                                                </label>
                                            </div>
                                            <div class="category-filter-values-container" id="customerCategoryValuesContainer">
                                                <!-- List mode or autocomplete will be rendered here -->
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Numeric Filter Config -->
                                    <div id="customerNumericFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="customerNumericFilterColumnName" class="filter-config-column-name"></span>
                                            <span id="customerNumericFilterTypeBadge" class="filter-config-type-badge">INTEGER</span>
                                        </div>
                                        <div class="filter-config-stats" id="customerNumericFilterStats">
                                            <!-- Range: X - Y | Nulls: Z% -->
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="numeric-filter-type" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="customerNumericType" value="range" checked onchange="updateCustomerNumericFilterInputs()">
                                                    Range
                                                </label>
                                                <label>
                                                    <input type="radio" name="customerNumericType" value="greater_than" onchange="updateCustomerNumericFilterInputs()">
                                                    Greater than
                                                </label>
                                                <label>
                                                    <input type="radio" name="customerNumericType" value="less_than" onchange="updateCustomerNumericFilterInputs()">
                                                    Less than
                                                </label>
                                                <label>
                                                    <input type="radio" name="customerNumericType" value="equals" onchange="updateCustomerNumericFilterInputs()">
                                                    Equals
                                                </label>
                                                <label>
                                                    <input type="radio" name="customerNumericType" value="not_equals" onchange="updateCustomerNumericFilterInputs()">
                                                    Not Equals
                                                </label>
                                            </div>
                                            <div class="numeric-filter-inputs" id="customerNumericInputs">
                                                <div class="numeric-filter-input-group">
                                                    <label class="numeric-filter-input-label">Min</label>
                                                    <input type="number" class="numeric-filter-input" id="customerNumericMin" placeholder="">
                                                </div>
                                                <div class="numeric-filter-input-group">
                                                    <label class="numeric-filter-input-label">Max</label>
                                                    <input type="number" class="numeric-filter-input" id="customerNumericMax" placeholder="">
                                                </div>
                                            </div>
                                            <div class="numeric-filter-null-handling" id="customerNumericNullHandling">
                                                <label>
                                                    <input type="checkbox" id="customerNumericIncludeNulls" checked>
                                                    Include NULL values
                                                </label>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Date Filter Config -->
                                    <div id="customerDateFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="customerDateFilterColumnName" class="filter-config-column-name"></span>
                                            <span class="filter-config-type-badge">DATE</span>
                                        </div>
                                        <div class="filter-config-stats" id="customerDateFilterStats">
                                            <!-- Range: YYYY-MM-DD - YYYY-MM-DD -->
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="date-filter-type" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="customerDateType" value="relative" checked onchange="updateCustomerDateFilterInputs()">
                                                    Relative
                                                </label>
                                                <label>
                                                    <input type="radio" name="customerDateType" value="range" onchange="updateCustomerDateFilterInputs()">
                                                    Date Range
                                                </label>
                                            </div>
                                            <!-- Relative Date Options -->
                                            <div class="date-filter-relative" id="customerDateRelativeInputs">
                                                <select id="customerDateRelativeOption" class="form-select w-full text-sm">
                                                    <option value="last_7_days">Last 7 days</option>
                                                    <option value="last_30_days" selected>Last 30 days</option>
                                                    <option value="last_90_days">Last 90 days</option>
                                                    <option value="this_month">This month</option>
                                                    <option value="this_quarter">This quarter</option>
                                                    <option value="this_year">This year</option>
                                                </select>
                                            </div>
                                            <!-- Date Range Inputs -->
                                            <div class="date-filter-range hidden" id="customerDateRangeInputs">
                                                <div class="date-filter-input-group">
                                                    <label class="date-filter-input-label">Start Date</label>
                                                    <input type="date" class="form-input text-sm" id="customerDateStart">
                                                </div>
                                                <div class="date-filter-input-group">
                                                    <label class="date-filter-input-label">End Date</label>
                                                    <input type="date" class="form-input text-sm" id="customerDateEnd">
                                                </div>
                                            </div>
                                            <div class="date-filter-null-handling" id="customerDateNullHandling" style="margin-top: 12px;">
                                                <label>
                                                    <input type="checkbox" id="customerDateIncludeNulls" checked>
                                                    Include NULL values
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="applyCustomerFilterColumnsModal()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Apply</span>
                                </button>
                                <button onclick="closeCustomerFilterColumnsModal()" class="btn-neu btn-neu-action btn-neu-cancel">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Dataset Summary Panel (always expanded) -->
                <div class="dataset-summary-panel" id="datasetSummaryPanel">
                    <div class="dataset-summary-header">
                        <i class="fas fa-chart-bar"></i>
                        <span>Dataset Summary</span>
                        <span class="dataset-summary-total-rows" id="summaryTotalRowsBadge"></span>
                    </div>
                    <div class="dataset-summary-content">
                        <!-- Empty state before refresh -->
                        <div id="datasetSummaryEmpty" class="dataset-summary-empty">
                            <i class="fas fa-info-circle"></i>
                            <span>Loading dataset statistics...</span>
                        </div>

                        <!-- Populated state after refresh -->
                        <div id="datasetSummaryData" class="dataset-summary-data hidden">
                            <!-- Filters Applied Row -->
                            <div class="dataset-filters-applied" id="filtersAppliedSection">
                                <div class="filter-badge" id="filterBadgeDates">
                                    <i class="fas fa-calendar-alt"></i>
                                    <span id="filterBadgeDatesText">All dates</span>
                                </div>
                                <div class="filter-badge" id="filterBadgeCustomers">
                                    <i class="fas fa-users"></i>
                                    <span id="filterBadgeCustomersText">All customers</span>
                                </div>
                                <div class="filter-badge" id="filterBadgeProducts">
                                    <i class="fas fa-box"></i>
                                    <span id="filterBadgeProductsText">All products</span>
                                </div>
                            </div>

                            <!-- Column Stats Table -->
                            <div class="column-stats-table-wrapper">
                                <table class="column-stats-table" id="columnStatsTable">
                                    <thead>
                                        <tr>
                                            <th>Column</th>
                                            <th>Data Type</th>
                                            <th>Statistics</th>
                                        </tr>
                                    </thead>
                                    <tbody id="columnStatsTableBody">
                                        <!-- Populated by JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Modal Footer (Neumorphic Style) -->
        <div class="modal-footer-wizard-neu">
            <div class="footer-left">
                <button onclick="prevStep()" class="btn-neu btn-neu-nav hidden" id="prevButton">
                    <span class="btn-neu-inner"><i class="fas fa-chevron-left"></i></span>
                </button>
                <button onclick="nextStep()" class="btn-neu btn-neu-nav" id="nextButton" disabled>
                    <span class="btn-neu-inner"><i class="fas fa-chevron-right"></i></span>
                </button>
            </div>
            <div class="footer-right">
                <button onclick="saveDataset()" class="btn-neu btn-neu-action btn-neu-save hidden" id="saveButton">
                    <span class="btn-neu-inner">Save</span>
                </button>
                <button onclick="closeWizard()" class="btn-neu btn-neu-action btn-neu-cancel">
                    <span class="btn-neu-inner">Cancel</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modern Notification Modal (auto-closes) -->
<div id="notificationModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[110] flex items-center justify-center p-4" onclick="closeNotification()">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md border border-gray-300" onclick="event.stopPropagation()">
        <!-- Header -->
        <div id="notificationHeader" class="px-5 py-4">
            <div class="flex items-center gap-3">
                <i id="notificationIcon" class="fas fa-info-circle text-blue-600 text-xl"></i>
                <h3 id="notificationTitle" class="text-base font-bold text-gray-900">Notification</h3>
            </div>
        </div>

        <!-- Body -->
        <div class="px-5 py-4 pt-0">
            <div id="notificationMessage" class="text-sm text-gray-700 whitespace-pre-line"></div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="deleteModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-sm">
        <div class="modal-header">
            <div class="modal-header-icon danger">
                <i class="fas fa-trash-alt"></i>
            </div>
            <h3 class="modal-header-title">Delete Dataset</h3>
        </div>
        <div class="modal-body">
            <p>Are you sure you want to delete "<strong id="deleteDatasetName"></strong>"?</p>
            <p class="text-sm text-gray-500 mt-2">This action cannot be undone.</p>
            <div id="deleteWarning" class="hidden mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                <p class="text-sm text-yellow-800">
                    <i class="fas fa-exclamation-triangle mr-1"></i>
                    This dataset has version history and may have been used in training.
                </p>
            </div>
        </div>
        <div class="modal-footer-wizard-neu">
            <div class="footer-left"></div>
            <div class="footer-right">
                <button onclick="confirmDelete()" class="btn-neu btn-neu-action btn-neu-cancel" id="confirmDeleteBtn">
                    <span class="btn-neu-inner">Delete</span>
                </button>
                <button onclick="closeDeleteModal()" class="btn-neu btn-neu-action btn-neu-secondary">
                    <span class="btn-neu-inner">Cancel</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Dataset Detail Modal -->
<div id="detailModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-lg">
        <div class="modal-header">
            <div class="modal-header-icon info">
                <i class="fas fa-table"></i>
            </div>
            <h3 class="modal-header-title" id="detailModalTitle">Dataset Details</h3>
        </div>
        <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
            <div id="detailContent">
                <p class="text-center text-gray-500 py-8">
                    <i class="fas fa-spinner fa-spin mr-2"></i>Loading...
                </p>
            </div>
        </div>
        <div class="modal-footer-wizard-neu">
            <div class="footer-left"></div>
            <div class="footer-right">
                <button onclick="viewGeneratedQuery()" class="btn-neu btn-neu-action btn-neu-nav-wide" style="width: 130px;">
                    <span class="btn-neu-inner" style="white-space: nowrap;">View SQL</span>
                </button>
                <button onclick="editDatasetFromDetail()" class="btn-neu btn-neu-action btn-neu-save" style="width: 130px;">
                    <span class="btn-neu-inner"><i class="fas fa-edit mr-1"></i>Edit</span>
                </button>
                <button onclick="closeDetailModal()" class="btn-neu btn-neu-action btn-neu-cancel" style="width: 130px;">
                    <span class="btn-neu-inner">Close</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Query Preview Modal -->
<div id="queryModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-lg">
        <div class="modal-header">
            <div class="modal-header-icon info">
                <i class="fas fa-code"></i>
            </div>
            <h3 class="modal-header-title">Generated SQL Query</h3>
        </div>
        <div class="modal-body">
            <p class="text-sm text-gray-500 mb-3">
                This is the base query that will be used to extract data from BigQuery.
                Train/eval split is configured in the Training domain.
            </p>
            <pre id="queryContent" class="bg-gray-900 text-green-400 p-4 rounded-lg text-sm overflow-x-auto" style="max-height: 400px;"></pre>
            <div id="queryValidation" class="mt-3 text-sm"></div>
        </div>
        <div class="modal-footer-wizard-neu">
            <div class="footer-left"></div>
            <div class="footer-right">
                <button onclick="copyQuery()" class="btn-neu btn-neu-action btn-neu-nav-wide">
                    <span class="btn-neu-inner"><i class="fas fa-copy mr-1"></i>Copy SQL</span>
                </button>
                <button onclick="closeQueryModal()" class="btn-neu btn-neu-action btn-neu-secondary">
                    <span class="btn-neu-inner">Close</span>
                </button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<!-- D3.js for charts -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// ============================================================================
// GLOBAL STATE
// ============================================================================
const modelId = {{ model.id }};
const csrftoken = document.querySelector('[name=csrfmiddleware-token]')?.value || '{{ csrf_token }}';

let currentWizardStep = 1;
let wizardEditMode = false;
let wizardEditDatasetId = null;
let searchTimeout = null;

// Wizard data state
let wizardData = {
    name: '',
    description: '',
    primaryTable: null,
    secondaryTables: [],
    joinConfig: {},
    selectedColumns: {},
    filters: {}
};

// Cached data
let availableTables = [];
let tableSchemas = {};
let currentDatasetId = null;
let currentQueries = {};

// Schema Builder State
let schemaBuilderState = {
    sessionId: null,
    tables: {},           // table metadata from load-samples
    selectedColumns: {},  // table -> [columns]
    joins: [],            // [{leftTable, leftCol, rightTable, rightCol, type}]
    connectMode: null,    // {table, column} when awaiting second click
    previewData: null,    // cached preview response
    selectedJoinIndex: null // for join popover
};

// Debounce timer for preview updates
let previewDebounceTimer = null;
const PREVIEW_DEBOUNCE_MS = 300;

// ============================================================================
// PAGE INITIALIZATION
// ============================================================================
document.addEventListener('DOMContentLoaded', function() {
    loadDatasets();
});

// ============================================================================
// DATASET LIST FUNCTIONS
// ============================================================================
function loadDatasets(page = 1) {
    const status = document.getElementById('statusFilter').value;
    const search = document.getElementById('searchInput').value;

    let url = `/api/models/${modelId}/datasets/?page=${page}&per_page=10`;
    if (status) url += `&status=${status}`;
    if (search) url += `&search=${encodeURIComponent(search)}`;

    fetch(url, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            renderDatasetsList(data.datasets);
            renderPagination(data.pagination);
        } else {
            showNotification(data.message || 'Failed to load datasets', 'error');
        }
    })
    .catch(error => {
        console.error('Error loading datasets:', error);
        showNotification('Failed to load datasets', 'error');
    });
}

function renderDatasetsList(datasets) {
    const container = document.getElementById('datasetsList');

    if (!datasets || datasets.length === 0) {
        container.innerHTML = `
            <div class="card-empty-state">
                <p class="card-empty-state-title">No datasets found</p>
                <p class="card-empty-state-text">Create your first dataset to define training data for your ML models</p>
            </div>
        `;
        return;
    }

    container.innerHTML = datasets.map(ds => {
        // Format description (truncate to 50 chars)
        const description = ds.description
            ? `${escapeHtml(ds.description.substring(0, 50))}${ds.description.length > 50 ? '...' : ''}`
            : 'N/A';

        // Format primary table (strip raw_data. prefix)
        const primaryTable = ds.primary_table
            ? ds.primary_table.replace('raw_data.', '')
            : 'N/A';

        // Format secondary tables count
        const secondaryCount = ds.secondary_tables?.length || 0;
        const secondaryText = secondaryCount === 0
            ? 'None'
            : `${secondaryCount} table${secondaryCount !== 1 ? 's' : ''}`;

        // Format stats from summary_snapshot
        const rowCount = ds.snapshot_total_rows != null
            ? formatNumber(ds.snapshot_total_rows)
            : 'N/A';
        const columnCount = ds.snapshot_column_count != null
            ? ds.snapshot_column_count
            : 'N/A';

        return `
        <div class="card">
            <div class="card-container-dataset">
                <!-- Column 1 (40%): Name + Description + Version -->
                <div class="card-content">
                    <div class="card-header">
                        <span class="status-dot green"></span>
                        <h4 class="card-title">${escapeHtml(ds.name)}</h4>
                    </div>
                    <div class="card-body">
                        <span class="card-value text-gray-500 text-xs">${description}</span>
                    </div>
                    <div class="card-version text-gray-400" style="font-size: 10px; margin-top: 2px;">
                        Version: ${ds.version_count || 1}
                    </div>
                </div>

                <!-- Column 2 (30%): Primary + Secondary Tables -->
                <div class="card-meta-column">
                    <span class="card-label">Primary:</span>
                    <span class="card-schedule-info">${primaryTable}</span>
                    <span class="card-label">Secondary:</span>
                    <span class="card-schedule-info">${secondaryText}</span>
                </div>

                <!-- Column 3 (15%): Dataset Stats -->
                <div class="card-meta-column">
                    <span class="card-label">Rows:</span>
                    <span class="card-schedule-info">${rowCount}</span>
                    <span class="card-label">Columns:</span>
                    <span class="card-schedule-info">${columnCount}</span>
                </div>

                <!-- Column 4 (10%): View Button -->
                <div class="card-run-actions">
                    <button onclick="viewDataset(${ds.id})" class="card-action-btn view" title="View details">
                        View
                    </button>
                </div>

                <!-- Column 5 (5%): Edit & Delete -->
                <div class="card-actions">
                    <button onclick="editDataset(${ds.id})" class="card-action-btn edit" title="Edit dataset">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button onclick="deleteDataset(${ds.id}, '${escapeHtml(ds.name)}')" class="card-action-btn delete" title="Delete dataset">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        </div>
        `;
    }).join('');
}

function renderPagination(pagination) {
    const container = document.getElementById('paginationContainer');
    const infoEl = document.getElementById('paginationInfo');
    const buttonsEl = document.getElementById('paginationButtons');

    if (pagination.total_pages <= 1) {
        container.classList.add('hidden');
        return;
    }

    container.classList.remove('hidden');

    const start = (pagination.page - 1) * pagination.per_page + 1;
    const end = Math.min(pagination.page * pagination.per_page, pagination.total);
    infoEl.textContent = `Showing ${start}-${end} of ${pagination.total} datasets`;

    let buttons = '';
    if (pagination.has_previous) {
        buttons += `<button onclick="loadDatasets(${pagination.page - 1})" class="btn btn-secondary btn-sm">Previous</button>`;
    }

    for (let i = 1; i <= pagination.total_pages; i++) {
        if (i === pagination.page) {
            buttons += `<button class="btn btn-primary btn-sm">${i}</button>`;
        } else if (i === 1 || i === pagination.total_pages || Math.abs(i - pagination.page) <= 1) {
            buttons += `<button onclick="loadDatasets(${i})" class="btn btn-secondary btn-sm">${i}</button>`;
        } else if (Math.abs(i - pagination.page) === 2) {
            buttons += `<span class="px-2 text-gray-500">...</span>`;
        }
    }

    if (pagination.has_next) {
        buttons += `<button onclick="loadDatasets(${pagination.page + 1})" class="btn btn-secondary btn-sm">Next</button>`;
    }

    buttonsEl.innerHTML = buttons;
}

function refreshDatasets() {
    loadDatasets();
    showNotification('Datasets refreshed', 'success');
}

function filterDatasets() {
    loadDatasets();
}

function debounceSearch() {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => loadDatasets(), 300);
}

// ============================================================================
// WIZARD FUNCTIONS
// ============================================================================
function openWizard(datasetId = null) {
    wizardEditMode = !!datasetId;
    wizardEditDatasetId = datasetId;

    // Reset wizard state
    currentWizardStep = 1;
    wizardData = {
        name: '',
        description: '',
        primaryTable: null,
        secondaryTables: [],
        joinConfig: {},
        selectedColumns: {},
        filters: {}
    };

    // Update UI
    document.getElementById('wizardTitle').textContent = wizardEditMode ? 'Edit Dataset' : 'Create Dataset';
    document.getElementById('saveButton').querySelector('.btn-neu-inner').textContent = 'Save';

    // Reset form fields
    document.getElementById('datasetName').value = '';
    document.getElementById('datasetDescription').value = '';
    document.getElementById('nameError').classList.add('hidden');
    document.getElementById('nameSuccess').classList.add('hidden');

    // Show modal
    document.getElementById('datasetWizardModal').classList.remove('hidden');

    // Load tables - wait for completion before loading edit data
    loadBqTables().then(() => {
        // If editing, load dataset data AFTER tables are loaded
        if (wizardEditMode) {
            loadDatasetForEdit(datasetId);
        }
    });

    showStep(1);
}

function closeWizard() {
    document.getElementById('datasetWizardModal').classList.add('hidden');
    resetWizard();
}

function resetWizard() {
    currentWizardStep = 1;
    wizardEditMode = false;
    wizardEditDatasetId = null;
    wizardData = {
        name: '',
        description: '',
        primaryTable: null,
        secondaryTables: [],
        joinConfig: {},
        selectedColumns: {},
        filters: {}
    };

    // Reset schema builder state
    schemaBuilderState = {
        sessionId: null,
        tables: {},
        selectedColumns: {},
        joins: [],
        connectMode: null,
        previewData: null,
        selectedJoinIndex: null
    };

    // Reset card positions
    cardPositions = {};

    // Reset product analysis state
    productAnalysisData = null;

    // Reset committed filter states (cross-sub-chapter tracking)
    committedDatesFilter.timestampColumn = null;
    productFiltersState.pending = {
        topRevenue: { enabled: false, productColumn: null, revenueColumn: null, thresholdPercent: 80 },
        aggregationFilters: [],
        categoryFilters: [],
        numericFilters: [],
        dateFilters: []
    };
    productFiltersState.committed = {
        topRevenue: { enabled: false, productColumn: null, revenueColumn: null, thresholdPercent: 80 },
        aggregationFilters: [],
        categoryFilters: [],
        numericFilters: [],
        dateFilters: []
    };
    productFiltersState.columnAnalysis = {};
    productFiltersState.selectedFilterColumn = null;

    // Reset customer filters state
    customerAnalysisData = null;
    customerFiltersApplied = false;
    customerFiltersState.pending = {
        topRevenue: { enabled: false, customerColumn: null, revenueColumn: null, thresholdPercent: 80 },
        aggregationFilters: [],
        categoryFilters: [],
        numericFilters: [],
        dateFilters: []
    };
    customerFiltersState.committed = {
        topRevenue: { enabled: false, customerColumn: null, revenueColumn: null, thresholdPercent: 80 },
        aggregationFilters: [],
        categoryFilters: [],
        numericFilters: [],
        dateFilters: []
    };
    customerFiltersState.columnAnalysis = {};
    customerFiltersState.selectedFilterColumn = null;

    // Reset filter UI elements
    const timestampSelect = document.getElementById('timestampColumn');
    if (timestampSelect) timestampSelect.selectedIndex = 0;

    const productSelect = document.getElementById('productIdColumn');
    if (productSelect) productSelect.selectedIndex = 0;

    const revenueSelect = document.getElementById('revenueColumn');
    if (revenueSelect) revenueSelect.selectedIndex = 0;

    const rollingDaysInput = document.getElementById('rollingDays');
    if (rollingDaysInput) rollingDaysInput.value = 30;

    const thresholdInput = document.getElementById('revenueThreshold');
    if (thresholdInput) thresholdInput.value = 80;

    // Reset sub-chapter summaries
    const historySummary = document.getElementById('historySummary');
    if (historySummary) historySummary.textContent = 'Last 30 days';

    const productsSummary = document.getElementById('productsSummary');
    if (productsSummary) productsSummary.textContent = 'All products included';

    const advancedSummary = document.getElementById('advancedSummary');
    if (advancedSummary) advancedSummary.textContent = 'No filters';

    // Hide analysis results
    const analysisResults = document.getElementById('productAnalysisResults');
    if (analysisResults) analysisResults.classList.add('hidden');

    const analysisError = document.getElementById('productAnalysisError');
    if (analysisError) analysisError.classList.add('hidden');

    // Clear chart
    const svg = document.getElementById('revenueDistributionChart');
    if (svg) svg.innerHTML = '';
}

function showStep(step) {
    // Update currentWizardStep FIRST so validation uses correct step
    currentWizardStep = step;

    // Hide all steps
    document.querySelectorAll('.wizard-step').forEach(s => s.classList.remove('active'));

    // Show target step
    document.getElementById(`step${step}`).classList.add('active');

    // Update step counter
    document.getElementById('currentStep').textContent = step;

    // Update progress bar - pill style classes (4 steps now)
    for (let i = 1; i <= 4; i++) {
        const pill = document.getElementById(`progress${i}`);
        pill.classList.remove('current', 'completed', 'future');
        if (i < step) {
            pill.classList.add('completed');
        } else if (i === step) {
            pill.classList.add('current');
        } else {
            pill.classList.add('future');
        }
    }

    // Update navigation buttons (uses currentWizardStep for validation)
    updateNavigationButtons(step);
}

function updateNavigationButtons(step) {
    const prevBtn = document.getElementById('prevButton');
    const nextBtn = document.getElementById('nextButton');
    const saveBtn = document.getElementById('saveButton');

    // Previous button
    if (step > 1) {
        prevBtn.classList.remove('hidden');
    } else {
        prevBtn.classList.add('hidden');
    }

    // Next/Save buttons (Step 4 is now the final step)
    if (step === 4) {
        nextBtn.classList.add('hidden');
        saveBtn.classList.remove('hidden');
    } else {
        nextBtn.classList.remove('hidden');
        saveBtn.classList.add('hidden');
    }

    // Enable/disable next based on validation
    validateCurrentStep();
}

function validateCurrentStep() {
    const nextBtn = document.getElementById('nextButton');
    const saveBtn = document.getElementById('saveButton');
    let isValid = false;

    switch (currentWizardStep) {
        case 1:
            const name = document.getElementById('datasetName').value.trim();
            isValid = name.length > 0;
            break;
        case 2:
            isValid = wizardData.primaryTable !== null;
            break;
        case 3:
            // At least one column must be selected (schema builder)
            const hasSelectedColumns = Object.values(schemaBuilderState.selectedColumns)
                .some(cols => cols && cols.length > 0);
            isValid = hasSelectedColumns;
            break;
        case 4:
            // Step 4 validation:
            // Dataset can be saved with or without filters - filters are optional
            // The dataset configuration from Step 3 (tables, columns, joins) is sufficient
            isValid = true;
            break;
    }

    nextBtn.disabled = !isValid;
    saveBtn.disabled = !isValid;
}

function nextStep() {
    if (currentWizardStep >= 4) return;  // Max step is now 4

    // Collect data from current step
    collectStepData(currentWizardStep);

    // Perform step-specific actions
    if (currentWizardStep === 1) {
        // Moving to step 2 - tables should already be loaded
    } else if (currentWizardStep === 2) {
        // Moving to step 3 - load schema builder with samples
        loadSchemaBuilder();
    } else if (currentWizardStep === 3) {
        // Moving to step 4 - collect columns and joins from schema builder
        collectSchemaBuilderData();
        // Fetch column analysis (types, stats) then populate filter dropdowns
        fetchColumnAnalysis().then(() => {
            // Populate filter dropdowns with selected columns (needs column types for timestamp filter)
            populateFilterColumnDropdowns();

            // In edit mode, restore saved filter states AFTER dropdowns are populated
            // restoreFiltersFromSavedData will also call fetchDatasetStats(true)
            if (wizardEditMode && wizardData.filters && Object.keys(wizardData.filters).length > 0) {
                restoreFiltersFromSavedData(wizardData.filters);
            } else {
                // Only fetch unfiltered stats for new datasets
                fetchDatasetStats(false);
            }
        });
    }

    showStep(currentWizardStep + 1);
}

function prevStep() {
    if (currentWizardStep <= 1) return;
    collectStepData(currentWizardStep);
    showStep(currentWizardStep - 1);
}

function collectStepData(step) {
    switch (step) {
        case 1:
            wizardData.name = document.getElementById('datasetName').value.trim();
            wizardData.description = document.getElementById('datasetDescription').value.trim();
            break;
        case 2:
            // Primary and secondary tables already tracked via selection
            break;
        case 3:
            // Schema builder data is collected via collectSchemaBuilderData()
            break;
        case 4:
            // Data Filters - New structure with sub-chapters

            // History filter (rolling window OR start date)
            const timestampCol = document.getElementById('timestampColumn')?.value;
            const rollingDays = parseInt(document.getElementById('rollingDays')?.value) || 30;
            const startDateValue = document.getElementById('startDateInput')?.value || null;

            if (timestampCol) {
                // Save based on the current filter mode
                // historyFilterMode is 'rolling' or 'startDate'
                if (historyFilterMode === 'startDate' && startDateValue) {
                    // Start Date mode - save start_date, no rolling_days
                    wizardData.filters.history = {
                        timestamp_column: timestampCol,
                        start_date: startDateValue
                    };
                } else {
                    // Rolling Window mode (default) - save rolling_days, no start_date
                    wizardData.filters.history = {
                        timestamp_column: timestampCol,
                        rolling_days: rollingDays
                    };
                }
            }

            // Products filter
            const productCol = document.getElementById('productIdColumn')?.value;
            const revenueCol = document.getElementById('revenueColumn')?.value;
            const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

            if (productCol && revenueCol && productAnalysisData) {
                wizardData.filters.products = {
                    product_column: productCol,
                    revenue_column: revenueCol,
                    threshold_type: 'cumulative_revenue',
                    threshold_percent: threshold,
                    cached_analysis: {
                        analyzed_at: new Date().toISOString(),
                        total_products: productAnalysisData.total_products,
                        selected_products: productAnalysisData.thresholds?.[String(threshold)]?.products ||
                            productAnalysisData.thresholds?.['80']?.products,
                        total_revenue: productAnalysisData.total_revenue,
                        selected_revenue: productAnalysisData.total_revenue * threshold / 100
                    }
                };
            }

            // Customer filter (advanced)
            if (document.getElementById('enableMinTransactions')?.checked) {
                wizardData.filters.customer_filter = {
                    type: 'min_transactions',
                    value: parseInt(document.getElementById('minTransactions').value)
                };
            }
            break;
    }
}

// ============================================================================
// STEP 1: NAME VALIDATION
// ============================================================================
let nameCheckTimeout = null;

function validateDatasetName() {
    const name = document.getElementById('datasetName').value.trim();
    const errorEl = document.getElementById('nameError');
    const successEl = document.getElementById('nameSuccess');

    errorEl.classList.add('hidden');
    successEl.classList.add('hidden');

    if (!name) {
        validateCurrentStep();
        return;
    }

    // Debounce the API call
    clearTimeout(nameCheckTimeout);
    nameCheckTimeout = setTimeout(() => {
        fetch(`/api/models/${modelId}/datasets/check-name/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                name: name,
                exclude_id: wizardEditDatasetId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.available) {
                successEl.classList.remove('hidden');
            } else {
                errorEl.textContent = data.message || 'Name already exists';
                errorEl.classList.remove('hidden');
            }
            validateCurrentStep();
        })
        .catch(error => {
            console.error('Error checking name:', error);
        });
    }, 300);

    validateCurrentStep();
}

// ============================================================================
// STEP 2: TABLE SELECTION
// ============================================================================
function loadBqTables() {
    return fetch(`/api/models/${modelId}/bq-tables/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            availableTables = data.tables;
            renderPrimaryTableList();
            return data.tables;
        } else {
            showNotification(data.message || 'Failed to load tables', 'error');
            return [];
        }
    })
    .catch(error => {
        console.error('Error loading tables:', error);
        document.getElementById('primaryTableList').innerHTML = `
            <p class="text-center text-red-500 py-4">
                <i class="fas fa-exclamation-circle mr-2"></i>Failed to load tables
            </p>
        `;
        return [];
    });
}

function renderPrimaryTableList() {
    const container = document.getElementById('primaryTableList');

    if (!availableTables || availableTables.length === 0) {
        container.innerHTML = `
            <p class="text-center text-gray-500 py-4">
                No tables found in raw_data dataset.<br>
                <span class="text-sm">Run an ETL job first to populate data.</span>
            </p>
        `;
        return;
    }

    container.innerHTML = availableTables.map(table => `
        <label class="wizard-selection-card mb-2 ${wizardData.primaryTable === table.full_name ? 'selected' : ''}">
            <input type="radio" name="primaryTable" value="${table.full_name}"
                   ${wizardData.primaryTable === table.full_name ? 'checked' : ''}
                   onchange="onPrimaryTableSelect('${table.full_name}')">
            <div class="card-content">
                <div class="card-title">${table.table_id}</div>
                <div class="card-description">
                    ${formatNumber(table.row_count)} rows | ${table.column_count} columns | ${formatBytes(table.size_bytes)}
                </div>
            </div>
        </label>
    `).join('');
}

function onPrimaryTableSelect(tableName) {
    wizardData.primaryTable = tableName;

    // Update selection styling
    document.querySelectorAll('#primaryTableList .wizard-selection-card').forEach(card => {
        card.classList.remove('selected');
    });
    document.querySelector(`#primaryTableList input[value="${tableName}"]`)?.closest('.wizard-selection-card')?.classList.add('selected');

    // Update secondary tables list
    renderSecondaryTableList();

    // Load schema for primary table
    loadTableSchema(tableName);

    validateCurrentStep();
}

function renderSecondaryTableList() {
    const container = document.getElementById('secondaryTableList');

    const otherTables = availableTables.filter(t => t.full_name !== wizardData.primaryTable);

    if (otherTables.length === 0) {
        container.innerHTML = `<p class="text-center text-gray-500 py-4">No additional tables available</p>`;
        return;
    }

    container.innerHTML = otherTables.map(table => `
        <label class="wizard-selection-card mb-2 ${wizardData.secondaryTables.includes(table.full_name) ? 'selected' : ''}">
            <input type="checkbox" value="${table.full_name}"
                   ${wizardData.secondaryTables.includes(table.full_name) ? 'checked' : ''}
                   onchange="onSecondaryTableToggle('${table.full_name}', this.checked)">
            <div class="card-content">
                <div class="card-title">${table.table_id}</div>
                <div class="card-description">
                    ${formatNumber(table.row_count)} rows | ${table.column_count} columns
                </div>
            </div>
        </label>
    `).join('');
}

function onSecondaryTableToggle(tableName, isChecked) {
    if (isChecked) {
        if (!wizardData.secondaryTables.includes(tableName)) {
            wizardData.secondaryTables.push(tableName);
            loadTableSchema(tableName);
        }
    } else {
        wizardData.secondaryTables = wizardData.secondaryTables.filter(t => t !== tableName);
        delete wizardData.joinConfig[tableName];
    }

    // Update selection styling
    const card = document.querySelector(`#secondaryTableList input[value="${tableName}"]`)?.closest('.wizard-selection-card');
    if (card) {
        card.classList.toggle('selected', isChecked);
    }

    // Show/hide join config section (if it exists - joins are now done in Step 3 Schema Builder)
    const joinSection = document.getElementById('joinConfigSection');
    if (joinSection) {
        if (wizardData.secondaryTables.length > 0) {
            joinSection.classList.remove('hidden');
            renderJoinConfig();
        } else {
            joinSection.classList.add('hidden');
        }
    }
}

function renderJoinConfig() {
    const container = document.getElementById('joinConfigList');
    if (!container) return; // Join config UI removed - joins are done in Step 3 Schema Builder

    container.innerHTML = wizardData.secondaryTables.map(tableName => {
        const shortName = tableName.replace('raw_data.', '');
        const config = wizardData.joinConfig[tableName] || {};
        const primarySchema = tableSchemas[wizardData.primaryTable] || [];
        const secondarySchema = tableSchemas[tableName] || [];

        return `
            <div class="p-3 border border-gray-200 rounded-lg bg-gray-50">
                <div class="font-medium text-sm mb-2">${shortName}</div>
                <div class="grid grid-cols-3 gap-2">
                    <div>
                        <label class="text-xs text-gray-600">Primary Key</label>
                        <select class="form-select w-full text-xs" onchange="updateJoinConfig('${tableName}', 'primary_key', this.value)">
                            <option value="">Select...</option>
                            ${primarySchema.map(col => `<option value="${col.name}" ${config.primary_key === col.name ? 'selected' : ''}>${col.name}</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label class="text-xs text-gray-600">Join Key</label>
                        <select class="form-select w-full text-xs" onchange="updateJoinConfig('${tableName}', 'join_key', this.value)">
                            <option value="">Select...</option>
                            ${secondarySchema.map(col => `<option value="${col.name}" ${config.join_key === col.name ? 'selected' : ''}>${col.name}</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label class="text-xs text-gray-600">Join Type</label>
                        <select class="form-select w-full text-xs" onchange="updateJoinConfig('${tableName}', 'join_type', this.value)">
                            <option value="LEFT" ${config.join_type === 'LEFT' ? 'selected' : ''}>LEFT JOIN</option>
                            <option value="INNER" ${config.join_type === 'INNER' ? 'selected' : ''}>INNER JOIN</option>
                        </select>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

function updateJoinConfig(tableName, field, value) {
    if (!wizardData.joinConfig[tableName]) {
        wizardData.joinConfig[tableName] = { join_type: 'LEFT' };
    }
    wizardData.joinConfig[tableName][field] = value;
}

function detectJoins() {
    const tables = [wizardData.primaryTable, ...wizardData.secondaryTables];

    fetch(`/api/models/${modelId}/detect-joins/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({ tables: tables })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success' && data.detected_joins) {
            // Apply detected joins
            data.detected_joins.forEach(join => {
                if (wizardData.secondaryTables.includes(join.table2)) {
                    wizardData.joinConfig[join.table2] = {
                        primary_key: join.column1,
                        join_key: join.column2,
                        join_type: 'LEFT'
                    };
                }
            });
            renderJoinConfig();
            showNotification('Joins detected successfully', 'success');
        } else {
            showNotification('No obvious joins detected. Please configure manually.', 'warning');
        }
    })
    .catch(error => {
        console.error('Error detecting joins:', error);
        showNotification('Failed to detect joins', 'error');
    });
}

function loadTableSchema(tableName) {
    if (tableSchemas[tableName]) return; // Already loaded

    fetch(`/api/models/${modelId}/bq-tables/${encodeURIComponent(tableName.replace('raw_data.', ''))}/schema/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            tableSchemas[tableName] = data.schema;
            // Re-render join config if needed
            if (wizardData.secondaryTables.length > 0) {
                renderJoinConfig();
            }
        }
    })
    .catch(error => {
        console.error('Error loading schema:', error);
    });
}

// ============================================================================
// STEP 3: VISUAL SCHEMA BUILDER
// ============================================================================

function loadSchemaBuilder() {
    const allTables = [wizardData.primaryTable, ...wizardData.secondaryTables].filter(Boolean);
    const container = document.getElementById('schemaCardsContainer');

    if (allTables.length === 0) {
        container.innerHTML = `
            <div class="schema-loading" id="schemaLoading">
                <i class="fas fa-exclamation-triangle"></i>
                No tables selected. Go back to Step 2.
            </div>
        `;
        return Promise.resolve();
    }

    // Show loading state - replace container content with loading indicator
    container.innerHTML = `
        <div class="schema-loading" id="schemaLoading" style="display: flex;">
            <i class="fas fa-spinner fa-spin"></i>
            Loading table samples...
        </div>
    `;

    // Reset schema builder state
    schemaBuilderState = {
        sessionId: null,
        tables: {},
        selectedColumns: {},
        joins: [],
        connectMode: null,
        previewData: null,
        selectedJoinIndex: null
    };

    // Reset card positions so tables are re-positioned fresh
    cardPositions = {};

    // Load samples from backend - return Promise so caller can await
    return fetch(`/api/models/${modelId}/datasets/load-samples/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({ tables: allTables })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            schemaBuilderState.sessionId = data.session_id;
            schemaBuilderState.tables = data.tables;

            // Initialize selected columns (all by default)
            Object.keys(data.tables).forEach(table => {
                const columns = data.tables[table].columns || [];
                schemaBuilderState.selectedColumns[table] = columns.map(c => c.name);
            });

            // Render table cards
            renderTableCards();

            // In edit mode, restore joins from wizardData.joinConfig
            if (wizardEditMode && wizardData.joinConfig && Object.keys(wizardData.joinConfig).length > 0) {
                Object.entries(wizardData.joinConfig).forEach(([secondaryTable, config]) => {
                    if (config.join_key && config.secondary_column) {
                        schemaBuilderState.joins.push({
                            leftTable: wizardData.primaryTable,
                            leftCol: config.join_key,
                            rightTable: secondaryTable,
                            rightCol: config.secondary_column,
                            type: config.join_type || 'left'
                        });
                    }
                });
                // Redraw connection lines after restoring joins
                setTimeout(updateConnectionLines, 100);
            }

            // In edit mode, restore selected columns from wizardData
            if (wizardEditMode && wizardData.selectedColumns && Object.keys(wizardData.selectedColumns).length > 0) {
                Object.entries(wizardData.selectedColumns).forEach(([table, columns]) => {
                    if (schemaBuilderState.selectedColumns[table]) {
                        schemaBuilderState.selectedColumns[table] = [...columns];
                    }
                });
                // Re-render table cards to reflect selected columns
                renderTableCards();
                setTimeout(updateConnectionLines, 100);
            }

            // Refresh preview
            refreshPreview();

            // Re-validate step after schema is loaded
            validateCurrentStep();
        } else {
            document.getElementById('schemaCardsContainer').innerHTML = `
                <div class="schema-preview-empty">
                    <i class="fas fa-exclamation-triangle"></i>
                    Error loading samples: ${data.message}
                </div>
            `;
        }
    })
    .catch(error => {
        console.error('Error loading schema builder:', error);
        document.getElementById('schemaCardsContainer').innerHTML = `
            <div class="schema-preview-empty">
                <i class="fas fa-exclamation-triangle"></i>
                Failed to load table samples
            </div>
        `;
    });
}

// Store card positions
let cardPositions = {};

function renderTableCards() {
    const container = document.getElementById('schemaCardsContainer');
    const allTables = [wizardData.primaryTable, ...wizardData.secondaryTables].filter(Boolean);

    let html = '';

    allTables.forEach((table, index) => {
        const tableData = schemaBuilderState.tables[table] || {};
        const columns = tableData.columns || [];
        const isPrimary = index === 0;
        const shortName = table.replace('raw_data.', '');
        const selectedCols = schemaBuilderState.selectedColumns[table] || [];
        const showLimit = 10;
        const hasMore = columns.length > showLimit;

        html += `
            <div class="schema-table-card ${isPrimary ? 'primary' : ''}" data-table="${table}" id="card_${shortName}">
                <div class="schema-card-header" onmousedown="startDrag(event, '${table}')">
                    <div class="schema-card-title">
                        <i class="fas fa-table"></i>
                        ${shortName}
                    </div>
                    <span class="schema-card-badge ${isPrimary ? 'primary' : 'secondary'}">
                        ${isPrimary ? 'Primary' : 'Secondary'}
                    </span>
                </div>
                <div class="schema-column-list ${hasMore ? 'collapsed' : ''}" id="columnList_${shortName}">
                    ${columns.slice(0, showLimit).map(col => renderColumnItem(table, col, selectedCols, isPrimary)).join('')}
                </div>
                ${hasMore ? `
                    <div class="schema-column-expander" id="expander_${shortName}" onclick="toggleColumnExpander('${table}', '${shortName}')">
                        Show ${columns.length - showLimit} more...
                    </div>
                ` : ''}
            </div>
        `;
    });

    container.innerHTML = html;

    // Position cards: primary in center, secondary around it
    positionCardsInitially(allTables);

    // Setup drag handlers
    setupDragHandlers();

    // Setup scroll handlers for column lists to update connection lines
    setupColumnScrollHandlers();

    // Update connection lines after a short delay to ensure cards are positioned
    setTimeout(updateConnectionLines, 50);
}

// Setup scroll event listeners on column lists to update connection lines when scrolling
function setupColumnScrollHandlers() {
    document.querySelectorAll('.schema-column-list').forEach(list => {
        list.addEventListener('scroll', () => {
            updateConnectionLines();
        });
    });
}

function positionCardsInitially(allTables) {
    const container = document.getElementById('schemaCardsContainer');
    const containerRect = container.getBoundingClientRect();

    // Use fixed dimensions based on CSS if container not yet sized
    const containerWidth = Math.max(containerRect.width, 900);
    const containerHeight = Math.max(containerRect.height, 350);

    const cardWidth = 220;
    const cardHeight = 280; // Approximate card height including columns
    const horizontalGap = 40; // Gap between cards

    // Calculate positions for all tables first
    const numTables = allTables.length;

    allTables.forEach((table, index) => {
        const shortName = table.replace('raw_data.', '');
        const card = document.getElementById(`card_${shortName}`);
        if (!card) return;

        let x, y;

        // Check if we have saved positions
        if (cardPositions[table]) {
            x = cardPositions[table].x;
            y = cardPositions[table].y;
        } else {
            // Calculate horizontal layout: distribute cards evenly across container width
            // Total width needed: numTables * cardWidth + (numTables - 1) * gap
            const totalCardsWidth = numTables * cardWidth + (numTables - 1) * horizontalGap;
            const startX = Math.max(20, (containerWidth - totalCardsWidth) / 2);

            // Position each card in a row
            x = startX + index * (cardWidth + horizontalGap);
            y = (containerHeight - cardHeight) / 2;

            // Keep within bounds
            x = Math.max(10, Math.min(x, containerWidth - cardWidth - 10));
            y = Math.max(10, Math.min(y, containerHeight - cardHeight - 10));
        }

        card.style.left = x + 'px';
        card.style.top = y + 'px';

        // Save position
        cardPositions[table] = { x, y };
    });
}

// Drag state
let dragState = {
    isDragging: false,
    table: null,
    startX: 0,
    startY: 0,
    cardStartX: 0,
    cardStartY: 0
};

function setupDragHandlers() {
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);
}

function startDrag(event, table) {
    // Don't start drag if clicking on checkbox or other interactive elements
    if (event.target.tagName === 'INPUT' || event.target.closest('.schema-connection-dot')) {
        return;
    }

    event.preventDefault();

    const shortName = table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    if (!card) return;

    dragState = {
        isDragging: true,
        table: table,
        startX: event.clientX,
        startY: event.clientY,
        cardStartX: parseInt(card.style.left) || 0,
        cardStartY: parseInt(card.style.top) || 0
    };

    card.classList.add('dragging');
}

function onDragMove(event) {
    if (!dragState.isDragging) return;

    const shortName = dragState.table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    if (!card) return;

    const container = document.getElementById('schemaCardsContainer');
    const containerRect = container.getBoundingClientRect();

    const deltaX = event.clientX - dragState.startX;
    const deltaY = event.clientY - dragState.startY;

    let newX = dragState.cardStartX + deltaX;
    let newY = dragState.cardStartY + deltaY;

    // Keep within container bounds
    const cardRect = card.getBoundingClientRect();
    const maxX = containerRect.width - cardRect.width;
    const maxY = containerRect.height - cardRect.height;

    newX = Math.max(0, Math.min(newX, maxX));
    newY = Math.max(0, Math.min(newY, maxY));

    card.style.left = newX + 'px';
    card.style.top = newY + 'px';

    // Save position
    cardPositions[dragState.table] = { x: newX, y: newY };

    // Update connection lines while dragging
    updateConnectionLines();
}

function onDragEnd(event) {
    if (!dragState.isDragging) return;

    const shortName = dragState.table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    if (card) {
        card.classList.remove('dragging');
    }

    dragState.isDragging = false;
    dragState.table = null;

    // Final update of connection lines
    updateConnectionLines();
}

function renderColumnItem(table, col, selectedCols, isPrimary) {
    const shortTable = table.replace('raw_data.', '');
    const isSelected = selectedCols.includes(col.name);

    // Determine if column is a recommended join key based on schema flag OR naming patterns
    const colLower = col.name.toLowerCase();
    const keyPatterns = ['_id', 'id_', '_key', 'key_', '_code', 'code_'];
    const isRecommendedJoinKey = col.is_potential_join_key ||
                      keyPatterns.some(p => colLower.includes(p)) ||
                      colLower === 'id';

    const isConnected = schemaBuilderState.joins.some(j =>
        (j.leftCol === col.name && wizardData.primaryTable === table) ||
        (j.rightCol === col.name && j.rightTable === table)
    );

    // Determine what to show in the connection area:
    // - Connected: colored dot (always visible)
    // - Recommended but not connected: empty dot (always visible)
    // - Not recommended and not connected: "+" on hover
    let connectionElement;
    if (isConnected) {
        // Connected column - show colored dot
        connectionElement = `
            <div class="schema-connection-dot connected"
                 data-table="${table}" data-column="${col.name}"
                 onclick="onConnectionDotClick('${table}', '${col.name}', event)"></div>
        `;
    } else if (isRecommendedJoinKey) {
        // Recommended join key - show empty dot
        connectionElement = `
            <div class="schema-connection-dot recommended"
                 data-table="${table}" data-column="${col.name}"
                 onclick="onConnectionDotClick('${table}', '${col.name}', event)"></div>
        `;
    } else {
        // Regular column - show "+" on hover
        connectionElement = `
            <div class="schema-connection-plus"
                 data-table="${table}" data-column="${col.name}"
                 onclick="onConnectionDotClick('${table}', '${col.name}', event)">+</div>
        `;
    }

    return `
        <div class="schema-column-item ${isConnected ? 'connected' : ''}" data-table="${table}" data-column="${col.name}"
             data-type="${col.type || 'unknown'}">
            <input type="checkbox" ${isSelected ? 'checked' : ''}
                   onchange="onColumnCheckChange('${table}', '${col.name}', this.checked)">
            <span class="schema-column-name">${col.name}</span>
            <span class="schema-column-type">${col.type?.substring(0, 3)?.toLowerCase() || ''}</span>
            ${connectionElement}
        </div>
    `;
}

function toggleColumnExpander(table, shortName) {
    const columnList = document.getElementById(`columnList_${shortName}`);
    const expander = document.getElementById(`expander_${shortName}`);
    const tableData = schemaBuilderState.tables[table] || {};
    const columns = tableData.columns || [];
    const selectedCols = schemaBuilderState.selectedColumns[table] || [];
    const isPrimary = table === wizardData.primaryTable;

    if (columnList.classList.contains('collapsed')) {
        // Expand - show all columns
        columnList.classList.remove('collapsed');
        columnList.innerHTML = columns.map(col => renderColumnItem(table, col, selectedCols, isPrimary)).join('');
        expander.textContent = 'Show less';
    } else {
        // Collapse - show first 10
        columnList.classList.add('collapsed');
        columnList.innerHTML = columns.slice(0, 10).map(col => renderColumnItem(table, col, selectedCols, isPrimary)).join('');
        expander.textContent = `Show ${columns.length - 10} more...`;
    }

    updateConnectionLines();
}

function onColumnCheckChange(table, column, isChecked) {
    if (!schemaBuilderState.selectedColumns[table]) {
        schemaBuilderState.selectedColumns[table] = [];
    }

    if (isChecked) {
        if (!schemaBuilderState.selectedColumns[table].includes(column)) {
            schemaBuilderState.selectedColumns[table].push(column);
        }
    } else {
        schemaBuilderState.selectedColumns[table] = schemaBuilderState.selectedColumns[table].filter(c => c !== column);
    }

    validateCurrentStep();
    debouncedRefreshPreview();
}

// Connection dot/plus click handling
function onConnectionDotClick(table, column, event) {
    // Get click position for popover
    const clickX = event ? event.clientX : 0;
    const clickY = event ? event.clientY : 0;

    const connectMode = schemaBuilderState.connectMode;

    if (!connectMode) {
        // Start connect mode
        schemaBuilderState.connectMode = { table, column };

        // Show source column info popover
        showColumnInfoPopover(table, column, clickX, clickY, true);

        // Highlight source element and valid targets
        highlightConnectModeElements(table, column);

        // Add event listeners for cancel actions
        document.addEventListener('keydown', handleConnectModeKeydown);
        document.addEventListener('click', handleConnectModeOutsideClick, true);

    } else {
        // Complete or cancel connection
        if (connectMode.table === table && connectMode.column === column) {
            // Clicked same element - cancel
            exitConnectMode();
        } else if (connectMode.table !== table) {
            // Valid target - create join
            createJoin(connectMode.table, connectMode.column, table, column);
            exitConnectMode();
        }
        // If same table but different column - ignore
    }
}

// Highlight elements during connect mode
function highlightConnectModeElements(sourceTable, sourceColumn) {
    // Highlight source dot/plus
    document.querySelectorAll('.schema-connection-dot, .schema-connection-plus').forEach(el => {
        if (el.dataset.table === sourceTable && el.dataset.column === sourceColumn) {
            el.classList.add('connect-mode');
        } else if (el.dataset.table !== sourceTable) {
            // Highlight valid targets (different table)
            el.classList.add('connect-mode-target');
        }
    });

    // Add hover listeners for target columns
    document.querySelectorAll('.schema-column-item').forEach(item => {
        if (item.dataset.table !== sourceTable) {
            item.addEventListener('mouseenter', handleTargetColumnHover);
            item.addEventListener('mouseleave', handleTargetColumnLeave);
        }
    });
}

// Handle hover on target column during connect mode
function handleTargetColumnHover(event) {
    const item = event.currentTarget;
    const table = item.dataset.table;
    const column = item.dataset.column;

    if (!schemaBuilderState.connectMode || table === schemaBuilderState.connectMode.table) {
        return;
    }

    // Get column type for compatibility check
    const sourceType = getColumnType(schemaBuilderState.connectMode.table, schemaBuilderState.connectMode.column);
    const targetType = getColumnType(table, column);
    const isCompatible = checkTypeCompatibility(sourceType, targetType);

    // Show target popover near cursor
    showColumnInfoPopover(table, column, event.clientX + 15, event.clientY + 15, false, sourceType, isCompatible);
}

// Handle mouse leave on target column
function handleTargetColumnLeave(event) {
    // Hide target info but keep source info
    if (schemaBuilderState.connectMode) {
        const popover = document.getElementById('columnInfoPopover');
        // Reset to source info
        showColumnInfoPopover(
            schemaBuilderState.connectMode.table,
            schemaBuilderState.connectMode.column,
            parseInt(popover.style.left),
            parseInt(popover.style.top),
            true
        );
    }
}

// Get column type from state
function getColumnType(table, column) {
    const tableData = schemaBuilderState.tables[table];
    if (!tableData || !tableData.columns) return 'unknown';

    const col = tableData.columns.find(c => c.name === column);
    return col ? col.type : 'unknown';
}

// Get sample values for a column
function getColumnSamples(table, column) {
    const tableData = schemaBuilderState.tables[table];
    if (!tableData || !tableData.sample_preview) return [];

    return tableData.sample_preview
        .map(row => row[column])
        .filter(v => v !== null && v !== undefined)
        .slice(0, 5);
}

// Format sample values for display
function formatSampleValues(samples) {
    if (!samples || samples.length === 0) return 'No samples';

    return samples.map(v => {
        if (typeof v === 'string') {
            // Truncate long strings
            return v.length > 15 ? `"${v.substring(0, 15)}..."` : `"${v}"`;
        }
        return String(v);
    }).join(', ');
}

// Check if two types are compatible for joining
function checkTypeCompatibility(type1, type2) {
    if (!type1 || !type2 || type1 === 'unknown' || type2 === 'unknown') {
        return true; // Allow if unknown
    }

    // Normalize types
    const normalize = (t) => {
        t = t.toUpperCase();
        if (t.includes('INT')) return 'INTEGER';
        if (t.includes('FLOAT') || t.includes('NUMERIC') || t.includes('DECIMAL')) return 'NUMERIC';
        if (t.includes('STRING') || t.includes('VARCHAR') || t.includes('CHAR')) return 'STRING';
        if (t.includes('DATE') || t.includes('TIME')) return 'DATETIME';
        if (t.includes('BOOL')) return 'BOOLEAN';
        return t;
    };

    const n1 = normalize(type1);
    const n2 = normalize(type2);

    // Same normalized type
    if (n1 === n2) return true;

    // Numeric types can join together
    if ((n1 === 'INTEGER' || n1 === 'NUMERIC') && (n2 === 'INTEGER' || n2 === 'NUMERIC')) {
        return true;
    }

    return false;
}

// Show column info popover
function showColumnInfoPopover(table, column, x, y, isSource, sourceType = null, isCompatible = true) {
    const popover = document.getElementById('columnInfoPopover');
    const type = getColumnType(table, column);
    const samples = getColumnSamples(table, column);

    // Update popover content
    document.getElementById('columnInfoName').textContent = column;
    document.getElementById('columnInfoTypeValue').textContent = type || 'unknown';
    document.getElementById('columnInfoSamplesValue').textContent = formatSampleValues(samples);

    // Show/hide hint, warning, compatible messages
    const hintEl = document.getElementById('columnInfoHint');
    const warningEl = document.getElementById('columnInfoWarning');
    const compatibleEl = document.getElementById('columnInfoCompatible');

    if (isSource) {
        hintEl.classList.remove('hidden');
        warningEl.classList.add('hidden');
        compatibleEl.classList.add('hidden');
    } else {
        hintEl.classList.add('hidden');

        if (!isCompatible) {
            warningEl.classList.remove('hidden');
            compatibleEl.classList.add('hidden');
            document.getElementById('columnInfoWarningText').textContent =
                `Type mismatch: ${sourceType}  ${type}`;
        } else {
            warningEl.classList.add('hidden');
            compatibleEl.classList.remove('hidden');
        }
    }

    // Position popover
    popover.style.left = `${x + 10}px`;
    popover.style.top = `${y + 10}px`;

    // Ensure popover stays within viewport
    const rect = popover.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    if (rect.right > viewportWidth) {
        popover.style.left = `${x - rect.width - 10}px`;
    }
    if (rect.bottom > viewportHeight) {
        popover.style.top = `${y - rect.height - 10}px`;
    }

    popover.classList.remove('hidden');
}

// Hide column info popover
function hideColumnInfoPopover() {
    document.getElementById('columnInfoPopover').classList.add('hidden');
}

// Handle Escape key to cancel connect mode
function handleConnectModeKeydown(event) {
    if (event.key === 'Escape') {
        exitConnectMode();
    }
}

// Handle click outside to cancel connect mode
function handleConnectModeOutsideClick(event) {
    // Check if click is on a connection element
    const isConnectionElement = event.target.closest('.schema-connection-dot, .schema-connection-plus');
    const isColumnItem = event.target.closest('.schema-column-item');

    if (!isConnectionElement && !isColumnItem) {
        exitConnectMode();
    }
}

function exitConnectMode() {
    schemaBuilderState.connectMode = null;

    // Remove highlight classes
    document.querySelectorAll('.schema-connection-dot, .schema-connection-plus').forEach(el => {
        el.classList.remove('connect-mode', 'connect-mode-target');
    });

    // Remove hover listeners
    document.querySelectorAll('.schema-column-item').forEach(item => {
        item.removeEventListener('mouseenter', handleTargetColumnHover);
        item.removeEventListener('mouseleave', handleTargetColumnLeave);
    });

    // Remove event listeners
    document.removeEventListener('keydown', handleConnectModeKeydown);
    document.removeEventListener('click', handleConnectModeOutsideClick, true);

    // Hide popover
    hideColumnInfoPopover();
}

function createJoin(leftTable, leftCol, rightTable, rightCol) {
    // Ensure primary table is always on the left
    if (leftTable !== wizardData.primaryTable && rightTable === wizardData.primaryTable) {
        [leftTable, leftCol, rightTable, rightCol] = [rightTable, rightCol, leftTable, leftCol];
    }

    // Check if join already exists
    const existingIndex = schemaBuilderState.joins.findIndex(j =>
        j.rightTable === rightTable
    );

    const joinData = {
        leftTable,
        leftCol,
        rightTable,
        rightCol,
        type: 'left',
        warning: null  // Will be populated if join key is not unique
    };

    if (existingIndex >= 0) {
        // Update existing join
        schemaBuilderState.joins[existingIndex] = joinData;
    } else {
        // Add new join
        schemaBuilderState.joins.push(joinData);
    }

    renderTableCards();
    refreshPreview();

    // Check join key uniqueness on the secondary table (async)
    checkJoinKeyUniqueness(rightTable, rightCol, existingIndex >= 0 ? existingIndex : schemaBuilderState.joins.length - 1);
}

async function checkJoinKeyUniqueness(table, column, joinIndex) {
    try {
        // Extract table name without schema prefix for API
        const tableName = table.replace('raw_data.', '');

        const response = await fetch(`/api/models/${modelId}/bq-tables/${tableName}/columns/${column}/check-uniqueness/`);
        const data = await response.json();

        if (data.status === 'success' && !data.is_unique) {
            // Store warning in join data
            if (schemaBuilderState.joins[joinIndex]) {
                schemaBuilderState.joins[joinIndex].warning = data.warning;
                schemaBuilderState.joins[joinIndex].duplicationFactor = data.duplication_factor;
            }

            // Show warning notification
            const shortTable = table.replace('raw_data.', '');
            showNotification(
                `Warning: Joining on '${column}' in '${shortTable}' will multiply rows by ~${data.duplication_factor}x because the column is not unique.`,
                'warning',
                'Non-Unique Join Key'
            );

            // Re-render to show warning indicator on join line
            renderTableCards();
        }
    } catch (error) {
        console.error('Error checking join key uniqueness:', error);
        // Don't block the user - just log the error
    }
}

function removeJoin(index) {
    schemaBuilderState.joins.splice(index, 1);
    renderTableCards();
    refreshPreview();
    hideJoinPopover();
}

function setJoinType(type) {
    if (schemaBuilderState.selectedJoinIndex !== null) {
        schemaBuilderState.joins[schemaBuilderState.selectedJoinIndex].type = type;
        refreshPreview();
        hideJoinPopover();
    }
}

function removeSelectedJoin() {
    if (schemaBuilderState.selectedJoinIndex !== null) {
        removeJoin(schemaBuilderState.selectedJoinIndex);
    }
}

function showJoinPopover(index, x, y) {
    schemaBuilderState.selectedJoinIndex = index;
    const popover = document.getElementById('joinPopover');
    const join = schemaBuilderState.joins[index];

    // Update active state for join type options
    popover.querySelectorAll('.join-popover-option[data-type]').forEach(opt => {
        opt.classList.toggle('active', opt.dataset.type === join.type);
    });

    // Show/hide warning section
    const warningEl = document.getElementById('joinPopoverWarning');
    const warningTextEl = document.getElementById('joinPopoverWarningText');
    if (join.warning) {
        warningEl.classList.remove('hidden');
        warningTextEl.textContent = join.warning;
    } else {
        warningEl.classList.add('hidden');
    }

    popover.style.left = x + 'px';
    popover.style.top = y + 'px';
    popover.classList.remove('hidden');
}

function hideJoinPopover() {
    schemaBuilderState.selectedJoinIndex = null;
    document.getElementById('joinPopover').classList.add('hidden');
}

// Color palette for connection lines
const JOIN_COLORS = [
    '#2563eb', // Blue
    '#16a34a', // Green
    '#dc2626', // Red
    '#9333ea', // Purple
    '#ea580c', // Orange
    '#0891b2', // Cyan
    '#c026d3', // Fuchsia
    '#ca8a04', // Yellow
];

// Get anchor point for a column, handling scrolled/clipped columns
function getColumnAnchorPoint(table, column, side, areaRect, cardsArea) {
    const shortName = table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    const columnEl = document.querySelector(`.schema-column-item[data-table="${table}"][data-column="${column}"]`);

    if (!card || !columnEl) {
        return null;
    }

    const cardRect = card.getBoundingClientRect();
    const columnRect = columnEl.getBoundingClientRect();

    // Find the scrollable column list container
    const columnList = card.querySelector('.schema-column-list');
    const listRect = columnList ? columnList.getBoundingClientRect() : cardRect;

    // Determine X coordinate based on which side to connect
    const x = side === 'right' ? cardRect.right : cardRect.left;

    // Calculate column's vertical center
    const columnCenterY = columnRect.top + columnRect.height / 2;

    // Check if column is visible within the scrollable area
    let y = columnCenterY;
    let isClipped = false;
    let clipDirection = null;

    if (columnList) {
        if (columnRect.bottom < listRect.top) {
            // Column is scrolled above visible area
            y = listRect.top + 10;
            isClipped = true;
            clipDirection = 'up';
        } else if (columnRect.top > listRect.bottom) {
            // Column is scrolled below visible area
            y = listRect.bottom - 10;
            isClipped = true;
            clipDirection = 'down';
        } else if (columnRect.top < listRect.top) {
            // Column is partially clipped at top
            y = listRect.top + 5;
            isClipped = true;
            clipDirection = 'up';
        } else if (columnRect.bottom > listRect.bottom) {
            // Column is partially clipped at bottom
            y = listRect.bottom - 5;
            isClipped = true;
            clipDirection = 'down';
        }
    }

    // Convert to SVG coordinates (relative to cards area)
    return {
        x: x - areaRect.left + cardsArea.scrollLeft,
        y: y - areaRect.top + cardsArea.scrollTop,
        isClipped,
        clipDirection
    };
}

// Determine which side each card should connect from based on relative positions
function getConnectionSides(leftCard, rightCard) {
    const leftRect = leftCard.getBoundingClientRect();
    const rightRect = rightCard.getBoundingClientRect();

    const leftCenterX = leftRect.left + leftRect.width / 2;
    const rightCenterX = rightRect.left + rightRect.width / 2;

    if (leftCenterX < rightCenterX) {
        // Left card is actually on the left
        return { leftSide: 'right', rightSide: 'left' };
    } else {
        // Left card is actually on the right
        return { leftSide: 'left', rightSide: 'right' };
    }
}

function updateConnectionLines() {
    const svg = document.getElementById('connectionsSvg');
    const cardsArea = document.getElementById('schemaCardsArea');

    // Clear existing lines
    svg.innerHTML = '';

    // Reset all connection dot colors first
    document.querySelectorAll('.schema-connection-dot.connected').forEach(dot => {
        dot.style.borderColor = '';
        dot.style.backgroundColor = '';
    });

    // Draw lines for each join
    schemaBuilderState.joins.forEach((join, index) => {
        // Get the card elements
        const leftCard = document.querySelector(`.schema-table-card[data-table="${join.leftTable}"]`);
        const rightCard = document.querySelector(`.schema-table-card[data-table="${join.rightTable}"]`);

        if (leftCard && rightCard) {
            const areaRect = cardsArea.getBoundingClientRect();

            // Determine which side each card should connect from
            const sides = getConnectionSides(leftCard, rightCard);

            // Get column-level anchor points
            const leftAnchor = getColumnAnchorPoint(join.leftTable, join.leftCol, sides.leftSide, areaRect, cardsArea);
            const rightAnchor = getColumnAnchorPoint(join.rightTable, join.rightCol, sides.rightSide, areaRect, cardsArea);

            // If we couldn't find the columns, fall back to card-level connection
            if (!leftAnchor || !rightAnchor) {
                const leftCardRect = leftCard.getBoundingClientRect();
                const rightCardRect = rightCard.getBoundingClientRect();
                const connection = calculateBestConnectionPoints(leftCardRect, rightCardRect, areaRect, cardsArea);
                drawConnectionLine(svg, connection.x1, connection.y1, connection.x2, connection.y2, index, areaRect, false, false, null, null);
                return;
            }

            // Get color for this join
            const color = JOIN_COLORS[index % JOIN_COLORS.length];

            // Draw the connection line (pass warning info)
            const hasWarning = join.warning !== null;
            drawConnectionLine(svg, leftAnchor.x, leftAnchor.y, rightAnchor.x, rightAnchor.y, index, areaRect,
                leftAnchor.isClipped, rightAnchor.isClipped, leftAnchor.clipDirection, rightAnchor.clipDirection, hasWarning);

            // Color the connection dots
            const leftDot = document.querySelector(`.schema-connection-dot[data-table="${join.leftTable}"][data-column="${join.leftCol}"]`);
            const rightDot = document.querySelector(`.schema-connection-dot[data-table="${join.rightTable}"][data-column="${join.rightCol}"]`);

            if (leftDot) {
                leftDot.style.borderColor = color;
                leftDot.style.backgroundColor = color;
            }
            if (rightDot) {
                rightDot.style.borderColor = color;
                rightDot.style.backgroundColor = color;
            }
        }
    });
}

// Draw a connection line with optional arrow indicators for clipped columns
function drawConnectionLine(svg, x1, y1, x2, y2, index, areaRect, leftClipped, rightClipped, leftClipDir, rightClipDir, hasWarning = false) {
    const color = hasWarning ? '#f59e0b' : JOIN_COLORS[index % JOIN_COLORS.length]; // Orange for warning
    const cardsArea = document.getElementById('schemaCardsArea');

    // Create a curved path for better visibility
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = createCurvedPath(x1, y1, x2, y2);
    path.setAttribute('d', d);
    path.setAttribute('class', hasWarning ? 'join-line join-line-warning' : 'join-line');
    path.setAttribute('stroke', color);
    path.setAttribute('fill', 'none');
    if (hasWarning) {
        path.setAttribute('stroke-dasharray', '8,4'); // Dashed line for warning
        path.setAttribute('stroke-width', '3');
    }
    path.style.pointerEvents = 'stroke';
    path.onclick = (e) => {
        e.stopPropagation();
        showJoinPopover(index, e.clientX - areaRect.left, e.clientY - areaRect.top);
    };

    svg.appendChild(path);

    // Add warning icon at midpoint if there's a warning
    if (hasWarning) {
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        drawWarningIcon(svg, midX, midY, index, areaRect);
    }

    // Add circles or arrows at connection points
    if (leftClipped && leftClipDir) {
        drawClipArrow(svg, x1, y1, leftClipDir, color);
    } else {
        const circle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle1.setAttribute('cx', x1);
        circle1.setAttribute('cy', y1);
        circle1.setAttribute('r', 4);
        circle1.setAttribute('fill', color);
        svg.appendChild(circle1);
    }

    if (rightClipped && rightClipDir) {
        drawClipArrow(svg, x2, y2, rightClipDir, color);
    } else {
        const circle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle2.setAttribute('cx', x2);
        circle2.setAttribute('cy', y2);
        circle2.setAttribute('r', 4);
        circle2.setAttribute('fill', color);
        svg.appendChild(circle2);
    }
}

// Draw a warning icon (exclamation triangle) at the specified position
function drawWarningIcon(svg, x, y, index, areaRect) {
    const cardsArea = document.getElementById('schemaCardsArea');

    // Create a group for the warning icon
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('transform', `translate(${x - 10}, ${y - 10})`);
    g.style.cursor = 'pointer';
    g.onclick = (e) => {
        e.stopPropagation();
        showJoinPopover(index, e.clientX - areaRect.left, e.clientY - areaRect.top);
    };

    // Warning triangle background
    const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    triangle.setAttribute('d', 'M10 2 L18 18 L2 18 Z');
    triangle.setAttribute('fill', '#f59e0b');
    triangle.setAttribute('stroke', '#fff');
    triangle.setAttribute('stroke-width', '1');
    g.appendChild(triangle);

    // Exclamation mark
    const exclamation = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    exclamation.setAttribute('x', '10');
    exclamation.setAttribute('y', '15');
    exclamation.setAttribute('text-anchor', 'middle');
    exclamation.setAttribute('fill', '#fff');
    exclamation.setAttribute('font-size', '12');
    exclamation.setAttribute('font-weight', 'bold');
    exclamation.textContent = '!';
    g.appendChild(exclamation);

    svg.appendChild(g);
}

// Draw an arrow indicator for clipped columns
function drawClipArrow(svg, x, y, direction, color) {
    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const size = 6;

    let d;
    if (direction === 'up') {
        // Upward arrow ()
        d = `M ${x} ${y - size} L ${x - size} ${y + size} L ${x + size} ${y + size} Z`;
    } else {
        // Downward arrow ()
        d = `M ${x} ${y + size} L ${x - size} ${y - size} L ${x + size} ${y - size} Z`;
    }

    arrow.setAttribute('d', d);
    arrow.setAttribute('fill', color);
    arrow.setAttribute('class', 'clip-arrow');
    svg.appendChild(arrow);
}

function calculateBestConnectionPoints(rect1, rect2, areaRect, cardsArea) {
    // Calculate centers of each card
    const center1 = {
        x: rect1.left + rect1.width / 2,
        y: rect1.top + rect1.height / 2
    };
    const center2 = {
        x: rect2.left + rect2.width / 2,
        y: rect2.top + rect2.height / 2
    };

    // Determine which edges to connect based on relative positions
    let x1, y1, x2, y2;

    // Horizontal distance vs vertical distance
    const dx = center2.x - center1.x;
    const dy = center2.y - center1.y;

    if (Math.abs(dx) > Math.abs(dy)) {
        // Cards are more horizontal - connect left/right edges
        if (dx > 0) {
            // Card 2 is to the right of Card 1
            x1 = rect1.right;
            y1 = center1.y;
            x2 = rect2.left;
            y2 = center2.y;
        } else {
            // Card 2 is to the left of Card 1
            x1 = rect1.left;
            y1 = center1.y;
            x2 = rect2.right;
            y2 = center2.y;
        }
    } else {
        // Cards are more vertical - connect top/bottom edges
        if (dy > 0) {
            // Card 2 is below Card 1
            x1 = center1.x;
            y1 = rect1.bottom;
            x2 = center2.x;
            y2 = rect2.top;
        } else {
            // Card 2 is above Card 1
            x1 = center1.x;
            y1 = rect1.top;
            x2 = center2.x;
            y2 = rect2.bottom;
        }
    }

    // Convert to SVG coordinates (relative to cards area)
    return {
        x1: x1 - areaRect.left + cardsArea.scrollLeft,
        y1: y1 - areaRect.top + cardsArea.scrollTop,
        x2: x2 - areaRect.left + cardsArea.scrollLeft,
        y2: y2 - areaRect.top + cardsArea.scrollTop
    };
}

function createCurvedPath(x1, y1, x2, y2) {
    // Create a smooth bezier curve between the two points
    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2;

    // Calculate control points for a smooth curve
    const dx = x2 - x1;
    const dy = y2 - y1;

    // Curve amount based on distance
    const curveAmount = Math.min(Math.abs(dx), Math.abs(dy)) * 0.3;

    let cx1, cy1, cx2, cy2;

    if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal connection - curve vertically
        cx1 = x1 + dx * 0.3;
        cy1 = y1;
        cx2 = x2 - dx * 0.3;
        cy2 = y2;
    } else {
        // Vertical connection - curve horizontally
        cx1 = x1;
        cy1 = y1 + dy * 0.3;
        cx2 = x2;
        cy2 = y2 - dy * 0.3;
    }

    return `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
}

function debouncedRefreshPreview() {
    if (previewDebounceTimer) {
        clearTimeout(previewDebounceTimer);
    }
    previewDebounceTimer = setTimeout(refreshPreview, PREVIEW_DEBOUNCE_MS);
}

function refreshPreview() {
    if (!schemaBuilderState.sessionId) return;

    const joins = schemaBuilderState.joins.map(j => ({
        table: j.rightTable,
        left_col: j.leftCol,
        right_col: j.rightCol,
        type: j.type
    }));

    fetch(`/api/models/${modelId}/datasets/preview/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({
            session_id: schemaBuilderState.sessionId,
            primary_table: wizardData.primaryTable,
            joins: joins,
            selected_columns: schemaBuilderState.selectedColumns
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            schemaBuilderState.previewData = data;
            renderPreview(data);
        } else {
            renderPreviewError(data.message);
        }
    })
    .catch(error => {
        console.error('Error generating preview:', error);
        renderPreviewError('Failed to generate preview');
    });
}

function renderPreview(data) {
    // Update stats
    document.getElementById('previewRowCount').textContent = data.stats?.total_rows || 0;
    document.getElementById('previewColCount').textContent = data.column_order?.length || 0;

    // Show warnings if any
    const warningsEl = document.getElementById('previewWarnings');
    const warningTextEl = document.getElementById('previewWarningText');
    if (data.stats?.warnings?.length > 0) {
        warningsEl.style.display = 'flex';
        warningTextEl.textContent = data.stats.warnings[0];
    } else if (Object.keys(data.stats?.null_counts || {}).length > 0) {
        const nullCounts = data.stats.null_counts;
        const firstNull = Object.entries(nullCounts)[0];
        warningsEl.style.display = 'flex';
        warningTextEl.textContent = `${firstNull[1]} nulls in ${firstNull[0]}`;
    } else {
        warningsEl.style.display = 'none';
    }

    // Render table
    const table = document.getElementById('previewTable');
    const thead = document.getElementById('previewTableHead');
    const tbody = document.getElementById('previewTableBody');
    const empty = document.getElementById('previewEmpty');

    if (!data.preview_rows || data.preview_rows.length === 0) {
        table.style.display = 'none';
        empty.style.display = 'block';
        return;
    }

    table.style.display = 'table';
    empty.style.display = 'none';

    // Headers
    thead.innerHTML = '<tr>' + (data.column_order || []).map(col =>
        `<th>${col}</th>`
    ).join('') + '</tr>';

    // Rows
    tbody.innerHTML = data.preview_rows.map(row => {
        return '<tr>' + (data.column_order || []).map(col => {
            const val = row[col];
            if (val === null || val === undefined) {
                return `<td class="null-value">NULL</td>`;
            }
            return `<td title="${val}">${val}</td>`;
        }).join('') + '</tr>';
    }).join('');

    validateCurrentStep();
}

function renderPreviewError(message) {
    document.getElementById('previewRowCount').textContent = '-';
    document.getElementById('previewColCount').textContent = '-';
    document.getElementById('previewWarnings').style.display = 'none';
    document.getElementById('previewTable').style.display = 'none';
    document.getElementById('previewEmpty').style.display = 'block';
    document.getElementById('previewEmpty').innerHTML = `
        <i class="fas fa-exclamation-triangle"></i>
        ${message || 'Failed to generate preview'}
    `;
}

function collectSchemaBuilderData() {
    // Convert joins to the format expected by the backend
    wizardData.joinConfig = {};
    schemaBuilderState.joins.forEach(join => {
        wizardData.joinConfig[join.rightTable] = {
            join_key: join.leftCol,
            secondary_column: join.rightCol,
            join_type: join.type
        };
    });

    // Update secondaryTables to only include tables that have joins configured
    // This prevents the backend from trying to join tables without proper configuration
    const joinedTables = schemaBuilderState.joins.map(j => j.rightTable);
    wizardData.secondaryTables = wizardData.secondaryTables.filter(table =>
        joinedTables.includes(table)
    );

    // Determine which tables are in use (primary + joined secondary tables)
    const tablesInUse = [wizardData.primaryTable, ...wizardData.secondaryTables];

    // Transfer only selected columns from tables that are in use
    wizardData.selectedColumns = {};
    tablesInUse.forEach(table => {
        if (schemaBuilderState.selectedColumns[table]) {
            wizardData.selectedColumns[table] = [...schemaBuilderState.selectedColumns[table]];
        }
    });
}

function getTypeAbbrev(type) {
    const abbrevs = {
        'STRING': 'str',
        'INTEGER': 'int',
        'INT64': 'int',
        'FLOAT': 'flt',
        'FLOAT64': 'flt',
        'BOOLEAN': 'bool',
        'TIMESTAMP': 'ts',
        'DATE': 'date',
        'DATETIME': 'dt'
    };
    return abbrevs[type?.toUpperCase()] || type?.substring(0, 3)?.toLowerCase() || '';
}

// Close join popover when clicking outside
document.addEventListener('click', function(e) {
    const popover = document.getElementById('joinPopover');
    if (popover && !popover.contains(e.target) && !e.target.classList.contains('join-line')) {
        hideJoinPopover();
    }
});

// ============================================================================
// STEP 4: FILTERS
// ============================================================================

// State for product revenue analysis
let productAnalysisData = null;
let usedFilterColumns = new Set(); // Track columns used in filters to prevent reuse

// Committed Dates Filter State (tracks timestamp column after Refresh Dataset in Dates sub-chapter)
let committedDatesFilter = {
    timestampColumn: null
};

// Product Filters State Management
let productFiltersState = {
    pending: {
        topRevenue: {
            enabled: false,
            productColumn: null,
            revenueColumn: null,
            thresholdPercent: 80
        },
        aggregationFilters: [],  // [{type: 'transaction_count'|'total_revenue', productColumn, amountColumn?, filterType, value, min?, max?}]
        categoryFilters: [],  // [{column, mode, values, colInfo}]
        numericFilters: [],   // [{column, type, min, max, value, includeNulls, colInfo}]
        dateFilters: []       // [{column, filterType, relativeOption, startDate, endDate, includeNulls, colInfo}]
    },
    committed: {
        topRevenue: {
            enabled: false,
            productColumn: null,
            revenueColumn: null,
            thresholdPercent: 80
        },
        aggregationFilters: [],
        categoryFilters: [],
        numericFilters: [],
        dateFilters: []
    },
    columnAnalysis: {},  // Cached column analysis data
    selectedFilterColumn: null  // Currently selected column in Filter Columns modal
};

// Customer Filters State Management
let customerFiltersState = {
    pending: {
        topRevenue: {
            enabled: false,
            customerColumn: null,    // Grouping column (NOT excluded from other filters)
            revenueColumn: null,     // Aggregation column (excluded after use)
            thresholdPercent: 80
        },
        aggregationFilters: [],  // [{type: 'transaction_count'|'spending', customerColumn, amountColumn?, filterType, value, min?, max?}]
        categoryFilters: [],     // [{column, mode, values, colInfo}]
        numericFilters: [],      // [{column, type, min, max, value, includeNulls, colInfo}]
        dateFilters: []          // [{column, filterType, relativeOption, startDate, endDate, includeNulls, colInfo}]
    },
    committed: {
        topRevenue: {
            enabled: false,
            customerColumn: null,
            revenueColumn: null,
            thresholdPercent: 80
        },
        aggregationFilters: [],
        categoryFilters: [],
        numericFilters: [],
        dateFilters: []
    },
    columnAnalysis: {},  // Cached column analysis data (shared with products or separate)
    selectedFilterColumn: null  // Currently selected column in Filter Columns modal
};

// Track if customer filters have been applied (committed via Refresh Dataset)
let customerFiltersApplied = false;

// Customer revenue analysis data (Pareto chart data)
let customerAnalysisData = null;

// ============================================================================
// RESTORE FILTERS FROM SAVED DATA (Edit Mode)
// ============================================================================
function restoreFiltersFromSavedData(filters) {
    /**
     * Restore filter states from saved dataset configuration.
     * Called when entering Step 4 in edit mode.
     *
     * @param {Object} filters - The saved filters from wizardData.filters
     */
    console.log('Restoring filters from saved data:', filters);

    // ===========================================
    // 1. RESTORE DATES FILTER
    // ===========================================
    if (filters.history) {
        const history = filters.history;

        // Set UI elements
        const timestampSelect = document.getElementById('timestampColumn');
        if (timestampSelect && history.timestamp_column) {
            // Try to find the option - may need to match with or without table prefix
            let found = false;
            for (let i = 0; i < timestampSelect.options.length; i++) {
                const optVal = timestampSelect.options[i].value;
                if (optVal === history.timestamp_column ||
                    optVal.endsWith('.' + history.timestamp_column.split('.').pop())) {
                    timestampSelect.selectedIndex = i;
                    found = true;
                    console.log('Found timestamp column option:', optVal);
                    break;
                }
            }
            if (!found) {
                console.warn('Could not find timestamp column in dropdown:', history.timestamp_column);
                console.log('Available options:', Array.from(timestampSelect.options).map(o => o.value));
            }
        }

        const rollingDaysInput = document.getElementById('rollingDays');
        if (rollingDaysInput && history.rolling_days) {
            rollingDaysInput.value = history.rolling_days;
        }

        // Set committed state - use the actual dropdown value (which may differ from saved)
        const actualTimestampValue = timestampSelect?.value || history.timestamp_column;
        datesFilterState.committed = {
            timestampColumn: actualTimestampValue || null,
            mode: history.start_date ? 'startDate' : 'rolling',
            rollingDays: history.rolling_days || 30,
            startDate: history.start_date || null
        };

        // Also set pending to match committed (no unapplied changes)
        datesFilterState.pending = { ...datesFilterState.committed };

        // Update legacy state
        committedDatesFilter.timestampColumn = actualTimestampValue;

        // Mark as applied
        dateFiltersApplied = true;

        // Update UI state
        if (history.start_date) {
            historyFilterMode = 'startDate';
            const startDateInput = document.getElementById('startDateInput');
            if (startDateInput) startDateInput.value = history.start_date;
        } else {
            historyFilterMode = 'rolling';
        }

        // Update status indicators and summary
        updateDatesFilterStatus();
        updateDatesRefreshButtonState();
        updateDatesFilterSummary();
    }

    // ===========================================
    // 2. RESTORE PRODUCTS FILTER
    // ===========================================
    if (filters.product_filter || filters.products) {
        const productFilter = filters.product_filter || {};
        const legacyProducts = filters.products || {};

        // Handle top_revenue filter
        if (productFilter.top_revenue?.enabled || legacyProducts.product_column) {
            const topRevenue = productFilter.top_revenue || {};

            productFiltersState.committed.topRevenue = {
                enabled: true,
                productColumn: topRevenue.product_column || legacyProducts.product_column,
                revenueColumn: topRevenue.revenue_column || legacyProducts.revenue_column,
                thresholdPercent: topRevenue.threshold_percent || legacyProducts.threshold_percent || 80
            };

            // Set UI elements
            const productSelect = document.getElementById('productIdColumn');
            if (productSelect) {
                productSelect.value = productFiltersState.committed.topRevenue.productColumn || '';
            }

            const revenueSelect = document.getElementById('revenueColumn');
            if (revenueSelect) {
                revenueSelect.value = productFiltersState.committed.topRevenue.revenueColumn || '';
            }

            const thresholdInput = document.getElementById('revenueThreshold');
            if (thresholdInput) {
                thresholdInput.value = productFiltersState.committed.topRevenue.thresholdPercent;
            }
        }

        // Handle aggregation filters
        if (productFilter.aggregation_filters?.length > 0) {
            productFiltersState.committed.aggregationFilters = productFilter.aggregation_filters.map(f => ({
                type: f.type,
                productColumn: f.product_column,
                amountColumn: f.amount_column,
                filterType: f.filter_type,
                value: f.value,
                min: f.min,
                max: f.max
            }));
        }

        // Handle category filters
        if (productFilter.category_filters?.length > 0) {
            productFiltersState.committed.categoryFilters = productFilter.category_filters.map(f => ({
                column: f.column,
                mode: f.mode,
                values: f.values
            }));
        }

        // Handle numeric filters
        if (productFilter.numeric_filters?.length > 0) {
            productFiltersState.committed.numericFilters = productFilter.numeric_filters.map(f => ({
                column: f.column,
                type: f.type,
                min: f.min,
                max: f.max,
                value: f.value,
                includeNulls: f.include_nulls
            }));
        }

        // Copy committed to pending (no unapplied changes)
        productFiltersState.pending = JSON.parse(JSON.stringify(productFiltersState.committed));

        // Mark as applied if there are any product filters
        const hasProductFilters = productFiltersState.committed.topRevenue.enabled ||
            productFiltersState.committed.aggregationFilters.length > 0 ||
            productFiltersState.committed.categoryFilters.length > 0 ||
            productFiltersState.committed.numericFilters.length > 0;

        if (hasProductFilters) {
            productFiltersApplied = true;
            updateProductsFilterStatus();
            updateProductsRefreshButtonState();
            updateProductsFilterSummary();
        }
    }

    // ===========================================
    // 3. RESTORE CUSTOMERS FILTER
    // ===========================================
    if (filters.customer_filter) {
        const customerFilter = filters.customer_filter;

        // Handle top_revenue filter
        if (customerFilter.top_revenue) {
            customerFiltersState.committed.topRevenue = {
                enabled: true,
                customerColumn: customerFilter.top_revenue.customer_column,
                revenueColumn: customerFilter.top_revenue.revenue_column,
                thresholdPercent: customerFilter.top_revenue.percent || 80
            };
        }

        // Handle aggregation filters
        if (customerFilter.aggregation_filters?.length > 0) {
            customerFiltersState.committed.aggregationFilters = customerFilter.aggregation_filters.map(f => ({
                type: f.type,
                customerColumn: f.customer_column,
                amountColumn: f.amount_column,
                filterType: f.filter_type,
                value: f.value,
                min: f.min,
                max: f.max
            }));
        }

        // Handle category filters
        if (customerFilter.category_filters?.length > 0) {
            customerFiltersState.committed.categoryFilters = customerFilter.category_filters.map(f => ({
                column: f.column,
                mode: f.mode,
                values: f.values
            }));
        }

        // Handle numeric filters
        if (customerFilter.numeric_filters?.length > 0) {
            customerFiltersState.committed.numericFilters = customerFilter.numeric_filters.map(f => ({
                column: f.column,
                type: f.type || f.filter_type,
                min: f.min,
                max: f.max,
                value: f.value,
                includeNulls: f.include_nulls
            }));
        }

        // Copy committed to pending (no unapplied changes)
        customerFiltersState.pending = JSON.parse(JSON.stringify(customerFiltersState.committed));

        // Mark as applied if there are any customer filters
        const hasCustomerFilters = customerFiltersState.committed.topRevenue.enabled ||
            customerFiltersState.committed.aggregationFilters.length > 0 ||
            customerFiltersState.committed.categoryFilters.length > 0 ||
            customerFiltersState.committed.numericFilters.length > 0;

        if (hasCustomerFilters) {
            customerFiltersApplied = true;
            updateCustomersFilterStatus();
            updateCustomersRefreshButtonState();
            updateCustomersFilterSummary();
        }
    }

    // Update all filter column dropdowns to reflect exclusions
    populateProductFilterDropdowns();

    // Fetch dataset stats with filters applied to update the Dataset Summary panel
    // This needs to happen after all filter states are restored
    fetchDatasetStats(true);

    console.log('Filter state restored:', {
        datesFilterState,
        productFiltersState,
        customerFiltersState,
        dateFiltersApplied,
        productFiltersApplied,
        customerFiltersApplied
    });
}

// --- Sub-chapter Toggle ---
function toggleSubchapter(name) {
    const content = document.getElementById(`${name}Content`);
    const chevron = document.getElementById(`${name}Chevron`);

    if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        chevron.classList.remove('fa-chevron-right');
        chevron.classList.add('fa-chevron-down');

        // Update button states when opening sub-chapter
        if (name === 'products') {
            updateProductsRefreshButtonState();
        } else if (name === 'customers') {
            updateCustomersRefreshButtonState();
        }
    } else {
        content.classList.add('hidden');
        chevron.classList.remove('fa-chevron-down');
        chevron.classList.add('fa-chevron-right');
    }
}

// --- Product Filter Section Toggles ---
function toggleProductFilterSection(sectionName) {
    const content = document.getElementById(`${sectionName}Content`);
    const header = content.previousElementSibling;
    const chevron = header.querySelector('.product-filter-chevron');

    if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        header.classList.remove('collapsed');
    } else {
        content.classList.add('hidden');
        header.classList.add('collapsed');
    }
}

function toggleTopProductsFilter() {
    // Legacy function - kept for compatibility
    // Top products filter is now auto-enabled when modal opens
    const enabled = document.getElementById('enableTopProducts').checked;
    productFiltersState.pending.topRevenue.enabled = enabled;
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

// ============================================================================
// TOP PRODUCTS MODAL
// ============================================================================

function openTopProductsModal() {
    const modal = document.getElementById('topProductsModal');
    modal.classList.remove('hidden');

    // Auto-enable top products filter when modal opens
    document.getElementById('enableTopProducts').checked = true;
    productFiltersState.pending.topRevenue.enabled = true;

    // Restore values from pending state if they exist
    const pending = productFiltersState.pending.topRevenue;
    if (pending.productColumn) {
        document.getElementById('productIdColumn').value = pending.productColumn;
    }
    if (pending.revenueColumn) {
        document.getElementById('revenueColumn').value = pending.revenueColumn;
    }
    document.getElementById('revenueThreshold').value = pending.thresholdPercent || 80;

    // Update analyze button state
    updateAnalyzeButtonState();

    // Show analysis results if we have data
    if (productAnalysisData) {
        document.getElementById('productAnalysisResults').classList.remove('hidden');
        drawRevenueDistributionChart(productAnalysisData.distribution, pending.thresholdPercent || 80);
        updateProductSelectionForThreshold(pending.thresholdPercent || 80);
    }
}

function closeTopProductsModal() {
    const modal = document.getElementById('topProductsModal');
    modal.classList.add('hidden');
}

function applyTopProductsFilter() {
    // Update state with current modal values
    const productCol = document.getElementById('productIdColumn')?.value;
    const revenueCol = document.getElementById('revenueColumn')?.value;
    const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

    // Only enable if we have valid column selections
    const isEnabled = productCol && revenueCol;

    productFiltersState.pending.topRevenue = {
        enabled: isEnabled,
        productColumn: productCol || null,
        revenueColumn: revenueCol || null,
        thresholdPercent: threshold
    };

    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
    closeTopProductsModal();
}

// ============================================================================
// TOP CUSTOMERS MODAL
// ============================================================================

async function openTopCustomersModal() {
    const modal = document.getElementById('topCustomersModal');
    modal.classList.remove('hidden');

    // Auto-enable top customers filter when modal opens
    document.getElementById('enableTopCustomers').checked = true;
    customerFiltersState.pending.topRevenue.enabled = true;

    // Pre-fetch column analysis if not cached (needed to identify numeric columns)
    if (Object.keys(customerFiltersState.columnAnalysis).length === 0 &&
        Object.keys(productFiltersState.columnAnalysis).length === 0) {
        await fetchColumnAnalysis();
    }

    // Copy column analysis from products if not in customers
    if (Object.keys(customerFiltersState.columnAnalysis).length === 0) {
        customerFiltersState.columnAnalysis = { ...productFiltersState.columnAnalysis };
    }

    // Populate column dropdowns
    populateTopCustomersDropdowns();

    // Restore values from pending state if they exist
    const pending = customerFiltersState.pending.topRevenue;
    if (pending.customerColumn) {
        document.getElementById('customerIdColumn').value = pending.customerColumn;
    }
    if (pending.revenueColumn) {
        document.getElementById('customerRevenueColumn').value = pending.revenueColumn;
    }
    document.getElementById('customerRevenueThreshold').value = pending.thresholdPercent || 80;

    // Update analyze button state
    updateCustomerAnalyzeButtonState();

    // Show analysis results if we have data
    if (customerAnalysisData) {
        document.getElementById('customerAnalysisResults').classList.remove('hidden');
        updateCustomerRevenueChart(pending.thresholdPercent || 80);
    }
}

function closeTopCustomersModal() {
    const modal = document.getElementById('topCustomersModal');
    modal.classList.add('hidden');
}

function populateTopCustomersDropdowns() {
    const customerIdSelect = document.getElementById('customerIdColumn');
    const revenueSelect = document.getElementById('customerRevenueColumn');

    // Get selected columns from schema builder
    const columns = [];
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            columns.push({ table: shortTable, column: col, fullName: `${shortTable}.${col}` });
        });
    });

    // Get column types from analysis if available
    const colAnalysis = customerFiltersState.columnAnalysis || productFiltersState.columnAnalysis;

    // Get timestamp column to exclude DATE columns used there
    const timestampCol = document.getElementById('timestampColumn')?.value;

    // Filter for numeric columns for revenue
    // INTEGER/FLOAT aggregation columns are REUSABLE - don't exclude based on aggregation usage
    const numericColumns = columns.filter(col => {
        const info = colAnalysis[col.fullName];
        const isNumeric = info?.type && ['INTEGER', 'FLOAT', 'INT64', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC'].includes(info.type.toUpperCase());
        // Only exclude DATE columns (they can only be used once)
        const isDateExcluded = isColumnCommittedInAnyFilter(col.fullName, 'date');
        // Also exclude the timestamp column
        const isTimestamp = timestampCol && col.fullName === timestampCol;
        return isNumeric && !isDateExcluded && !isTimestamp;
    });

    // Populate Customer ID dropdown (grouping column - only exclude date columns)
    // STRING grouping columns are reusable
    customerIdSelect.innerHTML = '<option value="">Select column...</option>';
    columns.forEach(col => {
        // Exclude timestamp column and date-filtered columns
        if (timestampCol && col.fullName === timestampCol) return;
        if (isColumnCommittedInAnyFilter(col.fullName, 'date')) return;

        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = col.fullName;
        customerIdSelect.appendChild(option);
    });

    // Populate Revenue dropdown (aggregation column - REUSABLE)
    // INTEGER/FLOAT aggregation columns can be used in multiple places
    revenueSelect.innerHTML = '<option value="">Select column...</option>';
    numericColumns.forEach(col => {
        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = col.fullName;
        revenueSelect.appendChild(option);
    });
}

function onCustomerColumnChange() {
    updateCustomerAnalyzeButtonState();
}

function onCustomerRevenueColumnChange() {
    updateCustomerAnalyzeButtonState();
}

function updateCustomerAnalyzeButtonState() {
    const customerCol = document.getElementById('customerIdColumn')?.value;
    const revenueCol = document.getElementById('customerRevenueColumn')?.value;
    const analyzeBtn = document.getElementById('analyzeCustomersBtn');

    if (customerCol && revenueCol) {
        analyzeBtn.disabled = false;
        analyzeBtn.classList.remove('filter-button-disabled');
    } else {
        analyzeBtn.disabled = true;
        analyzeBtn.classList.add('filter-button-disabled');
    }
}

async function analyzeCustomerRevenue() {
    const customerCol = document.getElementById('customerIdColumn').value;
    const revenueCol = document.getElementById('customerRevenueColumn').value;

    if (!customerCol || !revenueCol) {
        showNotification('Please select both customer ID and revenue columns', 'error');
        return;
    }

    const analyzeBtn = document.getElementById('analyzeCustomersBtn');
    const originalHtml = analyzeBtn.innerHTML;
    analyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing...';
    analyzeBtn.disabled = true;

    try {
        // Call the customer revenue analysis API
        const response = await fetch(`/api/models/{{ model.id }}/datasets/analyze-customer-revenue/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                session_id: schemaBuilderState.sessionId,
                customer_column: customerCol,
                revenue_column: revenueCol
            })
        });

        if (!response.ok) {
            throw new Error(`Analysis failed: ${response.statusText}`);
        }

        const data = await response.json();

        // Check for API-level error
        if (data.status === 'error') {
            throw new Error(data.message || 'Analysis failed');
        }

        customerAnalysisData = data;

        // Store column selections in pending state
        customerFiltersState.pending.topRevenue.customerColumn = customerCol;
        customerFiltersState.pending.topRevenue.revenueColumn = revenueCol;

        // Show analysis results
        document.getElementById('customerAnalysisResults').classList.remove('hidden');
        document.getElementById('customerAnalysisError').classList.add('hidden');

        // Render the Pareto chart
        renderCustomerRevenueChart(data);

        // Update stats
        const threshold = parseInt(document.getElementById('customerRevenueThreshold').value) || 80;
        updateCustomerRevenueChart(threshold);

        console.log('Customer analysis data:', data);  // Debug log

    } catch (error) {
        console.error('Customer revenue analysis failed:', error);
        document.getElementById('customerAnalysisError').classList.remove('hidden');
        document.getElementById('customerAnalysisErrorText').textContent = error.message;
        document.getElementById('customerAnalysisResults').classList.add('hidden');
    } finally {
        analyzeBtn.innerHTML = originalHtml;
        analyzeBtn.disabled = false;
    }
}

function renderCustomerRevenueChart(data) {
    // Similar to product revenue chart - render Pareto chart using D3
    const container = document.getElementById('customerRevenueChartContainer');
    const svg = d3.select('#customerRevenueDistributionChart');

    // Clear previous chart
    svg.selectAll('*').remove();

    const margin = { top: 20, right: 30, bottom: 50, left: 50 };
    const containerWidth = container.clientWidth || container.offsetWidth || 600;
    const width = Math.max(containerWidth - margin.left - margin.right, 200);
    const height = 180 - margin.top - margin.bottom;

    // Set SVG dimensions
    svg.attr('width', width + margin.left + margin.right)
       .attr('height', height + margin.top + margin.bottom);

    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Prepare data
    const distributionData = data.distribution || [];
    const totalCustomers = data.total_customers || 0;

    if (distributionData.length === 0) return;

    // Add (0,0) point for proper chart connection
    const chartData = [{ customer_percent: 0, cumulative_revenue_percent: 0, customer_count: 0 }, ...distributionData];

    // X scale (real customer count, not percentage)
    const x = d3.scaleLinear()
        .domain([0, totalCustomers])
        .range([0, width]);

    // Y scale (cumulative revenue percentage)
    const y = d3.scaleLinear()
        .domain([0, 100])
        .range([height, 0]);

    // Helper to convert customer_percent to customer_count
    const getCustomerCount = (d) => Math.round(totalCustomers * d.customer_percent / 100);

    // Line generator - use customer count for X
    const line = d3.line()
        .x(d => x(getCustomerCount(d)))
        .y(d => y(d.cumulative_revenue_percent))
        .curve(d3.curveMonotoneX);

    // Area under the line
    const area = d3.area()
        .x(d => x(getCustomerCount(d)))
        .y0(height)
        .y1(d => y(d.cumulative_revenue_percent))
        .curve(d3.curveMonotoneX);

    // Draw area
    g.append('path')
        .datum(chartData)
        .attr('fill', '#dbeafe')
        .attr('d', area);

    // Draw line
    g.append('path')
        .datum(chartData)
        .attr('fill', 'none')
        .attr('stroke', '#2563eb')
        .attr('stroke-width', 2)
        .attr('d', line);

    // Format helper for large numbers
    const formatCustomerCount = (val) => {
        if (val >= 1000000) return `${(val / 1000000).toFixed(1)}M`;
        if (val >= 1000) return `${(val / 1000).toFixed(0)}K`;
        return val.toString();
    };

    // X axis - show real customer numbers
    g.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(5).tickFormat(d => formatCustomerCount(d)))
        .selectAll('text')
        .style('font-size', '10px');

    // Y axis
    g.append('g')
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d + '%'))
        .selectAll('text')
        .style('font-size', '10px');

    // X axis label
    g.append('text')
        .attr('x', width / 2)
        .attr('y', height + 40)
        .attr('text-anchor', 'middle')
        .style('font-size', '11px')
        .style('fill', '#6b7280')
        .text('Customers (ranked by revenue)');

    // Y axis label
    g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', -45)
        .attr('x', -height / 2)
        .attr('text-anchor', 'middle')
        .style('font-size', '11px')
        .style('fill', '#6b7280')
        .text('Cumulative Revenue %');

    // Store reference for threshold line updates
    svg.node().chartData = { x, y, height, g, distributionData: chartData, totalCustomers, getCustomerCount };
}

function updateCustomerRevenueChart(threshold) {
    if (!customerAnalysisData) return;

    const svg = d3.select('#customerRevenueDistributionChart');
    const chartData = svg.node()?.chartData;
    if (!chartData) return;

    const { x, y, height, g, distributionData, totalCustomers, getCustomerCount } = chartData;

    // Remove previous threshold elements
    g.selectAll('.threshold-line').remove();
    g.selectAll('.threshold-area').remove();

    // Find the customer percentage for the given revenue threshold
    let customerPercent = 100;
    for (const point of distributionData) {
        if (point.cumulative_revenue_percent >= threshold) {
            customerPercent = point.customer_percent;
            break;
        }
    }

    // Calculate customer count for X position
    const customerCount = Math.round(totalCustomers * customerPercent / 100);

    // Draw threshold line (horizontal at threshold revenue %)
    g.append('line')
        .attr('class', 'threshold-line')
        .attr('x1', 0)
        .attr('x2', x(customerCount))
        .attr('y1', y(threshold))
        .attr('y2', y(threshold))
        .attr('stroke', '#16a34a')
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '4,4');

    // Draw threshold line (vertical at customer count)
    g.append('line')
        .attr('class', 'threshold-line')
        .attr('x1', x(customerCount))
        .attr('x2', x(customerCount))
        .attr('y1', y(threshold))
        .attr('y2', height)
        .attr('stroke', '#16a34a')
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '4,4');

    // Update stats
    const totalCustomersCount = customerAnalysisData.total_customers || 0;
    const selectedCustomers = Math.round(totalCustomersCount * customerPercent / 100);
    const totalRevenue = customerAnalysisData.total_revenue || 0;
    const selectedRevenue = totalRevenue * threshold / 100;

    document.getElementById('totalCustomersCount').textContent = totalCustomersCount.toLocaleString();
    document.getElementById('selectedCustomersCount').textContent = selectedCustomers.toLocaleString();
    document.getElementById('selectedCustomersPercent').textContent = `(${customerPercent.toFixed(1)}%)`;
    document.getElementById('customerRevenueCoverage').textContent = `${threshold}%`;
    document.getElementById('customerRevenueCoverageAmount').textContent = `($${selectedRevenue.toLocaleString(undefined, { maximumFractionDigits: 0 })})`;

    // Update pending state
    customerFiltersState.pending.topRevenue.thresholdPercent = threshold;
}

function onCustomerThresholdChange() {
    const threshold = parseInt(document.getElementById('customerRevenueThreshold').value) || 80;
    updateCustomerRevenueChart(threshold);
}

function applyTopCustomersFilter() {
    // Update state with current modal values
    const customerCol = document.getElementById('customerIdColumn')?.value;
    const revenueCol = document.getElementById('customerRevenueColumn')?.value;
    const threshold = parseInt(document.getElementById('customerRevenueThreshold')?.value) || 80;

    // Only enable if we have valid column selections
    const isEnabled = customerCol && revenueCol;

    customerFiltersState.pending.topRevenue = {
        enabled: isEnabled,
        customerColumn: customerCol || null,
        revenueColumn: revenueCol || null,
        thresholdPercent: threshold
    };

    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
    closeTopCustomersModal();
}

// ============================================================================
// CUSTOMER METRICS MODAL
// ============================================================================

// Snapshot of aggregation filters when modal opens (for Cancel functionality)
let customerMetricsModalSnapshot = null;

async function openCustomerMetricsModal() {
    const modal = document.getElementById('customerMetricsModal');
    modal.classList.remove('hidden');

    // Store snapshot of current aggregation filters for Cancel functionality
    customerMetricsModalSnapshot = JSON.parse(JSON.stringify(customerFiltersState.pending.aggregationFilters));

    // Pre-fetch column analysis if not cached (needed to identify numeric columns)
    if (Object.keys(customerFiltersState.columnAnalysis).length === 0 &&
        Object.keys(productFiltersState.columnAnalysis).length === 0) {
        await fetchColumnAnalysis();
    }

    // Copy column analysis from products if not in customers
    if (Object.keys(customerFiltersState.columnAnalysis).length === 0) {
        customerFiltersState.columnAnalysis = { ...productFiltersState.columnAnalysis };
    }

    // Populate column dropdowns
    populateCustomerMetricsDropdowns();

    // Render existing aggregation filters
    renderExistingAggregationFilters();

    // Reset form inputs
    resetCustomerMetricsInputs();
}

function closeCustomerMetricsModal() {
    const modal = document.getElementById('customerMetricsModal');
    modal.classList.add('hidden');
    customerMetricsModalSnapshot = null;
}

function applyCustomerMetricsFilters() {
    // Changes are already in pending state, just close the modal
    closeCustomerMetricsModal();

    // Update the summary and button state
    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
}

function cancelCustomerMetricsModal() {
    // Restore the snapshot (revert any changes made during this modal session)
    if (customerMetricsModalSnapshot !== null) {
        customerFiltersState.pending.aggregationFilters = customerMetricsModalSnapshot;
    }

    closeCustomerMetricsModal();

    // Update the summary and button state to reflect reverted state
    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
}

function populateCustomerMetricsDropdowns() {
    // Get columns from schema builder
    const columns = [];
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            columns.push({ table: shortTable, column: col, fullName: `${shortTable}.${col}` });
        });
    });

    // Get column types from analysis if available
    const colAnalysis = customerFiltersState.columnAnalysis || productFiltersState.columnAnalysis;

    // Get timestamp column to exclude
    const timestampCol = document.getElementById('timestampColumn')?.value;

    // Numeric columns for amount (aggregation columns are REUSABLE)
    // Only exclude DATE columns
    const numericColumns = columns.filter(col => {
        const info = colAnalysis[col.fullName];
        const isNumeric = info?.type && ['INTEGER', 'FLOAT', 'INT64', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC'].includes(info.type.toUpperCase());
        // Only exclude DATE columns (they can only be used once)
        const isDateExcluded = isColumnCommittedInAnyFilter(col.fullName, 'date');
        const isTimestamp = timestampCol && col.fullName === timestampCol;
        return isNumeric && !isDateExcluded && !isTimestamp;
    });

    // Transaction Count - Customer ID (grouping column - only exclude date columns)
    const txnCountCustomerSelect = document.getElementById('txnCountCustomerColumn');
    txnCountCustomerSelect.innerHTML = '<option value="">Select column...</option>';
    columns.forEach(col => {
        // Exclude timestamp column and date-filtered columns
        if (timestampCol && col.fullName === timestampCol) return;
        if (isColumnCommittedInAnyFilter(col.fullName, 'date')) return;

        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = col.fullName;
        txnCountCustomerSelect.appendChild(option);
    });

    // Spending - Customer ID (grouping column - only exclude date columns)
    const spendingCustomerSelect = document.getElementById('spendingCustomerColumn');
    spendingCustomerSelect.innerHTML = '<option value="">Select column...</option>';
    columns.forEach(col => {
        // Exclude timestamp column and date-filtered columns
        if (timestampCol && col.fullName === timestampCol) return;
        if (isColumnCommittedInAnyFilter(col.fullName, 'date')) return;

        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = col.fullName;
        spendingCustomerSelect.appendChild(option);
    });

    // Spending - Amount Column (aggregation column - REUSABLE across sub-chapters)
    // But within Customer Metrics, we exclude columns already used in PENDING aggregations
    // to avoid duplicate filters within the same modal
    const spendingAmountSelect = document.getElementById('spendingAmountColumn');
    spendingAmountSelect.innerHTML = '<option value="">Select column...</option>';
    numericColumns.forEach(col => {
        // Check if this column is already used in pending customer aggregations (within same modal)
        const isUsedInPending = customerFiltersState.pending.aggregationFilters.some(f => f.amountColumn === col.fullName);
        // Check if used as revenue column in top customers (within same modal)
        const isUsedAsRevenue = customerFiltersState.pending.topRevenue.revenueColumn === col.fullName;
        // Note: We do NOT exclude based on committed state - aggregation columns are reusable!
        if (!isUsedInPending && !isUsedAsRevenue) {
            const option = document.createElement('option');
            option.value = col.fullName;
            option.textContent = col.fullName;
            spendingAmountSelect.appendChild(option);
        }
    });
}

function resetCustomerMetricsInputs() {
    // Reset transaction count inputs
    document.getElementById('txnCountFilterType').value = 'greater_than';
    document.getElementById('txnCountValue').value = '';
    document.getElementById('txnCountMin').value = '';
    document.getElementById('txnCountMax').value = '';
    updateTxnCountInputs();

    // Reset spending inputs
    document.getElementById('spendingFilterType').value = 'greater_than';
    document.getElementById('spendingValue').value = '';
    document.getElementById('spendingMin').value = '';
    document.getElementById('spendingMax').value = '';
    updateSpendingInputs();
}

function updateTxnCountInputs() {
    const filterType = document.getElementById('txnCountFilterType').value;
    const valueContainer = document.getElementById('txnCountValueContainer');
    const minContainer = document.getElementById('txnCountMinContainer');
    const maxContainer = document.getElementById('txnCountMaxContainer');

    if (filterType === 'range') {
        valueContainer.classList.add('hidden');
        minContainer.classList.remove('hidden');
        maxContainer.classList.remove('hidden');
    } else {
        valueContainer.classList.remove('hidden');
        minContainer.classList.add('hidden');
        maxContainer.classList.add('hidden');
    }
}

function updateSpendingInputs() {
    const filterType = document.getElementById('spendingFilterType').value;
    const valueContainer = document.getElementById('spendingValueContainer');
    const minContainer = document.getElementById('spendingMinContainer');
    const maxContainer = document.getElementById('spendingMaxContainer');

    if (filterType === 'range') {
        valueContainer.classList.add('hidden');
        minContainer.classList.remove('hidden');
        maxContainer.classList.remove('hidden');
    } else {
        valueContainer.classList.remove('hidden');
        minContainer.classList.add('hidden');
        maxContainer.classList.add('hidden');
    }
}

function addTransactionCountFilter() {
    const customerColumn = document.getElementById('txnCountCustomerColumn').value;
    const filterType = document.getElementById('txnCountFilterType').value;

    if (!customerColumn) {
        showNotification('Please select a customer ID column', 'error');
        return;
    }

    let filterData = {
        type: 'transaction_count',
        customerColumn: customerColumn,
        filterType: filterType
    };

    if (filterType === 'range') {
        const min = parseFloat(document.getElementById('txnCountMin').value);
        const max = parseFloat(document.getElementById('txnCountMax').value);
        if (isNaN(min) || isNaN(max)) {
            showNotification('Please enter valid min and max values', 'error');
            return;
        }
        filterData.min = min;
        filterData.max = max;
    } else {
        const value = parseFloat(document.getElementById('txnCountValue').value);
        if (isNaN(value)) {
            showNotification('Please enter a valid value', 'error');
            return;
        }
        filterData.value = value;
    }

    // Add to pending state
    customerFiltersState.pending.aggregationFilters.push(filterData);

    // Update UI
    renderExistingAggregationFilters();
    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();

    // Reset inputs
    document.getElementById('txnCountCustomerColumn').value = '';
    document.getElementById('txnCountValue').value = '';
    document.getElementById('txnCountMin').value = '';
    document.getElementById('txnCountMax').value = '';

    showNotification('Transaction count filter added', 'success');
}

function addSpendingFilter() {
    const customerColumn = document.getElementById('spendingCustomerColumn').value;
    const amountColumn = document.getElementById('spendingAmountColumn').value;
    const filterType = document.getElementById('spendingFilterType').value;

    if (!customerColumn) {
        showNotification('Please select a customer ID column', 'error');
        return;
    }
    if (!amountColumn) {
        showNotification('Please select an amount column', 'error');
        return;
    }

    let filterData = {
        type: 'spending',
        customerColumn: customerColumn,
        amountColumn: amountColumn,
        filterType: filterType
    };

    if (filterType === 'range') {
        const min = parseFloat(document.getElementById('spendingMin').value);
        const max = parseFloat(document.getElementById('spendingMax').value);
        if (isNaN(min) || isNaN(max)) {
            showNotification('Please enter valid min and max values', 'error');
            return;
        }
        filterData.min = min;
        filterData.max = max;
    } else {
        const value = parseFloat(document.getElementById('spendingValue').value);
        if (isNaN(value)) {
            showNotification('Please enter a valid value', 'error');
            return;
        }
        filterData.value = value;
    }

    // Add to pending state
    customerFiltersState.pending.aggregationFilters.push(filterData);

    // Update UI
    renderExistingAggregationFilters();
    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
    populateCustomerMetricsDropdowns(); // Refresh to exclude used amount column

    // Reset inputs
    document.getElementById('spendingCustomerColumn').value = '';
    document.getElementById('spendingAmountColumn').value = '';
    document.getElementById('spendingValue').value = '';
    document.getElementById('spendingMin').value = '';
    document.getElementById('spendingMax').value = '';

    showNotification('Spending filter added', 'success');
}

function renderExistingAggregationFilters() {
    const container = document.getElementById('existingAggregationFiltersList');
    const section = document.getElementById('existingAggregationFiltersSection');
    const filters = customerFiltersState.pending.aggregationFilters;

    if (filters.length === 0) {
        section.classList.add('hidden');
        return;
    }

    section.classList.remove('hidden');
    container.innerHTML = filters.map((filter, index) => {
        let description = '';
        if (filter.type === 'transaction_count') {
            if (filter.filterType === 'range') {
                description = `Transactions: ${filter.min} - ${filter.max}`;
            } else if (filter.filterType === 'greater_than') {
                description = `Transactions > ${filter.value}`;
            } else {
                description = `Transactions < ${filter.value}`;
            }
            description += ` (grouped by ${filter.customerColumn})`;
        } else if (filter.type === 'spending') {
            if (filter.filterType === 'range') {
                description = `Spending: $${filter.min} - $${filter.max}`;
            } else if (filter.filterType === 'greater_than') {
                description = `Spending > $${filter.value}`;
            } else {
                description = `Spending < $${filter.value}`;
            }
            description += ` (SUM of ${filter.amountColumn})`;
        }

        return `
            <div class="existing-filter-item">
                <div class="existing-filter-info">
                    <div class="existing-filter-column">
                        <span class="existing-filter-column-name">${filter.type === 'transaction_count' ? 'Transaction Count' : 'Spending'}</span>
                        <span class="existing-filter-type-badge">${filter.filterType.replace('_', ' ')}</span>
                    </div>
                    <div class="existing-filter-value">${description}</div>
                </div>
                <div class="existing-filter-actions">
                    <button class="existing-filter-btn delete" onclick="removeAggregationFilter(${index})" title="Remove">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

function removeAggregationFilter(index) {
    customerFiltersState.pending.aggregationFilters.splice(index, 1);
    renderExistingAggregationFilters();
    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
    populateCustomerMetricsDropdowns(); // Refresh dropdowns
}

// ============================================================================
// PRODUCT METRICS MODAL
// ============================================================================

// Snapshot of aggregation filters when modal opens (for Cancel functionality)
let productMetricsModalSnapshot = null;

async function openProductMetricsModal() {
    const modal = document.getElementById('productMetricsModal');
    modal.classList.remove('hidden');

    // Store snapshot of current aggregation filters for Cancel functionality
    productMetricsModalSnapshot = JSON.parse(JSON.stringify(productFiltersState.pending.aggregationFilters));

    // Pre-fetch column analysis if not cached (needed to identify numeric columns)
    if (Object.keys(productFiltersState.columnAnalysis).length === 0) {
        await fetchColumnAnalysis();
    }

    // Populate column dropdowns
    populateProductMetricsDropdowns();

    // Render existing aggregation filters
    renderExistingProductAggregationFilters();

    // Reset form inputs
    resetProductMetricsInputs();
}

function closeProductMetricsModal() {
    const modal = document.getElementById('productMetricsModal');
    modal.classList.add('hidden');
    productMetricsModalSnapshot = null;
}

function applyProductMetricsFilters() {
    // Changes are already in pending state, just close the modal
    closeProductMetricsModal();

    // Update the summary and button state
    updateProductsFilterSummary();
    updateProductsRefreshButtonState();
}

function cancelProductMetricsModal() {
    // Restore the snapshot (revert any changes made during this modal session)
    if (productMetricsModalSnapshot !== null) {
        productFiltersState.pending.aggregationFilters = productMetricsModalSnapshot;
    }

    closeProductMetricsModal();

    // Update the summary and button state to reflect reverted state
    updateProductsFilterSummary();
    updateProductsRefreshButtonState();
}

function populateProductMetricsDropdowns() {
    // Get columns from schema builder
    const columns = [];
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            columns.push({ table: shortTable, column: col, fullName: `${shortTable}.${col}` });
        });
    });

    // Get column types from analysis if available
    const colAnalysis = productFiltersState.columnAnalysis;

    // Get timestamp column to exclude
    const timestampCol = document.getElementById('timestampColumn')?.value;

    // Numeric columns for amount (aggregation columns are REUSABLE)
    // Only exclude DATE columns
    const numericColumns = columns.filter(col => {
        const info = colAnalysis[col.fullName];
        const isNumeric = info?.type && ['INTEGER', 'FLOAT', 'INT64', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC'].includes(info.type.toUpperCase());
        // Only exclude DATE columns (they can only be used once)
        const isDateExcluded = isColumnCommittedInAnyFilter(col.fullName, 'date');
        const isTimestamp = timestampCol && col.fullName === timestampCol;
        return isNumeric && !isDateExcluded && !isTimestamp;
    });

    // Transaction Count - Product ID (grouping column - only exclude date columns)
    const txnCountProductSelect = document.getElementById('productTxnCountProductColumn');
    txnCountProductSelect.innerHTML = '<option value="">Select column...</option>';
    columns.forEach(col => {
        // Exclude timestamp column and date-filtered columns
        if (timestampCol && col.fullName === timestampCol) return;
        if (isColumnCommittedInAnyFilter(col.fullName, 'date')) return;

        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = col.fullName;
        txnCountProductSelect.appendChild(option);
    });

    // Revenue - Product ID (grouping column - only exclude date columns)
    const revenueProductSelect = document.getElementById('productRevenueProductColumn');
    revenueProductSelect.innerHTML = '<option value="">Select column...</option>';
    columns.forEach(col => {
        // Exclude timestamp column and date-filtered columns
        if (timestampCol && col.fullName === timestampCol) return;
        if (isColumnCommittedInAnyFilter(col.fullName, 'date')) return;

        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = col.fullName;
        revenueProductSelect.appendChild(option);
    });

    // Revenue - Amount Column (aggregation column - REUSABLE across sub-chapters)
    // But within Product Metrics, we exclude columns already used in PENDING aggregations
    // to avoid duplicate filters within the same modal
    const revenueAmountSelect = document.getElementById('productRevenueAmountColumn');
    revenueAmountSelect.innerHTML = '<option value="">Select column...</option>';
    numericColumns.forEach(col => {
        // Check if this column is already used in pending product aggregations (within same modal)
        const isUsedInPending = productFiltersState.pending.aggregationFilters.some(f => f.amountColumn === col.fullName);
        // Check if used as revenue column in top products (within same modal)
        const isUsedAsRevenue = productFiltersState.pending.topRevenue.revenueColumn === col.fullName;
        // Note: We do NOT exclude based on committed state - aggregation columns are reusable!
        if (!isUsedInPending && !isUsedAsRevenue) {
            const option = document.createElement('option');
            option.value = col.fullName;
            option.textContent = col.fullName;
            revenueAmountSelect.appendChild(option);
        }
    });
}

function resetProductMetricsInputs() {
    // Reset transaction count inputs
    document.getElementById('productTxnCountFilterType').value = 'greater_than';
    document.getElementById('productTxnCountValue').value = '';
    document.getElementById('productTxnCountMin').value = '';
    document.getElementById('productTxnCountMax').value = '';
    updateProductTxnCountInputs();

    // Reset revenue inputs
    document.getElementById('productRevenueFilterType').value = 'greater_than';
    document.getElementById('productRevenueValue').value = '';
    document.getElementById('productRevenueMin').value = '';
    document.getElementById('productRevenueMax').value = '';
    updateProductRevenueInputs();
}

function updateProductTxnCountInputs() {
    const filterType = document.getElementById('productTxnCountFilterType').value;
    const valueContainer = document.getElementById('productTxnCountValueContainer');
    const minContainer = document.getElementById('productTxnCountMinContainer');
    const maxContainer = document.getElementById('productTxnCountMaxContainer');

    if (filterType === 'range') {
        valueContainer.classList.add('hidden');
        minContainer.classList.remove('hidden');
        maxContainer.classList.remove('hidden');
    } else {
        valueContainer.classList.remove('hidden');
        minContainer.classList.add('hidden');
        maxContainer.classList.add('hidden');
    }
}

function updateProductRevenueInputs() {
    const filterType = document.getElementById('productRevenueFilterType').value;
    const valueContainer = document.getElementById('productRevenueValueContainer');
    const minContainer = document.getElementById('productRevenueMinContainer');
    const maxContainer = document.getElementById('productRevenueMaxContainer');

    if (filterType === 'range') {
        valueContainer.classList.add('hidden');
        minContainer.classList.remove('hidden');
        maxContainer.classList.remove('hidden');
    } else {
        valueContainer.classList.remove('hidden');
        minContainer.classList.add('hidden');
        maxContainer.classList.add('hidden');
    }
}

function addProductTransactionCountFilter() {
    const productColumn = document.getElementById('productTxnCountProductColumn').value;
    const filterType = document.getElementById('productTxnCountFilterType').value;

    if (!productColumn) {
        showNotification('Please select a product ID column', 'error');
        return;
    }

    let filterData = {
        type: 'transaction_count',
        productColumn: productColumn,
        filterType: filterType
    };

    if (filterType === 'range') {
        const min = parseFloat(document.getElementById('productTxnCountMin').value);
        const max = parseFloat(document.getElementById('productTxnCountMax').value);
        if (isNaN(min) || isNaN(max)) {
            showNotification('Please enter valid min and max values', 'error');
            return;
        }
        filterData.min = min;
        filterData.max = max;
    } else {
        const value = parseFloat(document.getElementById('productTxnCountValue').value);
        if (isNaN(value)) {
            showNotification('Please enter a valid value', 'error');
            return;
        }
        filterData.value = value;
    }

    // Add to pending state
    productFiltersState.pending.aggregationFilters.push(filterData);

    // Update UI
    renderExistingProductAggregationFilters();
    updateProductsFilterSummary();
    updateProductsRefreshButtonState();

    // Reset inputs
    document.getElementById('productTxnCountProductColumn').value = '';
    document.getElementById('productTxnCountValue').value = '';
    document.getElementById('productTxnCountMin').value = '';
    document.getElementById('productTxnCountMax').value = '';

    showNotification('Transaction count filter added', 'success');
}

function addProductRevenueFilter() {
    const productColumn = document.getElementById('productRevenueProductColumn').value;
    const amountColumn = document.getElementById('productRevenueAmountColumn').value;
    const filterType = document.getElementById('productRevenueFilterType').value;

    if (!productColumn) {
        showNotification('Please select a product ID column', 'error');
        return;
    }
    if (!amountColumn) {
        showNotification('Please select an amount column', 'error');
        return;
    }

    let filterData = {
        type: 'total_revenue',
        productColumn: productColumn,
        amountColumn: amountColumn,
        filterType: filterType
    };

    if (filterType === 'range') {
        const min = parseFloat(document.getElementById('productRevenueMin').value);
        const max = parseFloat(document.getElementById('productRevenueMax').value);
        if (isNaN(min) || isNaN(max)) {
            showNotification('Please enter valid min and max values', 'error');
            return;
        }
        filterData.min = min;
        filterData.max = max;
    } else {
        const value = parseFloat(document.getElementById('productRevenueValue').value);
        if (isNaN(value)) {
            showNotification('Please enter a valid value', 'error');
            return;
        }
        filterData.value = value;
    }

    // Add to pending state
    productFiltersState.pending.aggregationFilters.push(filterData);

    // Update UI
    renderExistingProductAggregationFilters();
    updateProductsFilterSummary();
    updateProductsRefreshButtonState();
    populateProductMetricsDropdowns(); // Refresh to exclude used amount column

    // Reset inputs
    document.getElementById('productRevenueProductColumn').value = '';
    document.getElementById('productRevenueAmountColumn').value = '';
    document.getElementById('productRevenueValue').value = '';
    document.getElementById('productRevenueMin').value = '';
    document.getElementById('productRevenueMax').value = '';

    showNotification('Revenue filter added', 'success');
}

function renderExistingProductAggregationFilters() {
    const container = document.getElementById('existingProductAggregationFiltersList');
    const section = document.getElementById('existingProductAggregationFiltersSection');
    const filters = productFiltersState.pending.aggregationFilters;

    if (filters.length === 0) {
        section.classList.add('hidden');
        return;
    }

    section.classList.remove('hidden');
    container.innerHTML = filters.map((filter, index) => {
        let description = '';
        if (filter.type === 'transaction_count') {
            if (filter.filterType === 'range') {
                description = `Transactions: ${filter.min} - ${filter.max}`;
            } else if (filter.filterType === 'greater_than') {
                description = `Transactions > ${filter.value}`;
            } else {
                description = `Transactions < ${filter.value}`;
            }
            description += ` (grouped by ${filter.productColumn})`;
        } else if (filter.type === 'total_revenue') {
            if (filter.filterType === 'range') {
                description = `Revenue: $${filter.min} - $${filter.max}`;
            } else if (filter.filterType === 'greater_than') {
                description = `Revenue > $${filter.value}`;
            } else {
                description = `Revenue < $${filter.value}`;
            }
            description += ` (SUM of ${filter.amountColumn})`;
        }

        return `
            <div class="existing-filter-item">
                <div class="existing-filter-info">
                    <div class="existing-filter-column">
                        <span class="existing-filter-column-name">${filter.type === 'transaction_count' ? 'Transaction Count' : 'Revenue'}</span>
                        <span class="existing-filter-type-badge">${filter.filterType.replace('_', ' ')}</span>
                    </div>
                    <div class="existing-filter-value">${description}</div>
                </div>
                <div class="existing-filter-actions">
                    <button class="existing-filter-btn delete" onclick="removeProductAggregationFilter(${index})" title="Remove">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

function removeProductAggregationFilter(index) {
    productFiltersState.pending.aggregationFilters.splice(index, 1);
    renderExistingProductAggregationFilters();
    updateProductsFilterSummary();
    updateProductsRefreshButtonState();
    populateProductMetricsDropdowns(); // Refresh dropdowns
}

// ============================================================================
// CUSTOMER FILTER COLUMNS MODAL
// ============================================================================

async function openCustomerFilterColumnsModal() {
    const modal = document.getElementById('customerFilterColumnsModal');

    // Render existing customer filters
    renderCustomerExistingFiltersList();

    // Pre-fetch column analysis if not cached
    if (Object.keys(customerFiltersState.columnAnalysis).length === 0 &&
        Object.keys(productFiltersState.columnAnalysis).length === 0) {
        await fetchColumnAnalysis();
    }

    // Copy column analysis from products if not in customers
    if (Object.keys(customerFiltersState.columnAnalysis).length === 0) {
        customerFiltersState.columnAnalysis = { ...productFiltersState.columnAnalysis };
    }

    // Populate column dropdown
    populateCustomerFilterColumnDropdown();

    // Reset filter config
    resetCustomerFilterConfigArea();

    modal.classList.remove('hidden');
}

function closeCustomerFilterColumnsModal() {
    const modal = document.getElementById('customerFilterColumnsModal');
    modal.classList.add('hidden');
    resetCustomerFilterConfigArea();
}

function populateCustomerFilterColumnDropdown() {
    const select = document.getElementById('customerFilterColumnSelect');
    const availableColumns = getAvailableCustomerFilterColumns();

    select.innerHTML = '<option value="">Select column...</option>';

    // Group by table
    const byTable = {};
    availableColumns.forEach(col => {
        if (!byTable[col.table]) byTable[col.table] = [];
        byTable[col.table].push(col);
    });

    Object.entries(byTable).forEach(([table, cols]) => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = table;
        cols.forEach(col => {
            const colInfo = customerFiltersState.columnAnalysis[col.fullName] ||
                           productFiltersState.columnAnalysis[col.fullName];
            const option = document.createElement('option');
            option.value = col.fullName;
            option.textContent = `${col.column} (${colInfo?.type || 'unknown'})`;
            optgroup.appendChild(option);
        });
        select.appendChild(optgroup);
    });
}

function resetCustomerFilterConfigArea() {
    customerFiltersState.selectedFilterColumn = null;
    document.getElementById('customerFilterConfigContainer').classList.add('hidden');
    document.getElementById('customerCategoryFilterConfig').classList.add('hidden');
    document.getElementById('customerNumericFilterConfig').classList.add('hidden');
    document.getElementById('customerDateFilterConfig').classList.add('hidden');
    document.getElementById('customerFilterColumnSelect').value = '';
}

async function onCustomerFilterColumnSelect() {
    const select = document.getElementById('customerFilterColumnSelect');
    const columnName = select.value;

    if (!columnName) {
        resetCustomerFilterConfigArea();
        return;
    }

    customerFiltersState.selectedFilterColumn = columnName;

    // Get column info
    let colInfo = customerFiltersState.columnAnalysis[columnName] ||
                  productFiltersState.columnAnalysis[columnName];

    // If not cached, fetch analysis
    if (!colInfo) {
        await fetchColumnAnalysis();
        colInfo = customerFiltersState.columnAnalysis[columnName] ||
                  productFiltersState.columnAnalysis[columnName];
    }

    if (!colInfo) {
        console.error('Could not get column info for:', columnName);
        return;
    }

    // Show appropriate config panel
    document.getElementById('customerFilterConfigContainer').classList.remove('hidden');

    if (colInfo.filter_type === 'category') {
        showCustomerCategoryFilterConfig(columnName, colInfo);
    } else if (colInfo.filter_type === 'numeric') {
        showCustomerNumericFilterConfig(columnName, colInfo);
    } else if (colInfo.filter_type === 'date') {
        showCustomerDateFilterConfig(columnName, colInfo);
    }
}

function showCustomerCategoryFilterConfig(columnName, colInfo) {
    document.getElementById('customerCategoryFilterConfig').classList.remove('hidden');
    document.getElementById('customerNumericFilterConfig').classList.add('hidden');
    document.getElementById('customerDateFilterConfig').classList.add('hidden');

    document.getElementById('customerCategoryFilterColumnName').textContent = columnName;

    // Reset mode to include
    document.querySelector('input[name="customerCategoryMode"][value="include"]').checked = true;

    // Render values
    const container = document.getElementById('customerCategoryValuesContainer');
    const values = colInfo.values || colInfo.top_values || [];

    if (colInfo.display_mode === 'autocomplete') {
        container.innerHTML = `
            <div class="category-autocomplete-container">
                <input type="text" class="category-autocomplete-input" placeholder="Search values..." id="customerCategorySearch" oninput="onCustomerCategorySearch(this.value)">
                <div class="category-autocomplete-dropdown hidden" id="customerCategoryDropdown"></div>
            </div>
            <div class="category-selected-tags" id="customerCategorySelectedTags"></div>
        `;
    } else {
        container.innerHTML = `
            <div class="category-filter-list">
                ${values.map(v => `
                    <div class="category-filter-item" onclick="toggleCustomerCategoryValue(this, '${v.value.replace(/'/g, "\\'")}')">
                        <div class="category-filter-item-label">
                            <input type="checkbox" value="${v.value}">
                            <span>${v.value}</span>
                        </div>
                        <span class="category-filter-item-count">${v.count?.toLocaleString() || ''}</span>
                    </div>
                `).join('')}
            </div>
            <div class="category-filter-selected-count" id="customerCategorySelectedCount">0 selected</div>
        `;
    }
}

function showCustomerNumericFilterConfig(columnName, colInfo) {
    document.getElementById('customerNumericFilterConfig').classList.remove('hidden');
    document.getElementById('customerCategoryFilterConfig').classList.add('hidden');
    document.getElementById('customerDateFilterConfig').classList.add('hidden');

    document.getElementById('customerNumericFilterColumnName').textContent = columnName;
    document.getElementById('customerNumericFilterTypeBadge').textContent = colInfo.type;

    // Show stats
    const statsDiv = document.getElementById('customerNumericFilterStats');
    statsDiv.innerHTML = `Range: ${colInfo.min} - ${colInfo.max}${colInfo.null_percent > 0 ? ` | Nulls: ${colInfo.null_percent.toFixed(1)}%` : ''}`;

    // Reset inputs
    document.querySelector('input[name="customerNumericType"][value="range"]').checked = true;
    document.getElementById('customerNumericMin').value = '';
    document.getElementById('customerNumericMax').value = '';
    document.getElementById('customerNumericMin').placeholder = colInfo.min;
    document.getElementById('customerNumericMax').placeholder = colInfo.max;
    document.getElementById('customerNumericIncludeNulls').checked = true;

    updateCustomerNumericFilterInputs();
}

function showCustomerDateFilterConfig(columnName, colInfo) {
    document.getElementById('customerDateFilterConfig').classList.remove('hidden');
    document.getElementById('customerCategoryFilterConfig').classList.add('hidden');
    document.getElementById('customerNumericFilterConfig').classList.add('hidden');

    document.getElementById('customerDateFilterColumnName').textContent = columnName;

    // Show stats
    const statsDiv = document.getElementById('customerDateFilterStats');
    statsDiv.innerHTML = `Range: ${colInfo.min_date || 'N/A'} - ${colInfo.max_date || 'N/A'}`;

    // Reset to relative mode
    document.querySelector('input[name="customerDateType"][value="relative"]').checked = true;
    document.getElementById('customerDateRelativeOption').value = 'last_30_days';
    document.getElementById('customerDateIncludeNulls').checked = true;

    updateCustomerDateFilterInputs();
}

function updateCustomerNumericFilterInputs() {
    const filterType = document.querySelector('input[name="customerNumericType"]:checked')?.value || 'range';
    const minGroup = document.querySelector('#customerNumericInputs .numeric-filter-input-group:first-child');
    const maxGroup = document.querySelector('#customerNumericInputs .numeric-filter-input-group:last-child');

    if (filterType === 'range') {
        minGroup.style.display = '';
        maxGroup.style.display = '';
        document.querySelector('#customerNumericInputs .numeric-filter-input-group:first-child .numeric-filter-input-label').textContent = 'Min';
    } else if (filterType === 'greater_than') {
        minGroup.style.display = '';
        maxGroup.style.display = 'none';
        document.querySelector('#customerNumericInputs .numeric-filter-input-group:first-child .numeric-filter-input-label').textContent = 'Value';
    } else if (filterType === 'less_than') {
        minGroup.style.display = 'none';
        maxGroup.style.display = '';
    } else {
        minGroup.style.display = '';
        maxGroup.style.display = 'none';
        document.querySelector('#customerNumericInputs .numeric-filter-input-group:first-child .numeric-filter-input-label').textContent = 'Value';
    }
}

function updateCustomerDateFilterInputs() {
    const filterType = document.querySelector('input[name="customerDateType"]:checked')?.value || 'relative';
    document.getElementById('customerDateRelativeInputs').style.display = filterType === 'relative' ? '' : 'none';
    document.getElementById('customerDateRangeInputs').classList.toggle('hidden', filterType !== 'range');
}

function toggleCustomerCategoryValue(element, value) {
    const checkbox = element.querySelector('input[type="checkbox"]');
    checkbox.checked = !checkbox.checked;
    element.classList.toggle('selected', checkbox.checked);

    // Update count
    const selected = document.querySelectorAll('#customerCategoryValuesContainer .category-filter-item.selected').length;
    document.getElementById('customerCategorySelectedCount').textContent = `${selected} selected`;
}

function renderCustomerExistingFiltersList() {
    const container = document.getElementById('customerExistingFiltersList');
    const section = document.getElementById('customerExistingFiltersSection');
    const pending = customerFiltersState.pending;

    const allFilters = [
        ...pending.categoryFilters.map((f, i) => ({ ...f, type: 'category', index: i })),
        ...pending.numericFilters.map((f, i) => ({ ...f, type: 'numeric', index: i })),
        ...pending.dateFilters.map((f, i) => ({ ...f, type: 'date', index: i }))
    ];

    if (allFilters.length === 0) {
        section.classList.add('hidden');
        return;
    }

    section.classList.remove('hidden');
    container.innerHTML = allFilters.map(filter => {
        let description = '';
        let typeBadge = '';

        if (filter.type === 'category') {
            typeBadge = 'STRING';
            const mode = filter.mode === 'include' ? 'Include' : 'Exclude';
            const count = filter.values?.length || 0;
            description = `${mode}: ${count} value${count !== 1 ? 's' : ''}`;
        } else if (filter.type === 'numeric') {
            typeBadge = filter.colInfo?.type || 'NUMBER';
            if (filter.filterType === 'range') {
                description = `Range: ${filter.min || ''} - ${filter.max || ''}`;
            } else if (filter.filterType === 'greater_than') {
                description = `> ${filter.value}`;
            } else if (filter.filterType === 'less_than') {
                description = `< ${filter.value}`;
            } else {
                description = `= ${filter.value}`;
            }
        } else if (filter.type === 'date') {
            typeBadge = 'DATE';
            if (filter.dateType === 'relative') {
                description = filter.relativeOption?.replace(/_/g, ' ') || 'Relative';
            } else {
                description = `${filter.startDate || 'Start'} - ${filter.endDate || 'End'}`;
            }
        }

        return `
            <div class="existing-filter-item">
                <div class="existing-filter-info">
                    <div class="existing-filter-column">
                        <span class="existing-filter-column-name">${filter.column}</span>
                        <span class="existing-filter-type-badge">${typeBadge}</span>
                    </div>
                    <div class="existing-filter-value">${description}</div>
                </div>
                <div class="existing-filter-actions">
                    <button class="existing-filter-btn delete" onclick="removeCustomerColumnFilter('${filter.type}', ${filter.index})" title="Remove">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

function removeCustomerColumnFilter(type, index) {
    if (type === 'category') {
        customerFiltersState.pending.categoryFilters.splice(index, 1);
    } else if (type === 'numeric') {
        customerFiltersState.pending.numericFilters.splice(index, 1);
    } else if (type === 'date') {
        customerFiltersState.pending.dateFilters.splice(index, 1);
    }

    renderCustomerExistingFiltersList();
    populateCustomerFilterColumnDropdown();
    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
}

function applyCustomerFilterColumnsModal() {
    const columnName = customerFiltersState.selectedFilterColumn;

    if (columnName) {
        const colInfo = customerFiltersState.columnAnalysis[columnName] ||
                        productFiltersState.columnAnalysis[columnName];

        if (colInfo) {
            if (colInfo.filter_type === 'category') {
                addCustomerCategoryFilterFromModal();
            } else if (colInfo.filter_type === 'numeric') {
                addCustomerNumericFilterFromModal();
            } else if (colInfo.filter_type === 'date') {
                addCustomerDateFilterFromModal();
            }
        }
    }

    closeCustomerFilterColumnsModal();
}

function addCustomerCategoryFilterFromModal() {
    const columnName = customerFiltersState.selectedFilterColumn;
    const mode = document.querySelector('input[name="customerCategoryMode"]:checked')?.value || 'include';

    // Get selected values
    const values = [];
    document.querySelectorAll('#customerCategoryValuesContainer .category-filter-item.selected input').forEach(cb => {
        values.push(cb.value);
    });

    if (values.length === 0) {
        showNotification('Please select at least one value', 'warning');
        return;
    }

    const colInfo = customerFiltersState.columnAnalysis[columnName] ||
                    productFiltersState.columnAnalysis[columnName];

    customerFiltersState.pending.categoryFilters.push({
        column: columnName,
        mode: mode,
        values: values,
        colInfo: colInfo
    });

    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
    showNotification('Category filter added', 'success');
}

function addCustomerNumericFilterFromModal() {
    const columnName = customerFiltersState.selectedFilterColumn;
    const filterType = document.querySelector('input[name="customerNumericType"]:checked')?.value || 'range';
    const includeNulls = document.getElementById('customerNumericIncludeNulls').checked;

    const colInfo = customerFiltersState.columnAnalysis[columnName] ||
                    productFiltersState.columnAnalysis[columnName];

    let filterData = {
        column: columnName,
        filterType: filterType,
        includeNulls: includeNulls,
        colInfo: colInfo
    };

    if (filterType === 'range') {
        filterData.min = parseFloat(document.getElementById('customerNumericMin').value) || null;
        filterData.max = parseFloat(document.getElementById('customerNumericMax').value) || null;
    } else {
        filterData.value = parseFloat(document.getElementById('customerNumericMin').value);
        if (isNaN(filterData.value)) {
            showNotification('Please enter a valid value', 'error');
            return;
        }
    }

    customerFiltersState.pending.numericFilters.push(filterData);

    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
    showNotification('Numeric filter added', 'success');
}

function addCustomerDateFilterFromModal() {
    const columnName = customerFiltersState.selectedFilterColumn;
    const dateType = document.querySelector('input[name="customerDateType"]:checked')?.value || 'relative';
    const includeNulls = document.getElementById('customerDateIncludeNulls').checked;

    const colInfo = customerFiltersState.columnAnalysis[columnName] ||
                    productFiltersState.columnAnalysis[columnName];

    let filterData = {
        column: columnName,
        dateType: dateType,
        includeNulls: includeNulls,
        colInfo: colInfo
    };

    if (dateType === 'relative') {
        filterData.relativeOption = document.getElementById('customerDateRelativeOption').value;
    } else {
        filterData.startDate = document.getElementById('customerDateStart').value || null;
        filterData.endDate = document.getElementById('customerDateEnd').value || null;
    }

    customerFiltersState.pending.dateFilters.push(filterData);

    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
    showNotification('Date filter added', 'success');
}

// ============================================================================
// FILTER COLUMNS MODAL
// ============================================================================

async function openFilterColumnsModal() {
    const modal = document.getElementById('filterColumnsModal');

    // Populate existing filters list
    renderExistingFiltersList();

    // Pre-fetch column analysis if not already cached
    if (Object.keys(productFiltersState.columnAnalysis).length === 0) {
        await fetchColumnAnalysis();
    }

    // Populate column dropdown (after analysis is fetched so types are shown)
    populateFilterColumnDropdown();

    // Reset filter config area
    resetFilterConfigArea();

    modal.classList.remove('hidden');
}

function closeFilterColumnsModal() {
    const modal = document.getElementById('filterColumnsModal');
    modal.classList.add('hidden');
    resetFilterConfigArea();
}

function applyFilterColumnsModal() {
    // Check if a filter is configured and add it
    const columnName = productFiltersState.selectedFilterColumn;
    if (columnName) {
        const colInfo = productFiltersState.columnAnalysis[columnName];
        if (colInfo) {
            if (colInfo.filter_type === 'category') {
                addCategoryFilterFromModal();
            } else if (colInfo.filter_type === 'numeric') {
                addNumericFilterFromModal();
            } else if (colInfo.filter_type === 'date') {
                addDateFilterFromModal();
            }
        }
    }
    closeFilterColumnsModal();
}

function renderExistingFiltersList() {
    const section = document.getElementById('existingFiltersSection');
    const list = document.getElementById('existingFiltersList');
    const pending = productFiltersState.pending;

    const allFilters = [
        ...pending.categoryFilters.map(f => ({ ...f, filterType: 'category' })),
        ...pending.numericFilters.map(f => ({ ...f, filterType: 'numeric' })),
        ...pending.dateFilters.map(f => ({ ...f, filterType: 'date' }))
    ];

    if (allFilters.length === 0) {
        section.classList.add('hidden');
        return;
    }

    section.classList.remove('hidden');
    list.innerHTML = allFilters.map((filter, index) => {
        let valueDisplay = '';
        let typeBadge = filter.colInfo?.type || 'STRING';

        if (filter.filterType === 'category') {
            const mode = filter.mode === 'include' ? 'Include' : 'Exclude';
            const valueCount = filter.values?.length || 0;
            valueDisplay = `${mode}: ${valueCount} value${valueCount !== 1 ? 's' : ''} selected`;
        } else if (filter.filterType === 'numeric') {
            if (filter.type === 'range') {
                const min = filter.min !== null && filter.min !== '' ? filter.min : '...';
                const max = filter.max !== null && filter.max !== '' ? filter.max : '...';
                valueDisplay = `Range: ${min} - ${max}`;
            } else if (filter.type === 'greater_than') {
                valueDisplay = `Greater than: ${filter.value}`;
            } else if (filter.type === 'less_than') {
                valueDisplay = `Less than: ${filter.value}`;
            } else if (filter.type === 'equals') {
                valueDisplay = `Equals: ${filter.value}`;
            } else if (filter.type === 'not_equals') {
                valueDisplay = `Not Equals: ${filter.value}`;
            }
        } else if (filter.filterType === 'date') {
            typeBadge = 'DATE';
            if (filter.dateFilterType === 'relative') {
                const relativeLabels = {
                    'last_7_days': 'Last 7 days',
                    'last_30_days': 'Last 30 days',
                    'last_90_days': 'Last 90 days',
                    'this_month': 'This month',
                    'this_quarter': 'This quarter',
                    'this_year': 'This year'
                };
                valueDisplay = relativeLabels[filter.relativeOption] || filter.relativeOption;
            } else {
                valueDisplay = `${filter.startDate || '...'} to ${filter.endDate || '...'}`;
            }
        }

        return `
            <div class="existing-filter-item" data-filter-type="${filter.filterType}" data-filter-index="${index}">
                <div class="existing-filter-info">
                    <div class="existing-filter-column">
                        <span class="existing-filter-column-name">${filter.column}</span>
                        <span class="existing-filter-type-badge">${typeBadge}</span>
                    </div>
                    <div class="existing-filter-value">${valueDisplay}</div>
                </div>
                <div class="existing-filter-actions">
                    <button class="existing-filter-btn delete" onclick="removeExistingFilter('${filter.filterType}', '${filter.column}')" title="Remove filter">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

function removeExistingFilter(filterType, columnName) {
    const pending = productFiltersState.pending;

    if (filterType === 'category') {
        pending.categoryFilters = pending.categoryFilters.filter(f => f.column !== columnName);
    } else if (filterType === 'numeric') {
        pending.numericFilters = pending.numericFilters.filter(f => f.column !== columnName);
    } else if (filterType === 'date') {
        pending.dateFilters = pending.dateFilters.filter(f => f.column !== columnName);
    }

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

function populateFilterColumnDropdown() {
    const select = document.getElementById('filterColumnSelect');
    select.innerHTML = '<option value="">Select column...</option>';

    // Get available columns (excluding already used ones)
    const availableColumns = getAvailableFilterColumns();

    availableColumns.forEach(col => {
        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = `${col.fullName} (${col.type || 'unknown'})`;
        select.appendChild(option);
    });
}

function getAvailableFilterColumns() {
    const allColumns = [];
    const timestampCol = document.getElementById('timestampColumn')?.value;

    // Get columns from schema builder
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            const fullName = `${shortTable}.${col}`;
            // Get column type from metadata if available
            const colInfo = productFiltersState.columnAnalysis[fullName];
            allColumns.push({
                table: shortTable,
                column: col,
                fullName,
                type: colInfo?.type || 'unknown'
            });
        });
    });

    // Filter out columns based on TYPE-AWARE exclusion rules:
    // - DATE/TIMESTAMP: Can only be used ONCE anywhere (check date filters)
    // - STRING: Can be used for grouping, but only ONCE for category filtering
    // - INTEGER/FLOAT: Can be used for aggregation, but only ONCE for numeric range filtering
    return allColumns.filter(col => {
        // Always exclude timestamp column from Dates sub-chapter
        if (timestampCol && col.fullName === timestampCol) return false;

        const colType = col.type?.toUpperCase() || 'unknown';

        // DATE/TIMESTAMP columns - can only be used once anywhere
        if (['DATE', 'DATETIME', 'TIMESTAMP'].includes(colType)) {
            if (isColumnCommittedInAnyFilter(col.fullName, 'date')) return false;
            if (isColumnUsedInFilters(col.fullName, 'date')) return false;
        }

        // STRING columns - check category filter exclusion
        if (colType === 'STRING') {
            if (isColumnCommittedInAnyFilter(col.fullName, 'category')) return false;
            if (isColumnUsedInFilters(col.fullName, 'category')) return false;
        }

        // INTEGER/FLOAT columns - check numeric filter exclusion
        if (['INTEGER', 'INT64', 'FLOAT', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC'].includes(colType)) {
            if (isColumnCommittedInAnyFilter(col.fullName, 'numeric')) return false;
            if (isColumnUsedInFilters(col.fullName, 'numeric')) return false;
        }

        return true;
    });
}

async function onFilterColumnSelect() {
    const select = document.getElementById('filterColumnSelect');
    const columnName = select.value;

    productFiltersState.selectedFilterColumn = columnName;

    if (!columnName) {
        resetFilterConfigArea();
        return;
    }

    // Fetch column analysis if not cached or if cache is empty
    if (!productFiltersState.columnAnalysis[columnName] || Object.keys(productFiltersState.columnAnalysis).length === 0) {
        await fetchColumnAnalysis();
    }

    const colInfo = productFiltersState.columnAnalysis[columnName];
    if (!colInfo) {
        console.error('Column analysis not found for:', columnName);
        console.log('Available columns:', Object.keys(productFiltersState.columnAnalysis));
        resetFilterConfigArea();
        return;
    }

    showFilterConfigForType(columnName, colInfo);
}

function showFilterConfigForType(columnName, colInfo) {
    const container = document.getElementById('filterConfigContainer');
    const categoryConfig = document.getElementById('categoryFilterConfig');
    const numericConfig = document.getElementById('numericFilterConfig');
    const dateConfig = document.getElementById('dateFilterConfig');

    // Hide all configs first
    categoryConfig.classList.add('hidden');
    numericConfig.classList.add('hidden');
    dateConfig.classList.add('hidden');
    container.classList.remove('hidden');

    if (colInfo.filter_type === 'category') {
        showCategoryFilterConfig(columnName, colInfo);
    } else if (colInfo.filter_type === 'numeric') {
        showNumericFilterConfig(columnName, colInfo);
    } else if (colInfo.filter_type === 'date') {
        showDateFilterConfig(columnName, colInfo);
    }
}

function showCategoryFilterConfig(columnName, colInfo) {
    const config = document.getElementById('categoryFilterConfig');
    document.getElementById('categoryFilterColumnName').textContent = `${columnName} - ${colInfo.unique_count} unique values`;

    // Render values list
    const valuesContainer = document.getElementById('newCategoryValuesContainer');
    // Backend returns 'values' as array of {value, count} objects in list mode
    if (colInfo.display_mode === 'list' && colInfo.values) {
        valuesContainer.innerHTML = `
            <div class="category-filter-search">
                <input type="text" placeholder="Search values..." oninput="filterCategoryValues(this.value)">
            </div>
            <div class="category-filter-list" id="newCategoryValuesList">
                ${colInfo.values.map(item => `
                    <div class="category-filter-item" onclick="toggleCategoryValue(this, '${item.value.replace(/'/g, "\\'")}')">
                        <label class="category-filter-item-label">
                            <input type="checkbox" value="${item.value}">
                            ${item.value}
                        </label>
                        <span class="category-filter-item-count">(${item.count})</span>
                    </div>
                `).join('')}
            </div>
        `;
    } else {
        // Autocomplete mode for >100 values
        valuesContainer.innerHTML = `
            <div class="category-autocomplete-container">
                <input type="text" class="category-autocomplete-input" placeholder="Type to search values..."
                       oninput="searchCategoryValues(this.value, '${columnName}')" id="categoryAutocompleteInput">
                <div class="category-autocomplete-dropdown hidden" id="categoryAutocompleteDropdown"></div>
            </div>
            <div class="category-selected-tags" id="categorySelectedTags"></div>
        `;
    }

    // Reset mode selection
    document.querySelector('input[name="newCategoryMode"][value="include"]').checked = true;

    config.classList.remove('hidden');
}

function showNumericFilterConfig(columnName, colInfo) {
    const config = document.getElementById('numericFilterConfig');
    document.getElementById('numericFilterColumnName').textContent = columnName;
    document.getElementById('numericFilterTypeBadge').textContent = colInfo.type;
    document.getElementById('numericFilterStats').textContent =
        `Range: ${colInfo.min} - ${colInfo.max} | Nulls: ${colInfo.null_percent || 0}%`;

    // Reset filter type to range
    document.querySelector('input[name="newNumericType"][value="range"]').checked = true;

    // Rebuild the inputs first (this creates fresh input elements)
    updateNumericFilterInputs();

    // Now set values on the newly created inputs
    const minInput = document.getElementById('newNumericMin');
    const maxInput = document.getElementById('newNumericMax');
    if (minInput) {
        minInput.value = '';
        minInput.placeholder = colInfo.min || '';
    }
    if (maxInput) {
        maxInput.value = '';
        maxInput.placeholder = colInfo.max || '';
    }

    document.getElementById('newNumericIncludeNulls').checked = true;

    config.classList.remove('hidden');
}

function showDateFilterConfig(columnName, colInfo) {
    const config = document.getElementById('dateFilterConfig');
    document.getElementById('dateFilterColumnName').textContent = columnName;
    document.getElementById('dateFilterStats').textContent =
        `Range: ${colInfo.min_date || 'N/A'} - ${colInfo.max_date || 'N/A'}`;

    // Reset inputs
    document.querySelector('input[name="newDateType"][value="relative"]').checked = true;
    document.getElementById('newDateRelativeOption').value = 'last_30_days';
    document.getElementById('newDateStart').value = '';
    document.getElementById('newDateEnd').value = '';
    document.getElementById('newDateIncludeNulls').checked = true;

    updateDateFilterInputs();
    config.classList.remove('hidden');
}

function resetFilterConfigArea() {
    document.getElementById('filterConfigContainer').classList.add('hidden');
    document.getElementById('categoryFilterConfig').classList.add('hidden');
    document.getElementById('numericFilterConfig').classList.add('hidden');
    document.getElementById('dateFilterConfig').classList.add('hidden');
    document.getElementById('filterColumnSelect').value = '';
    productFiltersState.selectedFilterColumn = null;
}

function updateNumericFilterInputs() {
    const filterType = document.querySelector('input[name="newNumericType"]:checked').value;
    const inputsDiv = document.getElementById('newNumericInputs');

    if (filterType === 'range') {
        inputsDiv.innerHTML = `
            <div class="numeric-filter-input-group">
                <label class="numeric-filter-input-label">Min</label>
                <input type="number" class="numeric-filter-input" id="newNumericMin" placeholder="">
            </div>
            <div class="numeric-filter-input-group">
                <label class="numeric-filter-input-label">Max</label>
                <input type="number" class="numeric-filter-input" id="newNumericMax" placeholder="">
            </div>
        `;
    } else {
        inputsDiv.innerHTML = `
            <div class="numeric-filter-input-group" style="flex: 1;">
                <label class="numeric-filter-input-label">Value</label>
                <input type="number" class="numeric-filter-input" id="newNumericValue" placeholder="">
            </div>
        `;
    }
}

function updateDateFilterInputs() {
    const filterType = document.querySelector('input[name="newDateType"]:checked').value;
    const relativeInputs = document.getElementById('newDateRelativeInputs');
    const rangeInputs = document.getElementById('newDateRangeInputs');

    if (filterType === 'relative') {
        relativeInputs.classList.remove('hidden');
        rangeInputs.classList.add('hidden');
    } else {
        relativeInputs.classList.add('hidden');
        rangeInputs.classList.remove('hidden');
    }
}

// --- Add filters from modal ---
function addCategoryFilterFromModal() {
    const columnName = productFiltersState.selectedFilterColumn;
    const colInfo = productFiltersState.columnAnalysis[columnName];
    const mode = document.querySelector('input[name="newCategoryMode"]:checked').value;

    // Get selected values
    let selectedValues = [];
    if (colInfo.display_mode === 'list') {
        const checkboxes = document.querySelectorAll('#newCategoryValuesList input[type="checkbox"]:checked');
        selectedValues = Array.from(checkboxes).map(cb => cb.value);
    } else {
        // Get from tags for autocomplete mode
        const tags = document.querySelectorAll('#categorySelectedTags .category-selected-tag');
        selectedValues = Array.from(tags).map(tag => tag.dataset.value);
    }

    if (selectedValues.length === 0) {
        alert('Please select at least one value');
        return;
    }

    const filterData = {
        column: columnName,
        mode: mode,
        values: selectedValues,
        colInfo: colInfo
    };

    productFiltersState.pending.categoryFilters.push(filterData);

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    resetFilterConfigArea();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

function addNumericFilterFromModal() {
    const columnName = productFiltersState.selectedFilterColumn;
    const colInfo = productFiltersState.columnAnalysis[columnName];
    const filterType = document.querySelector('input[name="newNumericType"]:checked').value;
    const includeNulls = document.getElementById('newNumericIncludeNulls').checked;

    const filterData = {
        column: columnName,
        type: filterType,
        includeNulls: includeNulls,
        colInfo: colInfo
    };

    if (filterType === 'range') {
        filterData.min = document.getElementById('newNumericMin').value || null;
        filterData.max = document.getElementById('newNumericMax').value || null;
        if (!filterData.min && !filterData.max) {
            alert('Please specify at least a min or max value');
            return;
        }
    } else {
        filterData.value = document.getElementById('newNumericValue')?.value;
        if (!filterData.value) {
            alert('Please specify a value');
            return;
        }
    }

    productFiltersState.pending.numericFilters.push(filterData);

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    resetFilterConfigArea();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

function addDateFilterFromModal() {
    const columnName = productFiltersState.selectedFilterColumn;
    const colInfo = productFiltersState.columnAnalysis[columnName];
    const dateFilterType = document.querySelector('input[name="newDateType"]:checked').value;
    const includeNulls = document.getElementById('newDateIncludeNulls').checked;

    const filterData = {
        column: columnName,
        dateFilterType: dateFilterType,
        includeNulls: includeNulls,
        colInfo: colInfo
    };

    if (dateFilterType === 'relative') {
        filterData.relativeOption = document.getElementById('newDateRelativeOption').value;
    } else {
        filterData.startDate = document.getElementById('newDateStart').value || null;
        filterData.endDate = document.getElementById('newDateEnd').value || null;
        if (!filterData.startDate && !filterData.endDate) {
            alert('Please specify at least a start or end date');
            return;
        }
    }

    productFiltersState.pending.dateFilters.push(filterData);

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    resetFilterConfigArea();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

// --- Category filter helpers ---
function toggleCategoryValue(element, value) {
    const checkbox = element.querySelector('input[type="checkbox"]');
    checkbox.checked = !checkbox.checked;
    element.classList.toggle('selected', checkbox.checked);
}

function filterCategoryValues(searchTerm) {
    const items = document.querySelectorAll('#newCategoryValuesList .category-filter-item');
    const search = searchTerm.toLowerCase();

    items.forEach(item => {
        const label = item.querySelector('.category-filter-item-label').textContent.toLowerCase();
        item.style.display = label.includes(search) ? '' : 'none';
    });
}

async function searchCategoryValues(searchTerm, columnName) {
    const dropdown = document.getElementById('categoryAutocompleteDropdown');

    if (searchTerm.length < 2) {
        dropdown.classList.add('hidden');
        return;
    }

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/search-category-values/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                session_id: schemaBuilderState.sessionId,
                column_name: columnName,
                search_term: searchTerm,
                limit: 20
            })
        });

        const data = await response.json();
        if (data.status === 'success' && data.values) {
            dropdown.innerHTML = data.values.map(v => `
                <div class="category-autocomplete-item" onclick="selectAutocompleteValue('${v.value.replace(/'/g, "\\'")}', ${v.count})">
                    <span>${v.value}</span>
                    <span style="color: #9ca3af; font-size: 11px;">(${v.count})</span>
                </div>
            `).join('');
            dropdown.classList.remove('hidden');
        }
    } catch (error) {
        console.error('Error searching category values:', error);
    }
}

function selectAutocompleteValue(value, count) {
    const tagsContainer = document.getElementById('categorySelectedTags');
    const dropdown = document.getElementById('categoryAutocompleteDropdown');
    const input = document.getElementById('categoryAutocompleteInput');

    // Check if already selected
    const existing = tagsContainer.querySelector(`[data-value="${value}"]`);
    if (existing) return;

    // Add tag
    const tag = document.createElement('span');
    tag.className = 'category-selected-tag';
    tag.dataset.value = value;
    tag.innerHTML = `${value} <span class="category-selected-tag-remove" onclick="this.parentElement.remove()">&times;</span>`;
    tagsContainer.appendChild(tag);

    // Clear input and hide dropdown
    input.value = '';
    dropdown.classList.add('hidden');
}

// --- Summary and Badge Updates ---
// Track if product filters have been applied (via Refresh Dataset click)
let productFiltersApplied = false;

// Update the Products summary line (shows pending filter details with delete buttons)
function updateProductsFilterSummary() {
    const summaryDiv = document.getElementById('productsFilterSummary');
    const summaryItems = document.getElementById('productsFilterSummaryItems');
    const pending = productFiltersState.pending;

    const filters = [];
    let filterNumber = 1;

    // Top products - unified format: "Top products: product_col by revenue_col, top X% (count)"
    if (pending.topRevenue.enabled) {
        const productCol = pending.topRevenue.productColumn?.split('.').pop() || 'product';
        const revenueCol = pending.topRevenue.revenueColumn?.split('.').pop() || 'revenue';

        // Get the number of products from analysis data if available
        // Use distribution data to find the actual product count at the user's threshold
        let productCount = null;
        if (productAnalysisData && productAnalysisData.distribution) {
            const threshold = pending.topRevenue.thresholdPercent;
            for (const point of productAnalysisData.distribution) {
                if (point.cumulative_revenue_percent >= threshold) {
                    productCount = point.product_count;
                    break;
                }
            }
        }

        const countInfo = productCount !== null ? ` (${productCount})` : '';
        const description = `Top products: ${productCol} by ${revenueCol}, top ${pending.topRevenue.thresholdPercent}%${countInfo}`;

        filters.push({
            number: filterNumber++,
            type: 'topRevenue',
            description: description,
            deleteAction: 'deleteFilterFromSummary("topRevenue", 0)'
        });
    }

    // Category filters - unified format: "Category: column, include/exclude X values"
    pending.categoryFilters.forEach((f, idx) => {
        const shortName = f.column.split('.').pop();
        const modeText = f.mode === 'include' ? 'include' : 'exclude';
        const valueCount = f.values?.length || 0;
        filters.push({
            number: filterNumber++,
            type: 'category',
            index: idx,
            description: `Category: ${shortName}, ${modeText} ${valueCount} value${valueCount !== 1 ? 's' : ''}`,
            deleteAction: `deleteFilterFromSummary("category", ${idx})`
        });
    });

    // Numeric filters - unified format: "Numeric: column, condition"
    pending.numericFilters.forEach((f, idx) => {
        const shortName = f.column.split('.').pop();
        let condition = '';
        if (f.type === 'range') {
            const min = f.min !== null && f.min !== '' ? f.min : '...';
            const max = f.max !== null && f.max !== '' ? f.max : '...';
            condition = `${min} - ${max}`;
        } else if (f.type === 'greater_than') {
            condition = `> ${f.value}`;
        } else if (f.type === 'less_than') {
            condition = `< ${f.value}`;
        } else if (f.type === 'equals') {
            condition = `= ${f.value}`;
        } else if (f.type === 'not_equals') {
            condition = ` ${f.value}`;
        }
        filters.push({
            number: filterNumber++,
            type: 'numeric',
            index: idx,
            description: `Numeric: ${shortName}, ${condition}`,
            deleteAction: `deleteFilterFromSummary("numeric", ${idx})`
        });
    });

    // Aggregation filters - unified format: "Metric: type, condition (grouped by col)"
    pending.aggregationFilters.forEach((f, idx) => {
        const productCol = f.productColumn?.split('.').pop() || 'product';
        let desc = '';
        if (f.type === 'transaction_count') {
            if (f.filterType === 'range') {
                desc = `Txn Count: ${f.min} - ${f.max} (by ${productCol})`;
            } else if (f.filterType === 'greater_than') {
                desc = `Txn Count: > ${f.value} (by ${productCol})`;
            } else {
                desc = `Txn Count: < ${f.value} (by ${productCol})`;
            }
        } else if (f.type === 'total_revenue') {
            const amountCol = f.amountColumn?.split('.').pop() || 'amount';
            if (f.filterType === 'range') {
                desc = `Revenue: $${f.min} - $${f.max} (SUM ${amountCol} by ${productCol})`;
            } else if (f.filterType === 'greater_than') {
                desc = `Revenue: > $${f.value} (SUM ${amountCol} by ${productCol})`;
            } else {
                desc = `Revenue: < $${f.value} (SUM ${amountCol} by ${productCol})`;
            }
        }
        filters.push({
            number: filterNumber++,
            type: 'aggregation',
            index: idx,
            description: desc,
            deleteAction: `deleteFilterFromSummary("aggregation", ${idx})`
        });
    });

    // Date filters - unified format: "Date: column, condition"
    pending.dateFilters.forEach((f, idx) => {
        const shortName = f.column.split('.').pop();
        let condition = '';
        if (f.dateFilterType === 'relative') {
            const relativeLabels = {
                'last_7_days': 'last 7 days',
                'last_30_days': 'last 30 days',
                'last_90_days': 'last 90 days',
                'this_month': 'this month',
                'this_quarter': 'this quarter',
                'this_year': 'this year'
            };
            condition = relativeLabels[f.relativeOption] || f.relativeOption;
        } else {
            condition = `${f.startDate || '...'} to ${f.endDate || '...'}`;
        }
        filters.push({
            number: filterNumber++,
            type: 'date',
            index: idx,
            description: `Date: ${shortName}, ${condition}`,
            deleteAction: `deleteFilterFromSummary("date", ${idx})`
        });
    });

    if (filters.length === 0) {
        summaryItems.innerHTML = '<span class="filter-summary-empty">No filters selected</span>';
        summaryDiv.classList.remove('has-pending');
    } else {
        summaryItems.innerHTML = filters.map(f => `
            <div class="filter-summary-item">
                <span class="filter-summary-item-number">Filter #${f.number}:</span>
                <span class="filter-summary-item-desc">${f.description}</span>
                <button type="button" class="filter-summary-item-delete" onclick="deleteFilterFromSummary('${f.type}', ${f.index !== undefined ? f.index : 0})" title="Remove filter">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
        `).join('');
        summaryDiv.classList.add('has-pending');
    }
}

// Delete a filter from the summary
function deleteFilterFromSummary(filterType, index) {
    const pending = productFiltersState.pending;

    if (filterType === 'topRevenue') {
        pending.topRevenue.enabled = false;
        pending.topRevenue.productColumn = null;
        pending.topRevenue.revenueColumn = null;
    } else if (filterType === 'aggregation') {
        pending.aggregationFilters.splice(index, 1);
    } else if (filterType === 'category') {
        pending.categoryFilters.splice(index, 1);
    } else if (filterType === 'numeric') {
        pending.numericFilters.splice(index, 1);
    } else if (filterType === 'date') {
        pending.dateFilters.splice(index, 1);
    }

    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

// Update the Products sub-chapter header badge (shows "X filters applied" after Refresh)
function updateProductsFilterStatus() {
    const statusEl = document.getElementById('productsFilterStatus');

    // Only show badge if filters have been applied via Refresh Dataset
    if (!productFiltersApplied) {
        statusEl.textContent = '';
        return;
    }

    const committed = productFiltersState.committed;
    let filterCount = 0;

    if (committed.topRevenue.enabled) filterCount++;
    filterCount += committed.aggregationFilters.length;
    filterCount += committed.categoryFilters.length;
    filterCount += committed.numericFilters.length;
    filterCount += committed.dateFilters.length;

    if (filterCount === 0) {
        statusEl.textContent = '';
    } else {
        statusEl.textContent = `${filterCount} filter${filterCount !== 1 ? 's' : ''} applied`;
    }
}

// Legacy function - kept for compatibility, now does nothing
function updateProductsNavBadges() {
    // Badges removed - now using summary line instead
}

// Update Products Refresh Dataset button state
function updateProductsRefreshButtonState() {
    const refreshBtn = document.getElementById('refreshProductFiltersBtn');
    if (!refreshBtn) return;

    // Enable button if pending state differs from committed state
    const pendingJson = JSON.stringify(productFiltersState.pending);
    const committedJson = JSON.stringify(productFiltersState.committed);
    const hasChanges = pendingJson !== committedJson;

    refreshBtn.disabled = !hasChanges;
    refreshBtn.classList.toggle('filter-button-disabled', !hasChanges);

    // Update "unapplied changes" indicator
    updateProductsUnappliedIndicator(hasChanges);
}

function updateProductsUnappliedIndicator(hasChanges) {
    const summaryDiv = document.getElementById('productsFilterSummary');
    if (!summaryDiv) return;

    // Remove existing indicator if present
    const existingIndicator = summaryDiv.querySelector('.unapplied-changes-indicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }

    // Add indicator if there are unapplied changes and filters were previously applied
    if (hasChanges && productFiltersApplied) {
        const indicator = document.createElement('div');
        indicator.className = 'unapplied-changes-indicator';
        indicator.innerHTML = '<i class="fas fa-exclamation-circle"></i> Unapplied changes - click "Refresh Dataset" to apply';
        summaryDiv.appendChild(indicator);
    }
}

// ============================================================================
// CUSTOMERS SUMMARY & REFRESH FUNCTIONS
// ============================================================================

// Update the Customers summary line (shows pending filter details with delete buttons)
function updateCustomersFilterSummary() {
    const summaryDiv = document.getElementById('customersFilterSummary');
    const summaryItems = document.getElementById('customersFilterSummaryItems');
    const pending = customerFiltersState.pending;

    const filters = [];
    let filterNumber = 1;

    // Top customers - unified format: "Top customers: customer_col by revenue_col, top X% (count)"
    if (pending.topRevenue.enabled) {
        const customerCol = pending.topRevenue.customerColumn?.split('.').pop() || 'customer';
        const revenueCol = pending.topRevenue.revenueColumn?.split('.').pop() || 'revenue';
        let customerCount = null;
        if (customerAnalysisData && customerAnalysisData.distribution) {
            const threshold = pending.topRevenue.thresholdPercent;
            for (const point of customerAnalysisData.distribution) {
                if (point.cumulative_revenue_percent >= threshold) {
                    customerCount = Math.round(customerAnalysisData.total_customers * point.customer_percent / 100);
                    break;
                }
            }
        }
        const countInfo = customerCount ? ` (${customerCount.toLocaleString()})` : '';
        const desc = `Top customers: ${customerCol} by ${revenueCol}, top ${pending.topRevenue.thresholdPercent}%${countInfo}`;
        filters.push({
            number: filterNumber++,
            type: 'topRevenue',
            index: 0,
            description: desc
        });
    }

    // Aggregation filters - unified format showing columns used
    pending.aggregationFilters.forEach((f, idx) => {
        const customerCol = f.customerColumn?.split('.').pop() || 'customer';
        let desc = '';
        if (f.type === 'transaction_count') {
            let condition = '';
            if (f.filterType === 'range') {
                condition = `${f.min} - ${f.max} transactions`;
            } else if (f.filterType === 'greater_than') {
                condition = `> ${f.value} transactions`;
            } else {
                condition = `< ${f.value} transactions`;
            }
            desc = `Transaction count: ${customerCol}, ${condition}`;
        } else if (f.type === 'spending') {
            const amountCol = f.amountColumn?.split('.').pop() || 'amount';
            let condition = '';
            if (f.filterType === 'range') {
                condition = `$${f.min} - $${f.max}`;
            } else if (f.filterType === 'greater_than') {
                condition = `> $${f.value}`;
            } else {
                condition = `< $${f.value}`;
            }
            desc = `Spending: ${customerCol} by ${amountCol}, ${condition}`;
        }
        filters.push({
            number: filterNumber++,
            type: 'aggregation',
            index: idx,
            description: desc
        });
    });

    // Category filters - unified format: "Category: column, include/exclude X values"
    pending.categoryFilters.forEach((f, idx) => {
        const shortName = f.column.split('.').pop();
        const valueCount = f.values?.length || 0;
        const modeText = f.mode === 'include' ? 'include' : 'exclude';
        filters.push({
            number: filterNumber++,
            type: 'category',
            index: idx,
            description: `Category: ${shortName}, ${modeText} ${valueCount} value${valueCount !== 1 ? 's' : ''}`
        });
    });

    // Numeric filters - unified format: "Numeric: column, condition"
    pending.numericFilters.forEach((f, idx) => {
        const shortName = f.column.split('.').pop();
        let condition = '';
        if (f.filterType === 'range') {
            condition = `${f.min || ''} - ${f.max || ''}`;
        } else if (f.filterType === 'greater_than') {
            condition = `> ${f.value}`;
        } else if (f.filterType === 'less_than') {
            condition = `< ${f.value}`;
        } else {
            condition = `= ${f.value}`;
        }
        filters.push({
            number: filterNumber++,
            type: 'numeric',
            index: idx,
            description: `Numeric: ${shortName}, ${condition}`
        });
    });

    // Date filters - unified format: "Date: column, condition"
    pending.dateFilters.forEach((f, idx) => {
        const shortName = f.column.split('.').pop();
        let condition = '';
        if (f.dateType === 'relative') {
            const relativeLabels = {
                'last_7_days': 'last 7 days',
                'last_30_days': 'last 30 days',
                'last_90_days': 'last 90 days',
                'this_month': 'this month',
                'this_quarter': 'this quarter',
                'this_year': 'this year'
            };
            condition = relativeLabels[f.relativeOption] || f.relativeOption;
        } else {
            condition = `${f.startDate || '...'} to ${f.endDate || '...'}`;
        }
        filters.push({
            number: filterNumber++,
            type: 'date',
            index: idx,
            description: `Date: ${shortName}, ${condition}`
        });
    });

    if (filters.length === 0) {
        summaryItems.innerHTML = '<span class="filter-summary-empty">No filters selected</span>';
        summaryDiv.classList.remove('has-pending');
    } else {
        summaryItems.innerHTML = filters.map(f => `
            <div class="filter-summary-item">
                <span class="filter-summary-item-number">Filter #${f.number}:</span>
                <span class="filter-summary-item-desc">${f.description}</span>
                <button type="button" class="filter-summary-item-delete" onclick="deleteCustomerFilterFromSummary('${f.type}', ${f.index})" title="Remove filter">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
        `).join('');
        summaryDiv.classList.add('has-pending');
    }
}

// Delete a customer filter from the summary
function deleteCustomerFilterFromSummary(filterType, index) {
    const pending = customerFiltersState.pending;

    if (filterType === 'topRevenue') {
        pending.topRevenue.enabled = false;
        pending.topRevenue.customerColumn = null;
        pending.topRevenue.revenueColumn = null;
    } else if (filterType === 'aggregation') {
        pending.aggregationFilters.splice(index, 1);
    } else if (filterType === 'category') {
        pending.categoryFilters.splice(index, 1);
    } else if (filterType === 'numeric') {
        pending.numericFilters.splice(index, 1);
    } else if (filterType === 'date') {
        pending.dateFilters.splice(index, 1);
    }

    updateCustomersFilterSummary();
    updateCustomersRefreshButtonState();
}

// Update the Customers sub-chapter header badge (shows "X filters applied" after Refresh)
function updateCustomersFilterStatus() {
    const statusEl = document.getElementById('customersFilterStatus');

    // Only show badge if filters have been applied via Refresh Dataset
    if (!customerFiltersApplied) {
        statusEl.textContent = '';
        return;
    }

    const committed = customerFiltersState.committed;
    let filterCount = 0;

    if (committed.topRevenue.enabled) filterCount++;
    filterCount += committed.aggregationFilters.length;
    filterCount += committed.categoryFilters.length;
    filterCount += committed.numericFilters.length;
    filterCount += committed.dateFilters.length;

    if (filterCount === 0) {
        statusEl.textContent = '';
    } else {
        statusEl.textContent = `${filterCount} filter${filterCount !== 1 ? 's' : ''} applied`;
    }
}

// Update Customers Refresh Dataset button state
function updateCustomersRefreshButtonState() {
    const refreshBtn = document.getElementById('refreshCustomerFiltersBtn');
    if (!refreshBtn) return;

    // Enable button if pending state differs from committed state
    const pendingJson = JSON.stringify(customerFiltersState.pending);
    const committedJson = JSON.stringify(customerFiltersState.committed);
    const hasChanges = pendingJson !== committedJson;

    refreshBtn.disabled = !hasChanges;
    refreshBtn.classList.toggle('filter-button-disabled', !hasChanges);

    // Update "unapplied changes" indicator
    updateCustomersUnappliedIndicator(hasChanges);
}

function updateCustomersUnappliedIndicator(hasChanges) {
    const summaryDiv = document.getElementById('customersFilterSummary');
    if (!summaryDiv) return;

    // Remove existing indicator if present
    const existingIndicator = summaryDiv.querySelector('.unapplied-changes-indicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }

    // Add indicator if there are unapplied changes and filters were previously applied
    if (hasChanges && customerFiltersApplied) {
        const indicator = document.createElement('div');
        indicator.className = 'unapplied-changes-indicator';
        indicator.innerHTML = '<i class="fas fa-exclamation-circle"></i> Unapplied changes - click "Refresh Dataset" to apply';
        summaryDiv.appendChild(indicator);
    }
}

// Refresh Customer Filters - commits pending to committed and updates Dataset Summary
async function refreshCustomerFilters() {
    const refreshBtn = document.getElementById('refreshCustomerFiltersBtn');
    const originalHtml = refreshBtn.innerHTML;
    refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
    refreshBtn.disabled = true;

    try {
        // Deep copy pending to committed
        customerFiltersState.committed = JSON.parse(JSON.stringify(customerFiltersState.pending));

        // Check if there are any filters after commit
        const committed = customerFiltersState.committed;
        const hasAnyFilters = committed.topRevenue.enabled ||
                              committed.aggregationFilters.length > 0 ||
                              committed.categoryFilters.length > 0 ||
                              committed.numericFilters.length > 0 ||
                              committed.dateFilters.length > 0;

        // Mark filters as applied only if there are actual filters
        // If all filters were deleted, reset the applied flag
        customerFiltersApplied = hasAnyFilters;

        // Update the header badge
        updateCustomersFilterStatus();

        // Build the customer_filter object and save to wizardData.filters
        const customerFilter = buildCustomerFilterForApi();
        wizardData.filters = wizardData.filters || {};
        if (Object.keys(customerFilter).length > 0) {
            wizardData.filters.customer_filter = customerFilter;
        } else {
            delete wizardData.filters.customer_filter;
        }

        // Update Dataset Summary panel
        await updateDatasetSummary();

        // Repopulate Products dropdowns to reflect changes in column availability
        populateProductFilterDropdowns();

    } catch (error) {
        console.error('Error refreshing customer filters:', error);
        showNotification('Failed to refresh customer filters', 'error');
    } finally {
        refreshBtn.innerHTML = originalHtml;
        updateCustomersRefreshButtonState();

        // Re-validate step 4 to enable/disable Save button
        validateCurrentStep();
    }
}

// --- Legacy Add Filter Modal (keeping for backwards compatibility) ---
function openAddFilterModal() {
    const modal = document.getElementById('addFilterModal');
    const select = document.getElementById('addFilterColumnSelect');

    // Populate column dropdown with filterable columns
    select.innerHTML = '<option value="">Choose a column...</option>';

    // Get selected columns from schema builder
    const allColumns = [];
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            const fullName = `${shortTable}.${col}`;
            // Exclude columns already used in filters
            if (!isColumnUsedInFilters(fullName)) {
                allColumns.push({ table: shortTable, column: col, fullName });
            }
        });
    });

    allColumns.forEach(c => {
        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        select.appendChild(option);
    });

    // Reset modal state
    document.getElementById('addFilterColumnInfo').classList.add('hidden');
    document.getElementById('addFilterConfirmBtn').disabled = true;

    modal.classList.remove('hidden');
}

function closeAddFilterModal() {
    document.getElementById('addFilterModal').classList.add('hidden');
}

// Check if a column is used in PENDING filters within the Products sub-chapter
// Type-aware: only excludes columns used for category, numeric, or date filtering
// Grouping columns (productColumn) and aggregation columns (revenueColumn) are NOT excluded
function isColumnUsedInFilters(columnName, usageType = 'any') {
    const pending = productFiltersState.pending;

    // Note: topRevenue.productColumn is GROUPING and topRevenue.revenueColumn is AGGREGATION
    // They should NOT cause exclusion since they can be reused

    switch (usageType) {
        case 'category':
            return pending.categoryFilters.some(f => f.column === columnName);

        case 'numeric':
            return pending.numericFilters.some(f => f.column === columnName);

        case 'date':
            return pending.dateFilters.some(f => f.column === columnName);

        case 'grouping':
        case 'aggregation':
            // Grouping and aggregation columns are always available
            return false;

        case 'any':
        default:
            // Check category, numeric, and date filters only
            // NOT grouping or aggregation columns (they're reusable)
            return pending.categoryFilters.some(f => f.column === columnName) ||
                   pending.numericFilters.some(f => f.column === columnName) ||
                   pending.dateFilters.some(f => f.column === columnName);
    }
}

// ============================================================================
// TYPE-AWARE COLUMN EXCLUSION LOGIC
// ============================================================================
//
// Column exclusion rules by type:
// - STRING columns: Can be used for GROUPING in multiple places (customer_id, product_id, etc.)
//                   Can only be used ONCE for CATEGORY filtering (IN/NOT IN)
// - INTEGER/FLOAT:  Can be used for AGGREGATION in multiple places (SUM, COUNT on total_amount, etc.)
//                   Can only be used ONCE for NUMERIC RANGE filtering (>, <, BETWEEN)
// - DATE/TIMESTAMP: Can only be used ONCE anywhere (Dates sub-chapter OR Filter Columns date filter)
//
// ============================================================================

// Check if a column is used as a DATE/TIMESTAMP filter anywhere (committed)
// DATE columns can only be used ONCE across all sub-chapters
function isColumnUsedAsDateFilter(columnName) {
    // Check Dates sub-chapter timestamp column
    if (committedDatesFilter.timestampColumn === columnName) return true;

    // Check Products date filters in Filter Columns
    if (productFiltersState.committed.dateFilters.some(f => f.column === columnName)) return true;

    // Check Customers date filters in Filter Columns
    if (customerFiltersState.committed.dateFilters.some(f => f.column === columnName)) return true;

    return false;
}

// Check if a column is used as a CATEGORY filter (STRING IN/NOT IN) anywhere (committed)
// STRING columns used for category filtering can only be used ONCE
function isColumnUsedAsCategoryFilter(columnName) {
    // Check Products category filters
    if (productFiltersState.committed.categoryFilters.some(f => f.column === columnName)) return true;

    // Check Customers category filters
    if (customerFiltersState.committed.categoryFilters.some(f => f.column === columnName)) return true;

    return false;
}

// Check if a column is used as a NUMERIC RANGE filter anywhere (committed)
// INTEGER/FLOAT columns used for numeric range filtering can only be used ONCE
function isColumnUsedAsNumericRangeFilter(columnName) {
    // Check Products numeric filters
    if (productFiltersState.committed.numericFilters.some(f => f.column === columnName)) return true;

    // Check Customers numeric filters
    if (customerFiltersState.committed.numericFilters.some(f => f.column === columnName)) return true;

    return false;
}

// Main exclusion function - type-aware
// usageType determines what kind of usage we're checking for:
// - 'date': Check if used as any date filter (for Dates timestamp dropdown and Filter Columns date)
// - 'category': Check if used as category filter (for Filter Columns category)
// - 'numeric': Check if used as numeric range filter (for Filter Columns numeric)
// - 'grouping': NEVER exclude - STRING grouping columns are reusable
// - 'aggregation': NEVER exclude - INTEGER/FLOAT aggregation columns are reusable
// - 'any': Legacy behavior - check all filter types (for general exclusion)
function isColumnCommittedInAnyFilter(columnName, usageType = 'any') {
    switch (usageType) {
        case 'date':
            // DATE/TIMESTAMP columns - can only be used ONCE anywhere
            return isColumnUsedAsDateFilter(columnName);

        case 'category':
            // STRING columns for category filtering - can only be used ONCE
            return isColumnUsedAsCategoryFilter(columnName);

        case 'numeric':
            // INTEGER/FLOAT columns for numeric range filtering - can only be used ONCE
            return isColumnUsedAsNumericRangeFilter(columnName);

        case 'grouping':
            // STRING grouping columns (customer_id, product_id) - ALWAYS available
            return false;

        case 'aggregation':
            // INTEGER/FLOAT aggregation columns (total_amount in SUM) - ALWAYS available
            return false;

        case 'any':
        default:
            // Legacy behavior: check DATE filters and category/numeric filters
            // But NOT aggregation columns (they're reusable)
            return isColumnUsedAsDateFilter(columnName) ||
                   isColumnUsedAsCategoryFilter(columnName) ||
                   isColumnUsedAsNumericRangeFilter(columnName);
    }
}

// Check if a column is used in PENDING filters within the Customers sub-chapter
// Type-aware: only excludes columns used for category, numeric, or date filtering
// Aggregation columns (used in SUM, etc.) are NOT excluded - they can be reused
function isColumnUsedInCustomerFilters(columnName, usageType = 'any') {
    const pending = customerFiltersState.pending;

    // Note: topRevenue.revenueColumn and aggregationFilters.amountColumn are AGGREGATION uses
    // They should NOT cause exclusion since INTEGER/FLOAT aggregation columns are reusable

    switch (usageType) {
        case 'category':
            return pending.categoryFilters.some(f => f.column === columnName);

        case 'numeric':
            return pending.numericFilters.some(f => f.column === columnName);

        case 'date':
            return pending.dateFilters.some(f => f.column === columnName);

        case 'grouping':
        case 'aggregation':
            // Grouping and aggregation columns are always available
            return false;

        case 'any':
        default:
            // Check category, numeric, and date filters only
            // NOT aggregation columns (they're reusable)
            return pending.categoryFilters.some(f => f.column === columnName) ||
                   pending.numericFilters.some(f => f.column === columnName) ||
                   pending.dateFilters.some(f => f.column === columnName);
    }
}

// Get columns available for Customer Filter Columns modal
// Uses TYPE-AWARE exclusion rules
function getAvailableCustomerFilterColumns() {
    const allColumns = [];
    const timestampCol = document.getElementById('timestampColumn')?.value;

    // Get columns from schema builder
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            const fullName = `${shortTable}.${col}`;
            // Get column type from metadata if available
            const colInfo = customerFiltersState.columnAnalysis[fullName] ||
                           productFiltersState.columnAnalysis[fullName];
            allColumns.push({
                table: shortTable,
                column: col,
                fullName,
                type: colInfo?.type || 'unknown'
            });
        });
    });

    // Filter out columns based on TYPE-AWARE exclusion rules:
    // - DATE/TIMESTAMP: Can only be used ONCE anywhere (check date filters)
    // - STRING: Can be used for grouping, but only ONCE for category filtering
    // - INTEGER/FLOAT: Can be used for aggregation, but only ONCE for numeric range filtering
    return allColumns.filter(col => {
        // Always exclude timestamp column from Dates sub-chapter
        if (timestampCol && col.fullName === timestampCol) return false;

        const colType = col.type?.toUpperCase() || 'unknown';

        // DATE/TIMESTAMP columns - can only be used once anywhere
        if (['DATE', 'DATETIME', 'TIMESTAMP'].includes(colType)) {
            if (isColumnCommittedInAnyFilter(col.fullName, 'date')) return false;
            if (isColumnUsedInCustomerFilters(col.fullName, 'date')) return false;
        }

        // STRING columns - check category filter exclusion
        if (colType === 'STRING') {
            if (isColumnCommittedInAnyFilter(col.fullName, 'category')) return false;
            if (isColumnUsedInCustomerFilters(col.fullName, 'category')) return false;
        }

        // INTEGER/FLOAT columns - check numeric filter exclusion
        if (['INTEGER', 'INT64', 'FLOAT', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC'].includes(colType)) {
            if (isColumnCommittedInAnyFilter(col.fullName, 'numeric')) return false;
            if (isColumnUsedInCustomerFilters(col.fullName, 'numeric')) return false;
        }

        return true;
    });
}

async function onAddFilterColumnChange() {
    const select = document.getElementById('addFilterColumnSelect');
    const columnName = select.value;
    const infoDiv = document.getElementById('addFilterColumnInfo');
    const confirmBtn = document.getElementById('addFilterConfirmBtn');

    if (!columnName) {
        infoDiv.classList.add('hidden');
        confirmBtn.disabled = true;
        return;
    }

    // Fetch column analysis if not cached
    if (!productFiltersState.columnAnalysis[columnName]) {
        await fetchColumnAnalysis();
    }

    const colInfo = productFiltersState.columnAnalysis[columnName];
    if (colInfo) {
        // Show column type and info
        let infoHtml = `<strong>Type:</strong> ${colInfo.type}<br>`;
        if (colInfo.filter_type === 'category') {
            infoHtml += `<strong>Unique values:</strong> ${colInfo.unique_count}`;
            if (colInfo.display_mode === 'autocomplete') {
                infoHtml += ' (autocomplete mode)';
            }
        } else if (colInfo.filter_type === 'numeric') {
            infoHtml += `<strong>Range:</strong> ${colInfo.min} - ${colInfo.max}`;
            if (colInfo.null_percent > 0) {
                infoHtml += `<br><strong>Nulls:</strong> ${colInfo.null_percent}%`;
            }
        }
        infoDiv.innerHTML = infoHtml;
        infoDiv.classList.remove('hidden');
        confirmBtn.disabled = !colInfo.filterable;
    } else {
        infoDiv.innerHTML = 'Column analysis not available';
        infoDiv.classList.remove('hidden');
        confirmBtn.disabled = true;
    }
}

async function fetchColumnAnalysis() {
    if (!schemaBuilderState.sessionId) return;

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/analyze-columns/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                session_id: schemaBuilderState.sessionId,
                selected_columns: schemaBuilderState.selectedColumns
            })
        });

        const data = await response.json();
        if (data.status === 'success') {
            productFiltersState.columnAnalysis = data.columns;
        }
    } catch (error) {
        console.error('Error fetching column analysis:', error);
    }
}

function confirmAddFilter() {
    const columnName = document.getElementById('addFilterColumnSelect').value;
    const colInfo = productFiltersState.columnAnalysis[columnName];

    if (!columnName || !colInfo || !colInfo.filterable) return;

    if (colInfo.filter_type === 'category') {
        addCategoryFilter(columnName, colInfo);
    } else if (colInfo.filter_type === 'numeric') {
        addNumericFilter(columnName, colInfo);
    }

    closeAddFilterModal();
}

// --- Category Filter Functions ---
function addCategoryFilter(columnName, colInfo) {
    const filterData = {
        column: columnName,
        mode: 'include',
        values: [],
        colInfo: colInfo
    };

    productFiltersState.pending.categoryFilters.push(filterData);
    renderCategoryFilters();
    updateProductFilterBadges();

    // Open the category filters section
    const content = document.getElementById('categoryFiltersContent');
    const header = content.previousElementSibling;
    content.classList.remove('hidden');
    header.classList.remove('collapsed');
}

function renderCategoryFilters() {
    const container = document.getElementById('categoryFilterCards');
    const emptyState = document.getElementById('categoryFiltersEmpty');
    const filters = productFiltersState.pending.categoryFilters;

    if (filters.length === 0) {
        container.innerHTML = '';
        emptyState.classList.remove('hidden');
        return;
    }

    emptyState.classList.add('hidden');
    container.innerHTML = filters.map((filter, index) => renderCategoryFilterCard(filter, index)).join('');
}

function renderCategoryFilterCard(filter, index) {
    const colInfo = filter.colInfo;
    const isAutocomplete = colInfo.display_mode === 'autocomplete';

    let valuesHtml = '';
    if (isAutocomplete) {
        // Autocomplete mode
        valuesHtml = `
            <div class="category-autocomplete-container">
                <input type="text" class="category-autocomplete-input"
                       placeholder="Search values..."
                       oninput="searchCategoryValues(${index}, this.value)"
                       onfocus="showAutocompleteDropdown(${index})">
                <div class="category-autocomplete-dropdown hidden" id="categoryAutocomplete_${index}">
                    <!-- Dropdown items inserted dynamically -->
                </div>
            </div>
            <div class="category-selected-tags" id="categoryTags_${index}">
                ${filter.values.map(v => `
                    <span class="category-selected-tag">
                        ${escapeHtml(v)}
                        <span class="category-selected-tag-remove" onclick="removeCategoryValue(${index}, '${escapeHtml(v)}')">&times;</span>
                    </span>
                `).join('')}
            </div>
        `;
    } else {
        // List mode with checkboxes
        const values = colInfo.values || [];
        valuesHtml = `
            <div class="category-filter-search">
                <input type="text" placeholder="Search..." oninput="filterCategoryList(${index}, this.value)">
            </div>
            <div class="category-filter-list" id="categoryList_${index}">
                ${values.map(v => `
                    <div class="category-filter-item ${filter.values.includes(v.value) ? 'selected' : ''}"
                         onclick="toggleCategoryValue(${index}, '${escapeHtml(v.value)}')">
                        <span class="category-filter-item-label">
                            <input type="checkbox" ${filter.values.includes(v.value) ? 'checked' : ''} readonly>
                            ${escapeHtml(v.value)}
                        </span>
                        <span class="category-filter-item-count">${v.count.toLocaleString()}</span>
                    </div>
                `).join('')}
            </div>
        `;
    }

    return `
        <div class="filter-card" id="categoryFilter_${index}">
            <div class="filter-card-header">
                <div class="filter-card-title">
                    <span class="filter-card-column-name">${filter.column}</span>
                    <span class="filter-card-type-badge">STRING</span>
                </div>
                <button class="filter-card-remove" onclick="removeCategoryFilter(${index})">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="filter-card-body">
                <div class="category-filter-mode">
                    <label>
                        <input type="radio" name="categoryMode_${index}" value="include"
                               ${filter.mode === 'include' ? 'checked' : ''}
                               onchange="setCategoryFilterMode(${index}, 'include')">
                        Include selected
                    </label>
                    <label>
                        <input type="radio" name="categoryMode_${index}" value="exclude"
                               ${filter.mode === 'exclude' ? 'checked' : ''}
                               onchange="setCategoryFilterMode(${index}, 'exclude')">
                        Exclude selected
                    </label>
                </div>
                ${valuesHtml}
                <div class="category-filter-selected-count">
                    Selected: ${filter.values.length} of ${colInfo.unique_count} values
                </div>
            </div>
        </div>
    `;
}

function setCategoryFilterMode(index, mode) {
    productFiltersState.pending.categoryFilters[index].mode = mode;
}

function toggleCategoryValue(index, value) {
    const filter = productFiltersState.pending.categoryFilters[index];
    const valueIndex = filter.values.indexOf(value);

    if (valueIndex === -1) {
        filter.values.push(value);
    } else {
        filter.values.splice(valueIndex, 1);
    }

    renderCategoryFilters();
}

function removeCategoryValue(index, value) {
    const filter = productFiltersState.pending.categoryFilters[index];
    const valueIndex = filter.values.indexOf(value);
    if (valueIndex !== -1) {
        filter.values.splice(valueIndex, 1);
        renderCategoryFilters();
    }
}

function removeCategoryFilter(index) {
    productFiltersState.pending.categoryFilters.splice(index, 1);
    renderCategoryFilters();
    updateProductFilterBadges();
}

function filterCategoryList(index, searchTerm) {
    const list = document.getElementById(`categoryList_${index}`);
    const items = list.querySelectorAll('.category-filter-item');
    const searchLower = searchTerm.toLowerCase();

    items.forEach(item => {
        const label = item.querySelector('.category-filter-item-label').textContent.toLowerCase();
        item.style.display = label.includes(searchLower) ? '' : 'none';
    });
}

async function searchCategoryValues(index, searchTerm) {
    const dropdown = document.getElementById(`categoryAutocomplete_${index}`);
    const filter = productFiltersState.pending.categoryFilters[index];

    if (searchTerm.length < 2) {
        dropdown.classList.add('hidden');
        return;
    }

    // Get table and column from column name
    const [tableName, colName] = filter.column.split('.');
    const fullTableName = `raw_data.${tableName}`;

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/search-category-values/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                session_id: schemaBuilderState.sessionId,
                table_name: fullTableName,
                column_name: colName,
                search_term: searchTerm,
                limit: 20
            })
        });

        const data = await response.json();
        if (data.status === 'success' && data.values.length > 0) {
            dropdown.innerHTML = data.values
                .filter(v => !filter.values.includes(v.value))
                .map(v => `
                    <div class="category-autocomplete-item" onclick="addAutocompleteValue(${index}, '${escapeHtml(v.value)}')">
                        <span>${escapeHtml(v.value)}</span>
                        <span class="category-filter-item-count">${v.count.toLocaleString()}</span>
                    </div>
                `).join('');
            dropdown.classList.remove('hidden');
        } else {
            dropdown.classList.add('hidden');
        }
    } catch (error) {
        console.error('Error searching category values:', error);
        dropdown.classList.add('hidden');
    }
}

function addAutocompleteValue(index, value) {
    const filter = productFiltersState.pending.categoryFilters[index];
    if (!filter.values.includes(value)) {
        filter.values.push(value);
        renderCategoryFilters();
    }
}

function showAutocompleteDropdown(index) {
    // Could show recent/top values here
}

// --- Numeric Filter Functions ---
function addNumericFilter(columnName, colInfo) {
    const filterData = {
        column: columnName,
        type: 'range',
        min: null,
        max: null,
        value: null,
        includeNulls: true,
        colInfo: colInfo
    };

    productFiltersState.pending.numericFilters.push(filterData);
    renderNumericFilters();
    updateProductFilterBadges();

    // Open the numeric filters section
    const content = document.getElementById('numericFiltersContent');
    const header = content.previousElementSibling;
    content.classList.remove('hidden');
    header.classList.remove('collapsed');
}

function renderNumericFilters() {
    const container = document.getElementById('numericFilterCards');
    const emptyState = document.getElementById('numericFiltersEmpty');
    const filters = productFiltersState.pending.numericFilters;

    if (filters.length === 0) {
        container.innerHTML = '';
        emptyState.classList.remove('hidden');
        return;
    }

    emptyState.classList.add('hidden');
    container.innerHTML = filters.map((filter, index) => renderNumericFilterCard(filter, index)).join('');
}

function renderNumericFilterCard(filter, index) {
    const colInfo = filter.colInfo;
    const isRange = filter.type === 'range';

    return `
        <div class="filter-card" id="numericFilter_${index}">
            <div class="filter-card-header">
                <div class="filter-card-title">
                    <span class="filter-card-column-name">${filter.column}</span>
                    <span class="filter-card-type-badge">${colInfo.type}</span>
                </div>
                <button class="filter-card-remove" onclick="removeNumericFilter(${index})">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="filter-card-body">
                <div class="numeric-filter-stats">
                    <span class="numeric-filter-stat">
                        <span class="numeric-filter-stat-label">Range:</span>
                        ${colInfo.min} - ${colInfo.max}
                    </span>
                    ${colInfo.null_percent > 0 ? `
                    <span class="numeric-filter-stat">
                        <span class="numeric-filter-stat-label">Nulls:</span>
                        ${colInfo.null_percent}%
                    </span>
                    ` : ''}
                </div>

                <div class="numeric-filter-type">
                    <label>
                        <input type="radio" name="numericType_${index}" value="range"
                               ${filter.type === 'range' ? 'checked' : ''}
                               onchange="setNumericFilterType(${index}, 'range')">
                        Range
                    </label>
                    <label>
                        <input type="radio" name="numericType_${index}" value="equals"
                               ${filter.type === 'equals' ? 'checked' : ''}
                               onchange="setNumericFilterType(${index}, 'equals')">
                        Equals
                    </label>
                    <label>
                        <input type="radio" name="numericType_${index}" value="not_equals"
                               ${filter.type === 'not_equals' ? 'checked' : ''}
                               onchange="setNumericFilterType(${index}, 'not_equals')">
                        Not equals
                    </label>
                </div>

                <div class="numeric-filter-inputs">
                    ${isRange ? `
                        <div class="numeric-filter-input-group">
                            <label class="numeric-filter-input-label">Min</label>
                            <input type="number" class="numeric-filter-input"
                                   value="${filter.min !== null ? filter.min : ''}"
                                   placeholder="${colInfo.min}"
                                   onchange="setNumericFilterValue(${index}, 'min', this.value)">
                        </div>
                        <div class="numeric-filter-input-group">
                            <label class="numeric-filter-input-label">Max</label>
                            <input type="number" class="numeric-filter-input"
                                   value="${filter.max !== null ? filter.max : ''}"
                                   placeholder="${colInfo.max}"
                                   onchange="setNumericFilterValue(${index}, 'max', this.value)">
                        </div>
                    ` : `
                        <div class="numeric-filter-input-group">
                            <label class="numeric-filter-input-label">Value</label>
                            <input type="number" class="numeric-filter-input"
                                   value="${filter.value !== null ? filter.value : ''}"
                                   onchange="setNumericFilterValue(${index}, 'value', this.value)">
                        </div>
                    `}
                </div>

                ${colInfo.null_count > 0 ? `
                <div class="numeric-filter-null-handling">
                    <label>
                        <input type="radio" name="numericNulls_${index}" value="include"
                               ${filter.includeNulls ? 'checked' : ''}
                               onchange="setNumericNullHandling(${index}, true)">
                        Include NULLs
                    </label>
                    <label>
                        <input type="radio" name="numericNulls_${index}" value="exclude"
                               ${!filter.includeNulls ? 'checked' : ''}
                               onchange="setNumericNullHandling(${index}, false)">
                        Exclude NULLs
                    </label>
                </div>
                ` : ''}
            </div>
        </div>
    `;
}

function setNumericFilterType(index, type) {
    productFiltersState.pending.numericFilters[index].type = type;
    renderNumericFilters();
}

function setNumericFilterValue(index, field, value) {
    const filter = productFiltersState.pending.numericFilters[index];
    filter[field] = value === '' ? null : parseFloat(value);
}

function setNumericNullHandling(index, includeNulls) {
    productFiltersState.pending.numericFilters[index].includeNulls = includeNulls;
}

function removeNumericFilter(index) {
    productFiltersState.pending.numericFilters.splice(index, 1);
    renderNumericFilters();
    updateProductFilterBadges();
}

// --- Product Filter Badges ---
function updateProductFilterBadges() {
    const pending = productFiltersState.pending;

    // Top Products badge
    const topBadge = document.getElementById('topProductsBadge');
    if (pending.topRevenue.enabled) {
        topBadge.textContent = `${pending.topRevenue.thresholdPercent}%`;
        topBadge.classList.remove('inactive');
    } else {
        topBadge.textContent = 'Disabled';
        topBadge.classList.add('inactive');
    }

    // Category Filters badge
    const catBadge = document.getElementById('categoryFiltersBadge');
    const catCount = pending.categoryFilters.length;
    catBadge.textContent = `${catCount} filter${catCount !== 1 ? 's' : ''}`;
    if (catCount > 0) {
        catBadge.classList.remove('inactive');
    } else {
        catBadge.classList.add('inactive');
    }

    // Numeric Filters badge
    const numBadge = document.getElementById('numericFiltersBadge');
    const numCount = pending.numericFilters.length;
    numBadge.textContent = `${numCount} filter${numCount !== 1 ? 's' : ''}`;
    if (numCount > 0) {
        numBadge.classList.remove('inactive');
    } else {
        numBadge.classList.add('inactive');
    }

    // Products sub-chapter status
    updateProductsFilterStatus();
}

// --- Reset and Refresh ---
function resetProductFilters() {
    // Copy committed state back to pending
    productFiltersState.pending = JSON.parse(JSON.stringify(productFiltersState.committed));

    // Re-render UI
    const enableCheckbox = document.getElementById('enableTopProducts');
    enableCheckbox.checked = productFiltersState.pending.topRevenue.enabled;
    toggleTopProductsFilter();

    renderCategoryFilters();
    renderNumericFilters();
    updateProductFilterBadges();

    showNotification('Product filters reset to last saved state', 'info');
}

async function refreshProductFilters() {
    // Commit pending state
    productFiltersState.committed = JSON.parse(JSON.stringify(productFiltersState.pending));

    // Check if there are any filters after commit
    const committed = productFiltersState.committed;
    const hasAnyFilters = committed.topRevenue.enabled ||
                          committed.categoryFilters.length > 0 ||
                          committed.numericFilters.length > 0 ||
                          committed.dateFilters.length > 0;

    // Mark filters as applied only if there are actual filters
    // If all filters were deleted, reset the applied flag
    productFiltersApplied = hasAnyFilters;

    // Update header status badge
    updateProductsFilterStatus();

    // Update all dropdowns to exclude committed columns (cross-sub-chapter exclusion)
    populateFilterColumnDropdowns();

    // Build the product_filter object for the API
    const productFilter = buildProductFilterForApi();

    // Update wizardData.filters
    wizardData.filters = wizardData.filters || {};
    wizardData.filters.product_filter = productFilter;

    // Call the dataset stats API
    await updateDatasetSummary();

    // Update button state AFTER commit - this clears the "unapplied changes" indicator
    // since pending now equals committed
    updateProductsRefreshButtonState();

    // Re-validate step 4 to enable/disable Save button
    validateCurrentStep();
}

function buildProductFilterForApi() {
    const pending = productFiltersState.pending;
    const result = {};

    // Top revenue filter
    if (pending.topRevenue.enabled) {
        result.top_revenue = {
            enabled: true,
            product_column: pending.topRevenue.productColumn,
            revenue_column: pending.topRevenue.revenueColumn,
            threshold_percent: pending.topRevenue.thresholdPercent
        };
    }

    // Aggregation filters (transaction count, total revenue)
    if (pending.aggregationFilters.length > 0) {
        result.aggregation_filters = pending.aggregationFilters.map(f => ({
            type: f.type,
            product_column: f.productColumn,
            amount_column: f.amountColumn,
            filter_type: f.filterType,
            value: f.value,
            min: f.min,
            max: f.max
        }));
    }

    // Category filters
    if (pending.categoryFilters.length > 0) {
        result.category_filters = pending.categoryFilters
            .filter(f => f.values.length > 0)
            .map(f => ({
                column: f.column,
                mode: f.mode,
                values: f.values
            }));
    }

    // Numeric filters
    if (pending.numericFilters.length > 0) {
        result.numeric_filters = pending.numericFilters
            .filter(f => f.min !== null || f.max !== null || f.value !== null)
            .map(f => ({
                column: f.column,
                type: f.type,
                min: f.min,
                max: f.max,
                value: f.value,
                include_nulls: f.includeNulls
            }));
    }

    return result;
}

function buildCustomerFilterForApi() {
    const committed = customerFiltersState.committed;
    const result = {};

    // Top revenue filter
    if (committed.topRevenue.enabled) {
        result.top_revenue = {
            enabled: true,
            customer_column: committed.topRevenue.customerColumn,
            revenue_column: committed.topRevenue.revenueColumn,
            percent: committed.topRevenue.thresholdPercent
        };
    }

    // Aggregation filters
    if (committed.aggregationFilters.length > 0) {
        result.aggregation_filters = committed.aggregationFilters.map(f => ({
            type: f.type,
            customer_column: f.customerColumn,
            amount_column: f.amountColumn,
            filter_type: f.filterType,
            value: f.value,
            min: f.min,
            max: f.max
        }));
    }

    // Category filters
    if (committed.categoryFilters.length > 0) {
        result.category_filters = committed.categoryFilters
            .filter(f => f.values && f.values.length > 0)
            .map(f => ({
                column: f.column,
                mode: f.mode,
                values: f.values
            }));
    }

    // Numeric filters
    if (committed.numericFilters.length > 0) {
        result.numeric_filters = committed.numericFilters
            .filter(f => f.min !== null || f.max !== null || f.value !== null)
            .map(f => ({
                column: f.column,
                filter_type: f.type,
                min: f.min,
                max: f.max,
                value: f.value,
                include_nulls: f.includeNulls
            }));
    }

    // Date filters
    if (committed.dateFilters.length > 0) {
        result.date_filters = committed.dateFilters.map(f => ({
            column: f.column,
            date_type: f.dateType,
            relative_option: f.relativeOption,
            start_date: f.startDate,
            end_date: f.endDate,
            include_nulls: f.includeNulls
        }));
    }

    return result;
}

// --- Column Dropdown Population ---
function populateFilterColumnDropdowns() {
    // Get all selected columns from schema builder
    const allColumns = [];
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            allColumns.push({
                table: shortTable,
                column: col,
                fullName: `${shortTable}.${col}`
            });
        });
    });

    // Populate timestamp column dropdown (only DATE/TIMESTAMP type columns)
    // DATE columns can only be used ONCE anywhere
    const timestampSelect = document.getElementById('timestampColumn');
    const currentTimestamp = timestampSelect?.value;  // Preserve current selection
    timestampSelect.innerHTML = '<option value="">Select column...</option>';

    // Get column type info from analysis cache
    const colAnalysis = productFiltersState.columnAnalysis || customerFiltersState.columnAnalysis || {};
    const dateTypes = ['DATE', 'DATETIME', 'TIMESTAMP', 'TIME'];

    allColumns.forEach(c => {
        // Only show DATE/TIMESTAMP type columns
        const colInfo = colAnalysis[c.fullName];
        const colType = colInfo?.type?.toUpperCase() || '';
        if (!dateTypes.includes(colType)) {
            return;  // Skip non-date columns
        }

        // Exclude columns already used as DATE filters in other sub-chapters
        // But allow the currently committed timestamp column (so it shows as selected)
        if (isColumnCommittedInAnyFilter(c.fullName, 'date') && c.fullName !== committedDatesFilter.timestampColumn) {
            return;
        }

        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        // Restore previous selection if it exists
        if (c.fullName === currentTimestamp) option.selected = true;
        timestampSelect.appendChild(option);
    });

    // Populate product ID and revenue column dropdowns
    populateProductFilterDropdowns(allColumns);

    // Reset analysis state when columns change
    resetProductAnalysis();

    // Note: Don't reset dataset summary here - fetchDatasetStats() is called
    // from nextStep() when entering Step 4 to load initial unfiltered stats

    // Update button states (disable buttons until timestamp selected)
    updateHistoryButtonStates();
}

function populateProductFilterDropdowns(allColumns = null) {
    if (!allColumns) {
        allColumns = [];
        Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
            const shortTable = table.replace('raw_data.', '');
            cols.forEach(col => {
                allColumns.push({
                    table: shortTable,
                    column: col,
                    fullName: `${shortTable}.${col}`
                });
            });
        });
    }

    // Get the timestamp column that's currently selected/committed in Dates
    const timestampCol = document.getElementById('timestampColumn')?.value;

    // Populate product ID dropdown (grouping column - only exclude date columns)
    // STRING grouping columns are reusable, so we only check for date exclusion
    const productSelect = document.getElementById('productIdColumn');
    const currentProduct = productSelect?.value;
    productSelect.innerHTML = '<option value="">Select column...</option>';
    allColumns.forEach(c => {
        // Exclude timestamp column (DATE type used in Dates sub-chapter)
        if (timestampCol && c.fullName === timestampCol) return;
        // Exclude columns used as date filters (DATE columns can only be used once)
        if (isColumnCommittedInAnyFilter(c.fullName, 'date')) return;

        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        if (c.fullName === currentProduct) option.selected = true;
        productSelect.appendChild(option);
    });

    // Populate revenue column dropdown (aggregation column - ONLY NUMERIC types)
    // INTEGER/FLOAT aggregation columns are reusable across sub-chapters
    const revenueSelect = document.getElementById('revenueColumn');
    const currentRevenue = revenueSelect?.value;
    const productCol = productSelect?.value;

    // Get column type info from analysis cache
    const colAnalysis = productFiltersState.columnAnalysis || customerFiltersState.columnAnalysis || {};
    const numericTypes = ['INTEGER', 'INT64', 'FLOAT', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC', 'DECIMAL'];

    revenueSelect.innerHTML = '<option value="">Select column...</option>';
    allColumns.forEach(c => {
        // Only show numeric columns for revenue
        const colInfo = colAnalysis[c.fullName];
        const colType = colInfo?.type?.toUpperCase() || '';
        if (!numericTypes.includes(colType)) return;  // Skip non-numeric columns

        // Exclude the selected product column (can't use same column for both)
        if (productCol && c.fullName === productCol) return;
        // Exclude timestamp column
        if (timestampCol && c.fullName === timestampCol) return;
        // Exclude columns used as date filters
        if (isColumnCommittedInAnyFilter(c.fullName, 'date')) return;
        // Note: We do NOT exclude aggregation columns - they are reusable!

        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        if (c.fullName === currentRevenue) option.selected = true;
        revenueSelect.appendChild(option);
    });
}

// --- History Sub-chapter ---

// Track active filter mode: 'rolling' or 'startDate'
let historyFilterMode = 'rolling';
let activeFilterPopup = null;

function toggleFilterPopup(popupName) {
    const popup = document.getElementById(`${popupName}Popup`);
    const button = document.getElementById(`${popupName}Btn`);

    // Don't open popup if button is disabled
    if (button && button.disabled) {
        return;
    }

    // Close any other open popups
    document.querySelectorAll('.filter-popup.show').forEach(p => {
        if (p.id !== `${popupName}Popup`) {
            p.classList.remove('show');
        }
    });
    document.querySelectorAll('.filter-button.active').forEach(b => {
        if (b.id !== `${popupName}Btn`) {
            b.classList.remove('active');
        }
    });

    // Toggle current popup
    if (popup.classList.contains('show')) {
        popup.classList.remove('show');
        button.classList.remove('active');
        activeFilterPopup = null;
    } else {
        // Position popup below the button using fixed positioning
        const buttonRect = button.getBoundingClientRect();
        popup.style.top = (buttonRect.bottom + 8) + 'px';
        popup.style.left = buttonRect.left + 'px';

        popup.classList.add('show');
        button.classList.add('active');
        activeFilterPopup = popupName;

        // If opening start date popup, set default to today
        if (popupName === 'startDate') {
            const startDateInput = document.getElementById('startDateInput');
            if (!startDateInput.value) {
                startDateInput.value = new Date().toISOString().split('T')[0];
            }
        }
    }
}

// Close popups when clicking outside
document.addEventListener('click', function(e) {
    if (activeFilterPopup && !e.target.closest('.filter-button-wrapper')) {
        const popup = document.getElementById(`${activeFilterPopup}Popup`);
        const button = document.getElementById(`${activeFilterPopup}Btn`);
        if (popup) popup.classList.remove('show');
        if (button) button.classList.remove('active');
        activeFilterPopup = null;
    }
});

// Close a specific filter popup
function closeFilterPopup(popupName) {
    const popup = document.getElementById(`${popupName}Popup`);
    const button = document.getElementById(`${popupName}Btn`);
    if (popup) popup.classList.remove('show');
    if (button) button.classList.remove('active');
    if (activeFilterPopup === popupName) {
        activeFilterPopup = null;
    }
}

// Apply rolling window and close popup
function applyRollingWindow() {
    onRollingDaysChange();
    closeFilterPopup('rollingWindow');
}

// Track if date filters have been applied (via Refresh Dataset click)
let dateFiltersApplied = false;

// Dates Filter State Management (pending/committed model like Products and Customers)
let datesFilterState = {
    pending: {
        timestampColumn: null,
        mode: 'rolling',  // 'rolling' or 'startDate'
        rollingDays: 30,
        startDate: null
    },
    committed: {
        timestampColumn: null,
        mode: 'rolling',
        rollingDays: 30,
        startDate: null
    }
};

// Get current pending dates filter state from UI elements
function getDatesFilterPendingState() {
    return {
        timestampColumn: document.getElementById('timestampColumn')?.value || null,
        mode: historyFilterMode,
        rollingDays: parseInt(document.getElementById('rollingDays')?.value) || 30,
        startDate: document.getElementById('startDateInput')?.value || null
    };
}

// Update Dates Refresh Dataset button state
function updateDatesRefreshButtonState() {
    const refreshBtn = document.getElementById('refreshDatasetBtn');
    if (!refreshBtn) return;

    // Get current pending state from UI
    const pendingState = getDatesFilterPendingState();

    // Enable button if pending state differs from committed state
    const pendingJson = JSON.stringify(pendingState);
    const committedJson = JSON.stringify(datesFilterState.committed);
    const hasChanges = pendingJson !== committedJson;

    // Also need a timestamp column selected to enable
    const hasTimestamp = !!pendingState.timestampColumn;

    const shouldEnable = hasTimestamp && hasChanges;

    refreshBtn.disabled = !shouldEnable;
    refreshBtn.classList.toggle('filter-button-disabled', !shouldEnable);

    // Update "unapplied changes" indicator
    updateDatesUnappliedIndicator(hasChanges && dateFiltersApplied);
}

function updateDatesUnappliedIndicator(hasChanges) {
    const summaryDiv = document.getElementById('datesFilterSummary');
    if (!summaryDiv) return;

    // Remove existing indicator if present
    const existingIndicator = summaryDiv.querySelector('.unapplied-changes-indicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }

    // Add indicator if there are unapplied changes
    if (hasChanges) {
        const indicator = document.createElement('div');
        indicator.className = 'unapplied-changes-indicator';
        indicator.innerHTML = '<i class="fas fa-exclamation-circle"></i> Unapplied changes - click "Refresh Dataset" to apply';
        summaryDiv.appendChild(indicator);
    }
}

// Update the Dates sub-chapter header badge (shows "1 filter applied" after Refresh)
function updateDatesFilterStatus() {
    const statusEl = document.getElementById('datesFilterStatus');

    // Only show badge if filters have been applied via Refresh Dataset
    if (!dateFiltersApplied) {
        statusEl.textContent = '';
        return;
    }

    const timestampCol = document.getElementById('timestampColumn')?.value;
    if (!timestampCol) {
        statusEl.textContent = '';
        return;
    }

    statusEl.textContent = '1 filter applied';
}

// Update the Dates summary line (shows pending filter details with delete button)
function updateDatesFilterSummary() {
    const summaryDiv = document.getElementById('datesFilterSummary');
    const summaryItems = document.getElementById('datesFilterSummaryItems');

    const timestampCol = document.getElementById('timestampColumn')?.value;
    const rollingDays = document.getElementById('rollingDays')?.value || 30;
    const startDate = document.getElementById('startDateInput')?.value;

    if (!timestampCol) {
        summaryItems.innerHTML = '<span class="filter-summary-empty">No filters selected</span>';
        summaryDiv.classList.remove('has-pending');
        return;
    }

    // Build filter description with unified format
    const colName = timestampCol.split('.').pop();
    let condition = '';

    if (historyFilterMode === 'startDate' && startDate) {
        condition = `from ${startDate}`;
    } else {
        condition = `last ${rollingDays} days`;
    }

    // Unified format: "Date filter: column_name, condition"
    const description = `Date filter: ${colName}, ${condition}`;

    // Render with same structure as Products
    summaryItems.innerHTML = `
        <div class="filter-summary-item">
            <span class="filter-summary-item-number">Filter #1:</span>
            <span class="filter-summary-item-desc">${description}</span>
            <button type="button" class="filter-summary-item-delete" onclick="deleteDatesFilter()" title="Remove filter">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `;
    summaryDiv.classList.add('has-pending');
}

// Delete the Dates filter
function deleteDatesFilter() {
    // Clear the timestamp column selection
    const timestampSelect = document.getElementById('timestampColumn');
    if (timestampSelect) {
        timestampSelect.value = '';
    }

    // Reset rolling days and start date to defaults
    const rollingDaysInput = document.getElementById('rollingDays');
    if (rollingDaysInput) {
        rollingDaysInput.value = '30';
    }
    const startDateInput = document.getElementById('startDateInput');
    if (startDateInput) {
        startDateInput.value = '';
    }
    historyFilterMode = 'rolling';

    // Update UI
    updateDatesFilterSummary();
    updateHistoryButtonStates();  // This will call updateDatesRefreshButtonState()

    // Re-populate product dropdowns (timestamp column is now available)
    populateProductFilterDropdowns();

    validateCurrentStep();
}

// Reset the applied status when filters are changed (user needs to click Refresh again)
function resetDateFiltersApplied() {
    dateFiltersApplied = false;
    // Clear the committed timestamp column (user changed selection, needs to Refresh again)
    committedDatesFilter.timestampColumn = null;
    document.getElementById('datesFilterStatus').textContent = '';
}

function onTimestampColumnChange() {
    updateDatesFilterSummary();
    // Update dependent button states (this will handle the Refresh button state)
    updateHistoryButtonStates();
    validateCurrentStep();
}

function updateHistoryButtonStates() {
    const timestampCol = document.getElementById('timestampColumn')?.value;
    const hasTimestamp = !!timestampCol;

    // Enable/disable dependent buttons
    const rollingWindowBtn = document.getElementById('rollingWindowBtn');
    const startDateBtn = document.getElementById('startDateBtn');

    if (rollingWindowBtn) {
        rollingWindowBtn.disabled = !hasTimestamp;
        rollingWindowBtn.classList.toggle('filter-button-disabled', !hasTimestamp);
    }
    if (startDateBtn) {
        startDateBtn.disabled = !hasTimestamp;
        startDateBtn.classList.toggle('filter-button-disabled', !hasTimestamp);
    }

    // Update Refresh Dataset button using the new pending/committed state logic
    updateDatesRefreshButtonState();
}

function onRollingDaysChange() {
    historyFilterMode = 'rolling';
    updateDatesFilterSummary();
    updateDatesRefreshButtonState();
    // Reset product analysis when date range changes
    resetProductAnalysis();
    validateCurrentStep();
}

function onStartDateChange() {
    historyFilterMode = 'startDate';
    updateDatesFilterSummary();
    updateDatesRefreshButtonState();
    // Reset product analysis when date range changes
    resetProductAnalysis();
    validateCurrentStep();
}

function refreshDatasetHistory() {
    const timestampCol = document.getElementById('timestampColumn')?.value;
    const rollingDays = document.getElementById('rollingDays')?.value || 30;
    const startDate = document.getElementById('startDateInput')?.value;

    if (!timestampCol) {
        alert('Please select a timestamp column first');
        return;
    }

    // Commit the current pending state
    datesFilterState.committed = {
        timestampColumn: timestampCol,
        mode: historyFilterMode,
        rollingDays: parseInt(rollingDays) || 30,
        startDate: startDate || null
    };

    // Also update the legacy committedDatesFilter for cross-sub-chapter exclusion
    committedDatesFilter.timestampColumn = timestampCol;

    // Mark filters as applied and update header status
    dateFiltersApplied = true;
    updateDatesFilterStatus();

    // Save to wizardData.filters for persistence
    wizardData.filters = wizardData.filters || {};
    wizardData.filters.history = {
        timestamp_column: timestampCol,
        rolling_days: parseInt(rollingDays) || 30,
        start_date: startDate || null
    };

    // Update all dropdowns to exclude the committed timestamp column
    populateProductFilterDropdowns();

    // Update Dataset Summary panel
    updateDatasetSummary();

    // Update button state (should become disabled since pending = committed)
    updateDatesRefreshButtonState();

    // Re-validate step 4 to enable/disable Save button
    validateCurrentStep();

    console.log('Refresh Dataset clicked:', {
        mode: historyFilterMode,
        timestampColumn: timestampCol,
        rollingDays: rollingDays,
        startDate: startDate
    });
}

// Store the latest dataset stats
let datasetStatsData = null;

async function fetchDatasetStats(withFilters = false) {
    /**
     * Fetch dataset statistics from the API.
     *
     * @param {boolean} withFilters - If true, include current filter settings.
     *                                If false, get unfiltered stats.
     */
    showDatasetStatsLoading();

    try {
        // Build the request payload
        const payload = {
            primary_table: wizardData.primaryTable,
            selected_columns: wizardData.selectedColumns || {},
            secondary_tables: wizardData.secondaryTables || [],
            join_config: wizardData.joinConfig || {}
        };

        // Add filters if requested - uses COMMITTED state from all sub-chapters
        // Priority order: Dates -> Customers -> Products
        if (withFilters) {
            const filters = {};

            // ===========================================
            // 1. DATE FILTERS (from committed state)
            // ===========================================
            if (dateFiltersApplied) {
                const datesCommitted = datesFilterState.committed;
                if (datesCommitted.timestampColumn) {
                    filters.timestamp_column = datesCommitted.timestampColumn;

                    if (datesCommitted.mode === 'rolling') {
                        filters.date_filter = { type: 'rolling', days: datesCommitted.rollingDays };
                    } else if (datesCommitted.mode === 'startDate' && datesCommitted.startDate) {
                        filters.date_filter = { type: 'fixed', start_date: datesCommitted.startDate };
                    }
                }
            }

            // ===========================================
            // 2. CUSTOMER FILTERS (from committed state)
            // ===========================================
            if (customerFiltersApplied) {
                const customerCommitted = customerFiltersState.committed;
                const customerFilter = {};

                // Top customers by revenue
                if (customerCommitted.topRevenue.enabled) {
                    customerFilter.top_revenue = {
                        customer_column: customerCommitted.topRevenue.customerColumn,
                        revenue_column: customerCommitted.topRevenue.revenueColumn,
                        percent: customerCommitted.topRevenue.thresholdPercent
                    };
                }

                // Aggregation filters (transaction count, spending)
                if (customerCommitted.aggregationFilters.length > 0) {
                    customerFilter.aggregation_filters = customerCommitted.aggregationFilters.map(f => ({
                        type: f.type,
                        customer_column: f.customerColumn,
                        amount_column: f.amountColumn || null,
                        filter_type: f.filterType,
                        value: f.value,
                        min: f.min,
                        max: f.max
                    }));
                }

                // Category filters
                if (customerCommitted.categoryFilters.length > 0) {
                    customerFilter.category_filters = customerCommitted.categoryFilters.map(f => ({
                        column: f.column,
                        mode: f.mode,
                        values: f.values
                    }));
                }

                // Numeric filters
                if (customerCommitted.numericFilters.length > 0) {
                    customerFilter.numeric_filters = customerCommitted.numericFilters.map(f => ({
                        column: f.column,
                        filter_type: f.filterType,
                        min: f.min,
                        max: f.max,
                        value: f.value,
                        include_nulls: f.includeNulls
                    }));
                }

                // Date filters (within Customers sub-chapter)
                if (customerCommitted.dateFilters.length > 0) {
                    customerFilter.date_filters = customerCommitted.dateFilters.map(f => ({
                        column: f.column,
                        date_type: f.dateType,
                        relative_option: f.relativeOption,
                        start_date: f.startDate,
                        end_date: f.endDate,
                        include_nulls: f.includeNulls
                    }));
                }

                // Only add customer_filter if there's at least one filter
                if (Object.keys(customerFilter).length > 0) {
                    filters.customer_filter = customerFilter;
                }
            }

            // ===========================================
            // 3. PRODUCT FILTERS (from committed state)
            // ===========================================
            if (productFiltersApplied) {
                const productCommitted = productFiltersState.committed;
                const productFilter = {};

                // Top products by revenue
                if (productCommitted.topRevenue.enabled) {
                    productFilter.top_revenue = {
                        enabled: true,
                        product_column: productCommitted.topRevenue.productColumn,
                        revenue_column: productCommitted.topRevenue.revenueColumn,
                        threshold_percent: productCommitted.topRevenue.thresholdPercent
                    };
                }

                // Aggregation filters (transaction count, total revenue)
                if (productCommitted.aggregationFilters.length > 0) {
                    productFilter.aggregation_filters = productCommitted.aggregationFilters.map(f => ({
                        type: f.type,
                        product_column: f.productColumn,
                        amount_column: f.amountColumn,
                        filter_type: f.filterType,
                        value: f.value,
                        min: f.min,
                        max: f.max
                    }));
                }

                // Category filters
                if (productCommitted.categoryFilters.length > 0) {
                    productFilter.category_filters = productCommitted.categoryFilters
                        .filter(f => f.values && f.values.length > 0)
                        .map(f => ({
                            column: f.column,
                            mode: f.mode,
                            values: f.values
                        }));
                }

                // Numeric filters
                if (productCommitted.numericFilters.length > 0) {
                    productFilter.numeric_filters = productCommitted.numericFilters
                        .filter(f => f.min !== null || f.max !== null || f.value !== null)
                        .map(f => ({
                            column: f.column,
                            type: f.type,
                            min: f.min,
                            max: f.max,
                            value: f.value,
                            include_nulls: f.includeNulls
                        }));
                }

                // Date filters (within Products sub-chapter)
                if (productCommitted.dateFilters && productCommitted.dateFilters.length > 0) {
                    productFilter.date_filters = productCommitted.dateFilters.map(f => ({
                        column: f.column,
                        date_type: f.dateType || f.filterType,
                        relative_option: f.relativeOption,
                        start_date: f.startDate,
                        end_date: f.endDate,
                        include_nulls: f.includeNulls
                    }));
                }

                // Only add product_filter if there's at least one filter
                if (Object.keys(productFilter).length > 0) {
                    filters.product_filter = productFilter;
                }
            }

            if (Object.keys(filters).length > 0) {
                payload.filters = filters;
            }

            // Debug log to verify all filters are included
            console.log('fetchDatasetStats - Committed filters from all sub-chapters:', {
                dateFiltersApplied,
                customerFiltersApplied,
                productFiltersApplied,
                filters: filters
            });
        }

        const response = await fetch(`/api/models/${modelId}/datasets/stats/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(payload)
        });

        const data = await response.json();

        if (data.status === 'success') {
            datasetStatsData = data;
            populateDatasetSummary(data);
        } else {
            showDatasetStatsError(data.message || 'Failed to fetch dataset stats');
        }

    } catch (error) {
        console.error('Error fetching dataset stats:', error);
        showDatasetStatsError(error.message);
    }
}

function showDatasetStatsLoading() {
    document.getElementById('datasetSummaryEmpty').classList.remove('hidden');
    document.getElementById('datasetSummaryData').classList.add('hidden');

    // Show loading state
    const emptyEl = document.getElementById('datasetSummaryEmpty');
    emptyEl.innerHTML = `
        <i class="fas fa-spinner fa-spin"></i>
        <span>Loading dataset statistics...</span>
    `;

    // Clear total rows badge
    document.getElementById('summaryTotalRowsBadge').textContent = '';
}

function showDatasetStatsError(message) {
    document.getElementById('datasetSummaryEmpty').classList.remove('hidden');
    document.getElementById('datasetSummaryData').classList.add('hidden');

    const emptyEl = document.getElementById('datasetSummaryEmpty');
    emptyEl.innerHTML = `
        <i class="fas fa-exclamation-triangle" style="color: #dc2626;"></i>
        <span style="color: #dc2626;">Error: ${message}</span>
    `;

    // Clear total rows badge
    document.getElementById('summaryTotalRowsBadge').textContent = '';
}

function populateDatasetSummary(data) {
    document.getElementById('datasetSummaryEmpty').classList.add('hidden');
    document.getElementById('datasetSummaryData').classList.remove('hidden');

    const filters = data.filters_applied || {};
    const summary = data.summary || {};
    const columnStats = data.column_stats || {};

    // --- Total Rows Badge in Header ---
    const totalRowsBadge = document.getElementById('summaryTotalRowsBadge');
    if (summary.total_rows) {
        totalRowsBadge.textContent = `${summary.total_rows.toLocaleString()} rows`;
    } else {
        totalRowsBadge.textContent = '';
    }

    // --- Filter Badges ---
    const datesBadge = document.getElementById('filterBadgeDates');
    const customersBadge = document.getElementById('filterBadgeCustomers');
    const productsBadge = document.getElementById('filterBadgeProducts');

    // Dates filter
    if (filters.dates?.type === 'rolling') {
        document.getElementById('filterBadgeDatesText').textContent = `Last ${filters.dates.days} days`;
        datesBadge.classList.add('filter-active');
    } else if (filters.dates?.type === 'fixed') {
        document.getElementById('filterBadgeDatesText').textContent = `From ${filters.dates.start_date}`;
        datesBadge.classList.add('filter-active');
    } else {
        document.getElementById('filterBadgeDatesText').textContent = 'All dates';
        datesBadge.classList.remove('filter-active');
    }

    // Customers filter
    if (filters.customers?.type === 'multiple') {
        // New format with multiple filters
        const count = filters.customers.count || filters.customers.filters?.length || 0;
        if (count === 1) {
            // Show specific filter type for single filter
            const filter = filters.customers.filters[0];
            if (filter.type === 'top_revenue') {
                document.getElementById('filterBadgeCustomersText').textContent = `Top ${filter.percent}% revenue`;
            } else if (filter.type === 'transaction_count') {
                const desc = filter.filter_type === 'greater_than' ? `> ${filter.value}` :
                             filter.filter_type === 'less_than' ? `< ${filter.value}` :
                             `${filter.min}-${filter.max}`;
                document.getElementById('filterBadgeCustomersText').textContent = `${desc} transactions`;
            } else if (filter.type === 'spending') {
                const desc = filter.filter_type === 'greater_than' ? `> $${filter.value}` :
                             filter.filter_type === 'less_than' ? `< $${filter.value}` :
                             `$${filter.min}-$${filter.max}`;
                document.getElementById('filterBadgeCustomersText').textContent = `Spending ${desc}`;
            } else if (filter.type === 'min_transactions') {
                document.getElementById('filterBadgeCustomersText').textContent = `Min ${filter.value} transactions`;
            } else {
                document.getElementById('filterBadgeCustomersText').textContent = '1 filter';
            }
        } else {
            document.getElementById('filterBadgeCustomersText').textContent = `${count} filters`;
        }
        customersBadge.classList.add('filter-active');
    } else if (filters.customers?.type === 'min_transactions') {
        // Legacy format
        document.getElementById('filterBadgeCustomersText').textContent = `Min ${filters.customers.value} transactions`;
        customersBadge.classList.add('filter-active');
    } else {
        document.getElementById('filterBadgeCustomersText').textContent = 'All customers';
        customersBadge.classList.remove('filter-active');
    }

    // Products filter
    if (filters.products?.type === 'multiple') {
        // New format with multiple filters
        const count = filters.products.count || filters.products.filters?.length || 0;
        if (count === 1) {
            const filter = filters.products.filters[0];
            if (filter.type === 'top_revenue') {
                document.getElementById('filterBadgeProductsText').textContent = `Top ${filter.percent}% revenue`;
            } else {
                document.getElementById('filterBadgeProductsText').textContent = '1 filter';
            }
        } else {
            document.getElementById('filterBadgeProductsText').textContent = `${count} filters`;
        }
        productsBadge.classList.add('filter-active');
    } else if (filters.products?.type === 'top_revenue') {
        // Legacy format
        document.getElementById('filterBadgeProductsText').textContent = `Top ${filters.products.percent}% revenue`;
        productsBadge.classList.add('filter-active');
    } else {
        document.getElementById('filterBadgeProductsText').textContent = 'All products';
        productsBadge.classList.remove('filter-active');
    }

    // --- Column Stats Table ---
    const tableBody = document.getElementById('columnStatsTableBody');
    tableBody.innerHTML = '';

    for (const [columnName, stats] of Object.entries(columnStats)) {
        const row = document.createElement('tr');

        // Column name cell
        const nameCell = document.createElement('td');
        nameCell.innerHTML = `<span class="column-name">${columnName}</span>`;
        row.appendChild(nameCell);

        // Data type cell
        const typeCell = document.createElement('td');
        typeCell.innerHTML = `<span class="column-type">${stats.type}</span>`;
        row.appendChild(typeCell);

        // Stats cell
        const statsCell = document.createElement('td');
        statsCell.innerHTML = formatColumnStats(stats);
        row.appendChild(statsCell);

        tableBody.appendChild(row);
    }
}

function formatColumnStats(stats) {
    const items = [];

    // Handle different column types
    if (stats.type === 'STRING' || stats.type === 'BYTES') {
        if (stats.unique_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">Unique:</span> <span class="stat-value">${stats.unique_count.toLocaleString()}</span></span>`);
        }
    } else if (['INT64', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC', 'INTEGER', 'FLOAT'].includes(stats.type)) {
        if (stats.min !== undefined && stats.min !== null) {
            items.push(`<span class="stat-item"><span class="stat-label">Min:</span> <span class="stat-value">${formatNumber(stats.min)}</span></span>`);
        }
        if (stats.max !== undefined && stats.max !== null) {
            items.push(`<span class="stat-item"><span class="stat-label">Max:</span> <span class="stat-value">${formatNumber(stats.max)}</span></span>`);
        }
        if (stats.avg !== undefined && stats.avg !== null) {
            items.push(`<span class="stat-item"><span class="stat-label">Avg:</span> <span class="stat-value">${formatNumber(stats.avg)}</span></span>`);
        }
    } else if (['DATE', 'DATETIME', 'TIMESTAMP'].includes(stats.type)) {
        if (stats.min) {
            items.push(`<span class="stat-item"><span class="stat-label">Min:</span> <span class="stat-value">${stats.min}</span></span>`);
        }
        if (stats.max) {
            items.push(`<span class="stat-item"><span class="stat-label">Max:</span> <span class="stat-value">${stats.max}</span></span>`);
        }
        if (stats.unique_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">Unique:</span> <span class="stat-value">${stats.unique_count.toLocaleString()}</span></span>`);
        }
    } else if (stats.type === 'BOOL') {
        if (stats.true_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">True:</span> <span class="stat-value">${stats.true_count.toLocaleString()}</span></span>`);
        }
        if (stats.false_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">False:</span> <span class="stat-value">${stats.false_count.toLocaleString()}</span></span>`);
        }
    }

    // Add null count if present
    if (stats.null_count !== undefined && stats.null_count > 0) {
        items.push(`<span class="stat-item"><span class="stat-label">Nulls:</span> <span class="stat-value">${stats.null_count.toLocaleString()} (${stats.null_percent}%)</span></span>`);
    }

    return `<div class="column-stats-details">${items.join('')}</div>`;
}

function formatNumber(num) {
    if (num === null || num === undefined) return '-';
    if (Number.isInteger(num)) {
        return num.toLocaleString();
    }
    // For floats, show up to 2 decimal places
    return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
}

// Format column stats for the View detail modal (similar to formatColumnStats but returns plain text)
function formatDetailColumnStats(stats) {
    const items = [];

    if (stats.type === 'STRING' || stats.type === 'BYTES') {
        if (stats.unique_count !== undefined) {
            items.push(`Unique: ${stats.unique_count.toLocaleString()}`);
        }
    } else if (['INT64', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC', 'INTEGER', 'FLOAT'].includes(stats.type)) {
        if (stats.min !== undefined && stats.min !== null) {
            items.push(`Min: ${formatNumber(stats.min)}`);
        }
        if (stats.max !== undefined && stats.max !== null) {
            items.push(`Max: ${formatNumber(stats.max)}`);
        }
        if (stats.avg !== undefined && stats.avg !== null) {
            items.push(`Avg: ${formatNumber(stats.avg)}`);
        }
    } else if (['DATE', 'DATETIME', 'TIMESTAMP'].includes(stats.type)) {
        if (stats.min) {
            items.push(`Min: ${stats.min}`);
        }
        if (stats.max) {
            items.push(`Max: ${stats.max}`);
        }
        if (stats.unique_count !== undefined) {
            items.push(`Unique: ${stats.unique_count.toLocaleString()}`);
        }
    } else if (stats.type === 'BOOL') {
        if (stats.true_count !== undefined) {
            items.push(`True: ${stats.true_count.toLocaleString()}`);
        }
        if (stats.false_count !== undefined) {
            items.push(`False: ${stats.false_count.toLocaleString()}`);
        }
    }

    // Add null info if present
    if (stats.null_count !== undefined && stats.null_count > 0) {
        items.push(`Nulls: ${stats.null_count.toLocaleString()} (${stats.null_percent}%)`);
    }

    return items.join('  ') || '-';
}

function updateDatasetSummary() {
    // Wrapper function for backward compatibility
    // Now calls fetchDatasetStats with filters
    fetchDatasetStats(true);
}

function resetDatasetSummary() {
    // Reset to empty state with proper message
    datasetStatsData = null;
    const emptyEl = document.getElementById('datasetSummaryEmpty');
    emptyEl.innerHTML = `
        <i class="fas fa-info-circle"></i>
        <span>Click "Refresh Dataset" to see summary statistics</span>
    `;
    emptyEl.classList.remove('hidden');
    document.getElementById('datasetSummaryData').classList.add('hidden');
}

function updateHistorySummary() {
    // Summary removed from header tablet design - this function kept for compatibility
    // Could be used in the future to update a status indicator if needed
}

// --- Products Sub-chapter ---
function onProductColumnChange() {
    // Update revenue dropdown to exclude selected product column
    populateProductFilterDropdowns();
    updateAnalyzeButtonState();
    resetProductAnalysis();
    validateCurrentStep();
}

function onRevenueColumnChange() {
    updateAnalyzeButtonState();
    resetProductAnalysis();
    validateCurrentStep();
}

function updateAnalyzeButtonState() {
    const productCol = document.getElementById('productIdColumn')?.value;
    const revenueCol = document.getElementById('revenueColumn')?.value;
    const analyzeBtn = document.getElementById('analyzeProductsBtn');

    const isEnabled = productCol && revenueCol;
    analyzeBtn.disabled = !isEnabled;

    if (isEnabled) {
        analyzeBtn.classList.remove('filter-button-disabled');
    } else {
        analyzeBtn.classList.add('filter-button-disabled');
    }
}

function resetProductAnalysis() {
    productAnalysisData = null;

    const resultsEl = document.getElementById('productAnalysisResults');
    const errorEl = document.getElementById('productAnalysisError');
    if (resultsEl) resultsEl.classList.add('hidden');
    if (errorEl) errorEl.classList.add('hidden');

    // Summary element removed from tablet header design
    const productsSummary = document.getElementById('productsSummary');
    if (productsSummary) productsSummary.textContent = 'All products included';

    // Clear chart
    const svg = document.getElementById('revenueDistributionChart');
    if (svg) svg.innerHTML = '';

    validateCurrentStep();
}

async function analyzeProductRevenue() {
    const productCol = document.getElementById('productIdColumn')?.value;
    const revenueCol = document.getElementById('revenueColumn')?.value;
    const timestampCol = document.getElementById('timestampColumn')?.value;
    const rollingDays = parseInt(document.getElementById('rollingDays')?.value) || 30;

    if (!productCol || !revenueCol) {
        showProductAnalysisError('Please select both Product ID and Revenue columns');
        return;
    }

    const analyzeBtn = document.getElementById('analyzeProductsBtn');
    analyzeBtn.disabled = true;
    analyzeBtn.classList.add('filter-button-disabled');
    analyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Analyzing...</span>';

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/analyze-product-revenue/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                primary_table: wizardData.primaryTable,
                product_column: productCol,
                revenue_column: revenueCol,
                timestamp_column: timestampCol || null,
                rolling_days: timestampCol ? rollingDays : null
            })
        });

        const data = await response.json();

        if (data.status === 'success') {
            productAnalysisData = data;
            displayProductAnalysisResults(data);

            const resultsEl = document.getElementById('productAnalysisResults');
            const errorEl = document.getElementById('productAnalysisError');
            if (resultsEl) resultsEl.classList.remove('hidden');
            if (errorEl) errorEl.classList.add('hidden');

            // Update date range preview if available
            if (data.date_range) {
                const dateRangeEl = document.getElementById('dateRangePreview');
                const dateRangeTextEl = document.getElementById('dateRangePreviewText');
                if (dateRangeEl) dateRangeEl.classList.remove('hidden');
                if (dateRangeTextEl) {
                    dateRangeTextEl.textContent = `Data from ${data.date_range.start} to ${data.date_range.end}`;
                }
            }
        } else {
            showProductAnalysisError(data.message || 'Analysis failed');
        }
    } catch (error) {
        console.error('Error analyzing product revenue:', error);
        showProductAnalysisError('Failed to analyze product revenue');
    } finally {
        analyzeBtn.disabled = false;
        analyzeBtn.classList.remove('filter-button-disabled');
        analyzeBtn.innerHTML = '<i class="fas fa-sync-alt"></i><span>Analyze</span>';
        validateCurrentStep();
    }
}

function displayProductAnalysisResults(data) {
    // Update summary stats
    document.getElementById('totalProductsCount').textContent = data.total_products.toLocaleString();

    const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;
    updateProductSelectionForThreshold(threshold, data);

    // Draw the chart after a small delay to ensure container is visible and has dimensions
    setTimeout(() => {
        drawRevenueDistributionChart(data.distribution, threshold);
    }, 50);

    // Update products summary
    updateProductsSummary();
}

function updateProductSelectionForThreshold(threshold, data = null) {
    if (!data) data = productAnalysisData;
    if (!data || !data.distribution) return;

    // Find the actual product count at the user's threshold using distribution data
    // This matches how Top Customers calculates the count
    let productCount = null;
    let productPercent = null;
    for (const point of data.distribution) {
        if (point.cumulative_revenue_percent >= threshold) {
            productCount = point.product_count;
            // Calculate percent of total products
            productPercent = data.total_products > 0
                ? ((point.product_count / data.total_products) * 100).toFixed(0)
                : 0;
            break;
        }
    }

    // If threshold is higher than all distribution points, use the last point
    if (productCount === null && data.distribution.length > 0) {
        const lastPoint = data.distribution[data.distribution.length - 1];
        productCount = lastPoint.product_count;
        productPercent = 100;
    }

    if (productCount !== null) {
        document.getElementById('selectedProductsCount').textContent = productCount.toLocaleString();
        document.getElementById('selectedProductsPercent').textContent = `(${productPercent}%)`;
    }

    document.getElementById('revenueCoverage').textContent = `${threshold}%`;
    document.getElementById('revenueCoverageAmount').textContent =
        `($${(data.total_revenue * threshold / 100 / 1000000).toFixed(1)}M of $${(data.total_revenue / 1000000).toFixed(1)}M)`;

    updateProductsSummary();
}

function onThresholdChange() {
    const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

    if (productAnalysisData) {
        updateProductSelectionForThreshold(threshold);
        // Redraw chart with new threshold line
        drawRevenueDistributionChart(productAnalysisData.distribution, threshold);
    }

    validateCurrentStep();
}

function updateProductsSummary() {
    const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

    if (productAnalysisData && productAnalysisData.distribution) {
        // Find the actual product count at the user's threshold using distribution data
        let productCount = null;
        for (const point of productAnalysisData.distribution) {
            if (point.cumulative_revenue_percent >= threshold) {
                productCount = point.product_count;
                break;
            }
        }

        // If threshold is higher than all distribution points, use the last point
        if (productCount === null && productAnalysisData.distribution.length > 0) {
            productCount = productAnalysisData.distribution[productAnalysisData.distribution.length - 1].product_count;
        }

        if (productCount !== null) {
            // Summary element removed from tablet header design
            const productsSummary = document.getElementById('productsSummary');
            if (productsSummary) {
                productsSummary.textContent = `${productCount.toLocaleString()} products at ${threshold}%`;
            }
        }
    }
}

function showProductAnalysisError(message) {
    const resultsEl = document.getElementById('productAnalysisResults');
    const errorEl = document.getElementById('productAnalysisError');
    const errorTextEl = document.getElementById('productAnalysisErrorText');

    if (resultsEl) resultsEl.classList.add('hidden');
    if (errorEl) errorEl.classList.remove('hidden');
    if (errorTextEl) errorTextEl.textContent = message;

    // Summary element removed from tablet header design
    const productsSummary = document.getElementById('productsSummary');
    if (productsSummary) productsSummary.textContent = 'Analysis failed';
}

// --- D3.js Revenue Distribution Chart ---
function drawRevenueDistributionChart(distribution, threshold = 80) {
    const container = document.getElementById('revenueChartContainer');
    const svg = d3.select('#revenueDistributionChart');

    // Clear previous chart
    svg.selectAll('*').remove();

    if (!distribution || distribution.length === 0) return;

    // Get totals from productAnalysisData
    const totalProducts = productAnalysisData?.total_products || distribution[distribution.length - 1]?.product_count || 100;
    const totalRevenue = productAnalysisData?.total_revenue || distribution[distribution.length - 1]?.cumulative_revenue || 0;

    // Dimensions - use container width or fallback to reasonable default
    const margin = { top: 20, right: 30, bottom: 50, left: 70 };
    const containerWidth = container.clientWidth || container.offsetWidth || 600;
    const width = Math.max(containerWidth - margin.left - margin.right, 200);
    const height = 200 - margin.top - margin.bottom;

    svg.attr('width', width + margin.left + margin.right)
       .attr('height', height + margin.top + margin.bottom);

    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Scales - X: product count, Y: cumulative revenue
    const x = d3.scaleLinear()
        .domain([0, totalProducts])
        .range([0, width]);

    const y = d3.scaleLinear()
        .domain([0, totalRevenue])
        .range([height, 0]);

    // Format helpers
    const formatRevenue = (val) => {
        if (val >= 1000000) return `$${(val / 1000000).toFixed(1)}M`;
        if (val >= 1000) return `$${(val / 1000).toFixed(0)}K`;
        return `$${val.toFixed(0)}`;
    };

    // Add grid lines
    g.append('g')
        .attr('class', 'grid')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickSize(-height).tickFormat('').ticks(Math.min(totalProducts, 10)))
        .style('stroke-dasharray', '3,3')
        .style('stroke-opacity', 0.2);

    g.append('g')
        .attr('class', 'grid')
        .call(d3.axisLeft(y).tickSize(-width).tickFormat('').ticks(5))
        .style('stroke-dasharray', '3,3')
        .style('stroke-opacity', 0.2);

    // Line generator - use product_count for X and cumulative_revenue for Y
    const line = d3.line()
        .x(d => x(d.product_count))
        .y(d => y(d.cumulative_revenue))
        .curve(d3.curveMonotoneX);

    // Ensure data starts at (0,0) for proper chart connection
    const chartData = [{ product_count: 0, cumulative_revenue: 0, cumulative_revenue_percent: 0 }, ...distribution];

    // Draw the distribution line
    g.append('path')
        .datum(chartData)
        .attr('fill', 'none')
        .attr('stroke', '#3b82f6')
        .attr('stroke-width', 2)
        .attr('d', line);

    // Calculate threshold revenue value and find intersection point
    const thresholdRevenue = totalRevenue * threshold / 100;
    const thresholdPoint = findThresholdPoint(distribution, threshold);

    const area = d3.area()
        .x(d => x(d.product_count))
        .y0(height)
        .y1(d => y(d.cumulative_revenue))
        .curve(d3.curveMonotoneX);

    // Filter data up to threshold, starting from (0,0)
    const areaData = [{ product_count: 0, cumulative_revenue: 0, cumulative_revenue_percent: 0 },
                      ...distribution.filter(d => d.cumulative_revenue_percent <= threshold)];
    if (areaData.length > 1 && thresholdPoint) {
        // Add the threshold point
        areaData.push({ product_count: thresholdPoint.productCount, cumulative_revenue: thresholdRevenue });

        g.append('path')
            .datum(areaData)
            .attr('fill', '#3b82f6')
            .attr('fill-opacity', 0.1)
            .attr('d', area);
    }

    // Draw threshold line (horizontal at threshold revenue)
    g.append('line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', y(thresholdRevenue))
        .attr('y2', y(thresholdRevenue))
        .attr('stroke', '#ef4444')
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '5,5');

    // Threshold label
    g.append('text')
        .attr('x', width - 5)
        .attr('y', y(thresholdRevenue) - 5)
        .attr('text-anchor', 'end')
        .attr('fill', '#ef4444')
        .attr('font-size', '11px')
        .text(`${threshold}% revenue (${formatRevenue(thresholdRevenue)})`);

    // Vertical line at threshold intersection
    if (thresholdPoint && thresholdPoint.productCount > 0) {
        g.append('line')
            .attr('x1', x(thresholdPoint.productCount))
            .attr('x2', x(thresholdPoint.productCount))
            .attr('y1', y(thresholdRevenue))
            .attr('y2', height)
            .attr('stroke', '#ef4444')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '3,3');

        // Products count label
        g.append('text')
            .attr('x', x(thresholdPoint.productCount))
            .attr('y', height + 35)
            .attr('text-anchor', 'middle')
            .attr('fill', '#ef4444')
            .attr('font-size', '10px')
            .text(`${Math.ceil(thresholdPoint.productCount)} products`);
    }

    // X axis - product counts
    g.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(Math.min(totalProducts, 10)).tickFormat(d => d.toLocaleString()))
        .selectAll('text')
        .style('font-size', '10px');

    // Y axis - revenue amounts
    g.append('g')
        .call(d3.axisLeft(y).ticks(5).tickFormat(formatRevenue))
        .selectAll('text')
        .style('font-size', '10px');

    // Axis labels
    g.append('text')
        .attr('x', width / 2)
        .attr('y', height + 45)
        .attr('text-anchor', 'middle')
        .attr('fill', '#666')
        .attr('font-size', '11px')
        .text('Products (ranked by revenue)');

    g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -55)
        .attr('text-anchor', 'middle')
        .attr('fill', '#666')
        .attr('font-size', '11px')
        .text('Cumulative Revenue');
}

function findThresholdX(distribution, threshold) {
    // Find the x value (percent_products) where cumulative_revenue reaches the threshold
    for (let i = 0; i < distribution.length - 1; i++) {
        if (distribution[i].cumulative_revenue_percent <= threshold &&
            distribution[i + 1].cumulative_revenue_percent >= threshold) {
            // Linear interpolation
            const ratio = (threshold - distribution[i].cumulative_revenue_percent) /
                (distribution[i + 1].cumulative_revenue_percent - distribution[i].cumulative_revenue_percent);
            return distribution[i].percent_products +
                ratio * (distribution[i + 1].percent_products - distribution[i].percent_products);
        }
    }
    return distribution[distribution.length - 1]?.percent_products || 100;
}

function findThresholdPoint(distribution, threshold) {
    // Find the point (product_count, revenue) where cumulative_revenue_percent reaches the threshold
    for (let i = 0; i < distribution.length - 1; i++) {
        if (distribution[i].cumulative_revenue_percent <= threshold &&
            distribution[i + 1].cumulative_revenue_percent >= threshold) {
            // Linear interpolation
            const ratio = (threshold - distribution[i].cumulative_revenue_percent) /
                (distribution[i + 1].cumulative_revenue_percent - distribution[i].cumulative_revenue_percent);
            const productCount = distribution[i].product_count +
                ratio * (distribution[i + 1].product_count - distribution[i].product_count);
            const revenue = distribution[i].cumulative_revenue +
                ratio * (distribution[i + 1].cumulative_revenue - distribution[i].cumulative_revenue);
            return { productCount, revenue };
        }
    }
    const last = distribution[distribution.length - 1];
    return last ? { productCount: last.product_count, revenue: last.cumulative_revenue } : null;
}

// --- Advanced Filters Sub-chapter ---
function toggleMinTransactionsInput() {
    const checkbox = document.getElementById('enableMinTransactions');
    document.getElementById('minTransactions').disabled = !checkbox.checked;
    updateAdvancedSummary();
    validateCurrentStep();
}

function updateAdvancedSummary() {
    // Summary element removed from tablet header design
    const advancedSummary = document.getElementById('advancedSummary');
    if (!advancedSummary) return;

    const minTxEnabled = document.getElementById('enableMinTransactions')?.checked;
    const minTx = document.getElementById('minTransactions')?.value || 2;

    let summary = 'No filters';
    if (minTxEnabled) {
        summary = `Min ${minTx} transactions`;
    }
    advancedSummary.textContent = summary;
}

// ============================================================================
// SAVE DATASET
// ============================================================================
function saveDataset() {
    // Collect all data from current step
    collectStepData(currentWizardStep);

    // Build summary snapshot from current Dataset Summary panel data
    // This captures whatever is currently displayed (filtered or unfiltered)
    const summarySnapshot = datasetStatsData ? {
        total_rows: datasetStatsData.summary?.total_rows || 0,
        filters_applied: datasetStatsData.filters_applied || {},
        column_stats: datasetStatsData.column_stats || {},
        snapshot_at: new Date().toISOString()
    } : {};

    // Build payload (split_config removed - handled by Training domain)
    const payload = {
        name: wizardData.name,
        description: wizardData.description,
        primary_table: wizardData.primaryTable,
        secondary_tables: wizardData.secondaryTables,
        join_config: wizardData.joinConfig,
        selected_columns: wizardData.selectedColumns,
        filters: wizardData.filters,
        summary_snapshot: summarySnapshot
    };

    const url = wizardEditMode
        ? `/api/datasets/${wizardEditDatasetId}/update/`
        : `/api/models/${modelId}/datasets/create/`;

    document.getElementById('saveButton').disabled = true;
    document.getElementById('saveButton').querySelector('.btn-neu-inner').innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Saving...';

    fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            showNotification(wizardEditMode ? 'Dataset updated successfully' : 'Dataset created successfully', 'success');
            closeWizard();
            loadDatasets();
        } else {
            showNotification(data.message || 'Failed to save dataset', 'error');
            if (data.errors) {
                console.error('Validation errors:', data.errors);
            }
        }
    })
    .catch(error => {
        console.error('Error saving dataset:', error);
        showNotification('Failed to save dataset', 'error');
    })
    .finally(() => {
        document.getElementById('saveButton').disabled = false;
        document.getElementById('saveButton').querySelector('.btn-neu-inner').textContent = 'Save';
    });
}

// ============================================================================
// DATASET ACTIONS
// ============================================================================
function viewDataset(datasetId) {
    currentDatasetId = datasetId;
    document.getElementById('detailModal').classList.remove('hidden');
    document.getElementById('detailContent').innerHTML = '<p class="text-center text-gray-500 py-8"><i class="fas fa-spinner fa-spin mr-2"></i>Loading...</p>';

    fetch(`/api/datasets/${datasetId}/summary/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            renderDatasetDetail(data.summary);
        } else {
            document.getElementById('detailContent').innerHTML = `<p class="text-center text-red-500 py-8">${data.message || 'Failed to load details'}</p>`;
        }
    })
    .catch(error => {
        console.error('Error loading dataset:', error);
        document.getElementById('detailContent').innerHTML = '<p class="text-center text-red-500 py-8">Failed to load details</p>';
    });
}

function renderDatasetDetail(summary) {
    document.getElementById('detailModalTitle').textContent = summary.name;

    // Build filters applied display from summary_snapshot
    const snapshot = summary.summary_snapshot || {};
    const filtersApplied = snapshot.filters_applied || {};
    const columnStats = snapshot.column_stats || {};
    const joinConfig = summary.join_config || {};
    const filtersConfig = summary.filters?.config || {};

    // Build join configuration display
    const joinRows = Object.entries(joinConfig).map(([table, config]) => {
        const tableName = table.replace('raw_data.', '');
        const primaryTable = summary.tables.primary?.replace('raw_data.', '') || 'primary';
        return `
            <div class="flex items-center text-sm py-1">
                <span class="text-gray-900 font-medium">${primaryTable}.${config.join_key}</span>
                <i class="fas fa-arrows-alt-h mx-2 text-gray-400"></i>
                <span class="text-gray-900 font-medium">${tableName}.${config.secondary_column}</span>
                <span class="ml-2 px-2 py-0.5 rounded text-xs bg-gray-200 text-gray-600">${config.join_type || 'LEFT'}</span>
            </div>
        `;
    }).join('');

    // Build detailed filters display
    const filterDetails = [];

    // Dates filter details
    if (filtersApplied.dates?.type === 'rolling') {
        filterDetails.push(`
            <div class="border-l-4 border-blue-400 pl-3 py-2">
                <div class="font-medium text-gray-900"><i class="fas fa-calendar-alt mr-2 text-blue-500"></i>Date Filter</div>
                <div class="text-sm text-gray-600 mt-1">
                    <span class="text-gray-500">Column:</span> <span class="font-medium">${filtersApplied.dates.column || 'N/A'}</span><br>
                    <span class="text-gray-500">Range:</span> Last ${filtersApplied.dates.days} days (rolling window)
                </div>
            </div>
        `);
    } else if (filtersApplied.dates?.type === 'fixed') {
        filterDetails.push(`
            <div class="border-l-4 border-blue-400 pl-3 py-2">
                <div class="font-medium text-gray-900"><i class="fas fa-calendar-alt mr-2 text-blue-500"></i>Date Filter</div>
                <div class="text-sm text-gray-600 mt-1">
                    <span class="text-gray-500">Column:</span> <span class="font-medium">${filtersApplied.dates.column || 'N/A'}</span><br>
                    <span class="text-gray-500">Start Date:</span> ${filtersApplied.dates.start_date}
                </div>
            </div>
        `);
    }

    // Customers filter details
    if (filtersApplied.customers?.type === 'multiple' && filtersApplied.customers.filters?.length > 0) {
        const customerFilterItems = filtersApplied.customers.filters.map(f => {
            if (f.type === 'top_revenue') {
                return `<li>Top <strong>${f.percent}%</strong> customers by revenue<br>
                    <span class="text-gray-500 text-xs ml-4">Customer: ${f.customer_column || 'N/A'}, Revenue: ${f.revenue_column || 'N/A'}</span></li>`;
            } else if (f.type === 'transaction_count') {
                const desc = f.filter_type === 'greater_than' ? `> ${f.value}` :
                             f.filter_type === 'less_than' ? `< ${f.value}` :
                             `${f.min} - ${f.max}`;
                return `<li>Transaction count ${desc}</li>`;
            } else if (f.type === 'spending') {
                const desc = f.filter_type === 'greater_than' ? `> $${f.value}` :
                             f.filter_type === 'less_than' ? `< $${f.value}` :
                             `$${f.min} - $${f.max}`;
                return `<li>Total spending ${desc}</li>`;
            } else if (f.type === 'category') {
                return `<li>${f.column}: ${f.mode} ${f.values?.slice(0, 3).join(', ')}${f.values?.length > 3 ? '...' : ''}</li>`;
            } else if (f.type === 'numeric') {
                const desc = f.filter_type === 'range' ? `${f.min} - ${f.max}` :
                             f.filter_type === 'greater_than' ? `> ${f.value}` :
                             f.filter_type === 'less_than' ? `< ${f.value}` : `= ${f.value}`;
                return `<li>${f.column}: ${desc}</li>`;
            }
            return `<li>${f.type}</li>`;
        }).join('');
        filterDetails.push(`
            <div class="border-l-4 border-green-400 pl-3 py-2">
                <div class="font-medium text-gray-900"><i class="fas fa-users mr-2 text-green-500"></i>Customer Filters (${filtersApplied.customers.count})</div>
                <ul class="text-sm text-gray-600 mt-1 list-disc list-inside">${customerFilterItems}</ul>
            </div>
        `);
    }

    // Products filter details
    if (filtersApplied.products?.type === 'multiple' && filtersApplied.products.filters?.length > 0) {
        const productFilterItems = filtersApplied.products.filters.map(f => {
            if (f.type === 'top_revenue') {
                return `<li>Top <strong>${f.percent}%</strong> products by revenue<br>
                    <span class="text-gray-500 text-xs ml-4">Product: ${f.product_column || 'N/A'}, Revenue: ${f.revenue_column || 'N/A'}</span></li>`;
            } else if (f.type === 'category') {
                return `<li>${f.column}: ${f.mode} ${f.values?.slice(0, 3).join(', ')}${f.values?.length > 3 ? '...' : ''}</li>`;
            } else if (f.type === 'numeric') {
                const desc = f.filter_type === 'range' ? `${f.min} - ${f.max}` :
                             f.filter_type === 'greater_than' ? `> ${f.value}` :
                             f.filter_type === 'less_than' ? `< ${f.value}` : `= ${f.value}`;
                return `<li>${f.column}: ${desc}</li>`;
            }
            return `<li>${f.type}</li>`;
        }).join('');
        filterDetails.push(`
            <div class="border-l-4 border-purple-400 pl-3 py-2">
                <div class="font-medium text-gray-900"><i class="fas fa-box mr-2 text-purple-500"></i>Product Filters (${filtersApplied.products.count})</div>
                <ul class="text-sm text-gray-600 mt-1 list-disc list-inside">${productFilterItems}</ul>
            </div>
        `);
    }

    // Build column stats table rows
    const columnStatsRows = Object.entries(columnStats).map(([colName, stats]) => {
        return `
            <tr>
                <td class="px-3 py-2 text-sm text-gray-900">${colName}</td>
                <td class="px-3 py-2"><span class="inline-block px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-700">${stats.type || 'UNKNOWN'}</span></td>
                <td class="px-3 py-2 text-sm text-gray-600">${formatDetailColumnStats(stats)}</td>
            </tr>
        `;
    }).join('');

    const html = `
        <div class="space-y-4">
            <!-- Info -->
            <div class="flex items-center gap-3">
                <span class="text-sm text-gray-500">Created ${new Date(summary.timestamps.created_at).toLocaleDateString()}</span>
                ${snapshot.has_snapshot ? `<span class="px-3 py-1 rounded-full text-sm font-bold bg-green-100 text-green-700">${formatNumber(snapshot.total_rows)} rows</span>` : ''}
            </div>

            ${summary.description ? `<p class="text-gray-600">${escapeHtml(summary.description)}</p>` : ''}

            <!-- Tables & Joins -->
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-2"><i class="fas fa-database mr-2 text-gray-500"></i>Tables & Joins</h4>
                <div class="space-y-2">
                    <div class="flex items-center">
                        <span class="text-sm font-medium text-gray-700 w-24">Primary:</span>
                        <span class="text-sm text-gray-900 font-medium">${summary.tables.primary?.replace('raw_data.', '') || 'Not set'}</span>
                    </div>
                    ${summary.tables.secondary.length > 0 ? `
                    <div class="flex items-start">
                        <span class="text-sm font-medium text-gray-700 w-24">Secondary:</span>
                        <span class="text-sm text-gray-900">${summary.tables.secondary.map(t => t.replace('raw_data.', '')).join(', ')}</span>
                    </div>
                    ` : ''}
                    ${Object.keys(joinConfig).length > 0 ? `
                    <div class="mt-3 pt-3 border-t border-gray-200">
                        <div class="text-sm font-medium text-gray-700 mb-2">Join Keys:</div>
                        ${joinRows}
                    </div>
                    ` : ''}
                </div>
            </div>

            <!-- Filters Applied (Detailed) -->
            ${filterDetails.length > 0 ? `
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-3"><i class="fas fa-filter mr-2 text-gray-500"></i>Filters Applied</h4>
                <div class="space-y-3">
                    ${filterDetails.join('')}
                </div>
            </div>
            ` : `
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-2"><i class="fas fa-filter mr-2 text-gray-500"></i>Filters Applied</h4>
                <p class="text-sm text-gray-500">No filters applied - using all data</p>
            </div>
            `}

            <!-- Column Statistics -->
            ${snapshot.has_snapshot && Object.keys(columnStats).length > 0 ? `
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-3"><i class="fas fa-chart-bar mr-2 text-gray-500"></i>Column Statistics</h4>
                <div class="bg-white rounded-lg border border-gray-200 overflow-hidden">
                    <table class="w-full text-left">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-3 py-2 text-xs font-semibold text-gray-700 uppercase">Column</th>
                                <th class="px-3 py-2 text-xs font-semibold text-gray-700 uppercase">Type</th>
                                <th class="px-3 py-2 text-xs font-semibold text-gray-700 uppercase">Statistics</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-100">
                            ${columnStatsRows}
                        </tbody>
                    </table>
                </div>
                ${snapshot.snapshot_at ? `
                <div class="mt-3 text-xs text-gray-500">
                    <i class="fas fa-clock mr-1"></i>Snapshot from ${new Date(snapshot.snapshot_at).toLocaleString()}
                </div>
                ` : ''}
            </div>
            ` : ''}

            ${!snapshot.has_snapshot ? `
            <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                <p class="text-sm text-yellow-800">
                    <i class="fas fa-info-circle mr-1"></i>
                    No summary snapshot available. Edit the dataset to generate statistics.
                </p>
            </div>
            ` : ''}
        </div>
    `;

    document.getElementById('detailContent').innerHTML = html;
}

function editDataset(datasetId) {
    // Open wizard in edit mode - loadDatasetForEdit is called inside openWizard
    // after tables are loaded to avoid race condition
    openWizard(datasetId);
}

function loadDatasetForEdit(datasetId) {
    fetch(`/api/datasets/${datasetId}/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            const ds = data.dataset;

            // Populate wizard data
            wizardData.name = ds.name;
            wizardData.description = ds.description || '';
            wizardData.primaryTable = ds.primary_table;
            wizardData.secondaryTables = ds.secondary_tables || [];
            wizardData.joinConfig = ds.join_config || {};
            wizardData.selectedColumns = ds.selected_columns || {};
            wizardData.filters = ds.filters || {};

            // Update form fields
            document.getElementById('datasetName').value = ds.name;
            document.getElementById('datasetDescription').value = ds.description || '';

            // Update table selections
            renderPrimaryTableList();
            renderSecondaryTableList();

            validateCurrentStep();
        }
    })
    .catch(error => {
        console.error('Error loading dataset for edit:', error);
    });
}

function editDatasetFromDetail() {
    closeDetailModal();
    editDataset(currentDatasetId);
}

function deleteDataset(datasetId, name) {
    document.getElementById('deleteDatasetName').textContent = name;
    document.getElementById('deleteModal').classList.remove('hidden');
    document.getElementById('deleteModal').dataset.datasetId = datasetId;
    document.getElementById('deleteWarning').classList.add('hidden');
}

function closeDeleteModal() {
    document.getElementById('deleteModal').classList.add('hidden');
}

function confirmDelete() {
    const datasetId = document.getElementById('deleteModal').dataset.datasetId;

    document.getElementById('confirmDeleteBtn').disabled = true;
    document.getElementById('confirmDeleteBtn').innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Deleting...';

    fetch(`/api/datasets/${datasetId}/delete/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({ force: true })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            showNotification('Dataset deleted successfully', 'success');
            closeDeleteModal();
            loadDatasets();
        } else {
            showNotification(data.message || 'Failed to delete dataset', 'error');
        }
    })
    .catch(error => {
        console.error('Error deleting dataset:', error);
        showNotification('Failed to delete dataset', 'error');
    })
    .finally(() => {
        document.getElementById('confirmDeleteBtn').disabled = false;
        document.getElementById('confirmDeleteBtn').textContent = 'Delete';
    });
}

// ============================================================================
// QUERY PREVIEW
// ============================================================================
function viewGeneratedQuery() {
    if (!currentDatasetId) return;

    document.getElementById('queryModal').classList.remove('hidden');
    document.getElementById('queryContent').textContent = 'Loading...';

    // Load base query (train/eval split is handled by Training domain)
    fetch(`/api/datasets/${currentDatasetId}/query/`, { headers: { 'X-CSRFToken': csrftoken } })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success') {
            currentQueries = { full: data.query };
            document.getElementById('queryContent').textContent = data.query;

            if (data.validation) {
                const validation = data.validation;
                document.getElementById('queryValidation').innerHTML = `
                    <div class="flex items-center gap-4">
                        <span class="text-gray-600"><i class="fas fa-database mr-1"></i>${formatBytes(validation.total_bytes_processed || 0)} processed</span>
                        <span class="text-gray-600"><i class="fas fa-dollar-sign mr-1"></i>Est. $${(validation.estimated_cost_usd || 0).toFixed(4)}</span>
                        ${validation.is_valid ? '<span class="text-green-600"><i class="fas fa-check-circle mr-1"></i>Valid</span>' : '<span class="text-red-600"><i class="fas fa-times-circle mr-1"></i>Invalid</span>'}
                    </div>
                `;
            }
        } else {
            document.getElementById('queryContent').textContent = 'Error loading query';
        }
    })
    .catch(error => {
        console.error('Error loading query:', error);
        document.getElementById('queryContent').textContent = 'Error loading query';
    });
}

function copyQuery() {
    const query = document.getElementById('queryContent').textContent;
    navigator.clipboard.writeText(query).then(() => {
        showNotification('Query copied to clipboard', 'success');
    }).catch(() => {
        showNotification('Failed to copy query', 'error');
    });
}

function closeQueryModal() {
    document.getElementById('queryModal').classList.add('hidden');
}

function closeDetailModal() {
    document.getElementById('detailModal').classList.add('hidden');
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Store callback for notification close and auto-close timer
let notificationCloseCallback = null;
let notificationAutoCloseTimer = null;

function showNotification(message, type = 'info', title = null, onClose = null) {
    const modal = document.getElementById('notificationModal');
    const icon = document.getElementById('notificationIcon');
    const titleEl = document.getElementById('notificationTitle');
    const messageEl = document.getElementById('notificationMessage');

    // Clear any existing auto-close timer
    if (notificationAutoCloseTimer) {
        clearTimeout(notificationAutoCloseTimer);
        notificationAutoCloseTimer = null;
    }

    // Store callback
    notificationCloseCallback = onClose;

    // Set message
    messageEl.textContent = message;

    // Set icon and colors based on type
    if (type === 'error') {
        icon.className = 'fas fa-exclamation-circle text-red-600 text-xl';
        titleEl.textContent = title || 'Error';
    } else if (type === 'warning') {
        icon.className = 'fas fa-exclamation-triangle text-yellow-600 text-xl';
        titleEl.textContent = title || 'Warning';
    } else if (type === 'success') {
        icon.className = 'fas fa-check-circle text-green-600 text-xl';
        titleEl.textContent = title || 'Success';
    } else {
        icon.className = 'fas fa-info-circle text-blue-600 text-xl';
        titleEl.textContent = title || 'Information';
    }

    // Show modal
    modal.classList.remove('hidden');

    // Auto-close after 2 seconds (errors stay longer at 4 seconds)
    const autoCloseDelay = type === 'error' ? 4000 : 2000;
    notificationAutoCloseTimer = setTimeout(() => {
        closeNotification();
    }, autoCloseDelay);
}

function closeNotification() {
    const modal = document.getElementById('notificationModal');
    modal.classList.add('hidden');

    // Clear auto-close timer if manually closed
    if (notificationAutoCloseTimer) {
        clearTimeout(notificationAutoCloseTimer);
        notificationAutoCloseTimer = null;
    }

    // Execute callback if provided
    if (notificationCloseCallback) {
        notificationCloseCallback();
        notificationCloseCallback = null;
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatNumber(num) {
    if (!num) return '0';
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toLocaleString();
}

function formatBytes(bytes) {
    if (!bytes) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}
</script>
{% endblock %}
