{% extends 'base_model.html' %}
{% load humanize %}
{% load static %}

{% block title %}{{ model.name }} - Dataset Manager{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/cards.css' %}?v=4">
<link rel="stylesheet" href="{% static 'css/modals.css' %}?v=2">
{% endblock %}

{% block model_content %}
<div class="space-y-6">
    <!-- Dataset Manager Container -->
    <div class="bg-white rounded-xl border border-black shadow-lg p-6">
        <div class="flex items-center justify-between mb-6">
            <h2 class="text-2xl font-bold text-gray-900">Dataset Manager</h2>
            <div class="btn-group">
                <button onclick="refreshDatasets()" class="btn btn-secondary btn-sm" style="width: 140px;">
                    <i class="fas fa-sync-alt"></i>Refresh
                </button>
                <button onclick="openWizard()" class="btn btn-primary btn-sm" style="width: 140px;">
                    <i class="fas fa-plus"></i>New Dataset
                </button>
            </div>
        </div>

        <!-- Filter Bar -->
        <div class="flex items-center gap-4 mb-4">
            <div class="flex items-center gap-2">
                <label class="text-sm font-medium text-gray-600">Status:</label>
                <select id="statusFilter" onchange="filterDatasets()" class="form-select text-sm" style="width: 120px;">
                    <option value="">All</option>
                    <option value="draft">Draft</option>
                    <option value="active">Active</option>
                </select>
            </div>
            <div class="flex-1">
                <input type="text" id="searchInput" placeholder="Search datasets..."
                       class="form-input w-full text-sm" onkeyup="debounceSearch()">
            </div>
        </div>

        <!-- Datasets List Container -->
        <div id="datasetsList" class="space-y-3" style="min-height: 200px;">
            <!-- Dataset cards will be inserted here by JavaScript -->
            <div class="card-empty-state">
                <p class="card-empty-state-title">No datasets configured</p>
                <p class="card-empty-state-text">Create your first dataset to define training data for your ML models</p>
            </div>
        </div>

        <!-- Pagination -->
        <div id="paginationContainer" class="hidden mt-4 pt-4 border-t border-gray-200">
            <div class="flex items-center justify-between">
                <div id="paginationInfo" class="text-sm text-gray-600"></div>
                <div id="paginationButtons" class="flex items-center gap-2"></div>
            </div>
        </div>
    </div>
</div>

<!-- Dataset Wizard Modal -->
<div id="datasetWizardModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-wizard modal-dataset-wizard">
        <!-- Modal Header -->
        <div class="modal-header-wizard">
            <div class="modal-header-content">
                <div class="modal-header-icon info">
                    <i class="fas fa-table text-lg"></i>
                </div>
                <div class="modal-header-info">
                    <h3 class="modal-header-title" id="wizardTitle">Create Dataset</h3>
                    <p class="modal-step-counter">Step <span id="currentStep">1</span> of 5</p>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="progress-bar-pills">
                <div id="progress1" class="progress-step-pill current">Info</div>
                <div id="progress2" class="progress-step-pill future">Tables</div>
                <div id="progress3" class="progress-step-pill future">Schema</div>
                <div id="progress4" class="progress-step-pill future">Filters</div>
                <div id="progress5" class="progress-step-pill future">Split</div>
            </div>
        </div>

        <!-- Modal Body -->
        <div class="modal-body-wizard">
            <!-- Step 1: Basic Info -->
            <div id="step1" class="wizard-step active">
                <h4 class="wizard-section-title">Basic Information</h4>

                <!-- Dataset Name -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Dataset Name <span class="required">*</span></label>
                    <input type="text" id="datasetName" placeholder="e.g., Transactions Q4 2024"
                           class="form-input w-full" oninput="validateDatasetName()">
                    <p id="nameError" class="text-xs text-red-600 mt-1 hidden"></p>
                    <p id="nameSuccess" class="text-xs text-green-600 mt-1 hidden">
                        <i class="fas fa-check-circle mr-1"></i>Name is available
                    </p>
                </div>

                <!-- Description -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Description <span class="optional">(optional)</span></label>
                    <textarea id="datasetDescription" placeholder="Describe the purpose of this dataset..."
                              class="form-textarea w-full" rows="3"></textarea>
                </div>

                <div class="wizard-info-box info">
                    <i class="fas fa-info-circle"></i>
                    <div>
                        <strong>What is a Dataset?</strong><br>
                        A dataset defines which BigQuery tables, columns, and filters to use for training your ML models.
                    </div>
                </div>
            </div>

            <!-- Step 2: Source Tables -->
            <div id="step2" class="wizard-step">
                <h4 class="wizard-section-title">Select Source Tables</h4>
                <p class="wizard-section-subtitle">Choose tables from your BigQuery raw_data dataset.</p>

                <!-- Primary Table -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Primary Table <span class="required">*</span></label>
                    <div class="wizard-list-container">
                        <div id="primaryTableList" class="list-content" style="max-height: 160px;">
                            <p class="text-center text-gray-500 py-4">
                                <i class="fas fa-spinner fa-spin mr-2"></i>Loading tables...
                            </p>
                        </div>
                    </div>
                    <p class="wizard-field-hint">
                        <i class="fas fa-info-circle mr-1"></i>
                        The primary table contains your main transaction/interaction data.
                    </p>
                </div>

                <!-- Secondary Tables -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Secondary Tables <span class="optional">(optional)</span></label>
                    <div class="wizard-list-container">
                        <div id="secondaryTableList" class="list-content" style="max-height: 140px;">
                            <p class="text-center text-gray-500 py-4">Select a primary table first</p>
                        </div>
                    </div>
                    <p class="wizard-field-hint">
                        <i class="fas fa-link mr-1"></i>
                        Additional tables to join (e.g., products, customers). You'll configure joins in the next step.
                    </p>
                </div>
            </div>

            <!-- Step 3: Visual Schema Builder -->
            <div id="step3" class="wizard-step">
                <div class="schema-builder-container">
                    <!-- Header with title -->
                    <div class="schema-builder-header">
                        <div>
                            <h4 class="wizard-section-title" style="margin-bottom: 2px;">Schema Builder</h4>
                            <p class="wizard-section-subtitle" style="margin-bottom: 0;">Connect tables and select columns for your dataset.</p>
                        </div>
                    </div>

                    <!-- Table Cards Area -->
                    <div class="schema-cards-area" id="schemaCardsArea">
                        <!-- SVG for connection lines -->
                        <svg class="schema-connections-svg" id="connectionsSvg"></svg>

                        <!-- Table cards container -->
                        <div class="schema-cards-container" id="schemaCardsContainer">
                            <!-- Loading state -->
                            <div class="schema-loading" id="schemaLoading">
                                <i class="fas fa-spinner fa-spin"></i>
                                Loading table samples...
                            </div>
                        </div>
                    </div>

                    <!-- Preview Section -->
                    <div class="schema-preview-section">
                        <!-- Stats bar -->
                        <div class="schema-preview-stats" id="previewStats">
                            <div class="stat-item">
                                <span>Preview:</span>
                                <span class="stat-value" id="previewRowCount">-</span>
                                <span>rows</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value" id="previewColCount">-</span>
                                <span>columns</span>
                            </div>
                            <div class="stat-item" id="previewWarnings" style="display: none;">
                                <i class="fas fa-exclamation-triangle stat-warning"></i>
                                <span class="stat-warning" id="previewWarningText"></span>
                            </div>
                        </div>

                        <!-- Preview table -->
                        <div class="schema-preview-table-container" id="previewTableContainer">
                            <div class="schema-preview-empty" id="previewEmpty">
                                <i class="fas fa-table"></i>
                                Select columns to see a preview of your dataset
                            </div>
                            <table class="schema-preview-table" id="previewTable" style="display: none;">
                                <thead id="previewTableHead"></thead>
                                <tbody id="previewTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Join Popover (hidden by default) -->
                <div class="join-popover hidden" id="joinPopover">
                    <div class="join-popover-header">Join Type</div>
                    <div class="join-popover-option" data-type="left" onclick="setJoinType('left')">
                        <i class="fas fa-check"></i> LEFT JOIN
                    </div>
                    <div class="join-popover-option" data-type="inner" onclick="setJoinType('inner')">
                        <i class="fas fa-check"></i> INNER JOIN
                    </div>
                    <div class="join-popover-option danger" onclick="removeSelectedJoin()">
                        <i class="fas fa-trash"></i> Remove
                    </div>
                </div>

                <!-- Column Info Popover for connect mode (hidden by default) -->
                <div class="column-info-popover hidden" id="columnInfoPopover">
                    <div class="column-info-name" id="columnInfoName">column_name</div>
                    <div class="column-info-type" id="columnInfoType">
                        <span class="column-info-label">Type:</span>
                        <span class="column-info-value" id="columnInfoTypeValue">STRING</span>
                    </div>
                    <div class="column-info-samples" id="columnInfoSamples">
                        <span class="column-info-label">Samples:</span>
                        <span class="column-info-value" id="columnInfoSamplesValue"></span>
                    </div>
                    <div class="column-info-hint" id="columnInfoHint">
                        Click a column in another table to connect
                    </div>
                    <div class="column-info-warning hidden" id="columnInfoWarning">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span id="columnInfoWarningText">Type mismatch</span>
                    </div>
                    <div class="column-info-compatible hidden" id="columnInfoCompatible">
                        <i class="fas fa-check-circle"></i>
                        <span>Compatible</span>
                    </div>
                </div>
            </div>

            <!-- Step 4: Filtering -->
            <div id="step4" class="wizard-step">
                <h4 class="wizard-section-title">Filtering</h4>
                <p class="wizard-section-subtitle">Configure filters to select the data for your dataset.</p>

                <!-- Sub-chapter 1: Dates -->
                <div class="filter-subchapter" id="historySubchapter">
                    <div class="subchapter-header-tablet" onclick="toggleSubchapter('history')">
                        <span class="subchapter-title">Dates</span>
                        <span class="subchapter-filter-status" id="datesFilterStatus"></span>
                        <i id="historyChevron" class="fas fa-chevron-right subchapter-chevron"></i>
                    </div>
                    <div id="historyContent" class="subchapter-content-outside hidden">
                        <!-- Filter Buttons Row -->
                        <div class="filter-buttons-row">
                            <!-- Timestamp Column Button -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Select timestamp column</span>
                                <button type="button" class="filter-button" id="timestampColumnBtn" onclick="toggleFilterPopup('timestampColumn')">
                                    <i class="fas fa-clock"></i>
                                    <span>Timestamp Column</span>
                                </button>
                                <div class="filter-popup" id="timestampColumnPopup">
                                    <div class="filter-popup-header">Select Timestamp Column</div>
                                    <select id="timestampColumn" class="form-select w-full text-sm" onchange="onTimestampColumnChange(); closeFilterPopup('timestampColumn');">
                                        <option value="">Select column...</option>
                                    </select>
                                    <p class="filter-popup-hint">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Column used to filter data by date
                                    </p>
                                </div>
                            </div>

                            <!-- Rolling Window Button -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Set number of days</span>
                                <button type="button" class="filter-button" id="rollingWindowBtn" onclick="toggleFilterPopup('rollingWindow')">
                                    <i class="fas fa-history"></i>
                                    <span>Rolling Window</span>
                                </button>
                                <div class="filter-popup" id="rollingWindowPopup">
                                    <div class="filter-popup-header">Set Rolling Window</div>
                                    <div class="flex items-center gap-2">
                                        <input type="number" id="rollingDays" value="30" min="1" max="365"
                                               class="form-input w-20 text-sm" onchange="onRollingDaysChange()">
                                        <span class="text-sm text-gray-600">days</span>
                                        <button type="button" class="btn btn-sm btn-primary" onclick="applyRollingWindow()">Apply</button>
                                    </div>
                                    <p class="filter-popup-hint">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Days from the latest available date
                                    </p>
                                </div>
                            </div>

                            <!-- Start Date Button -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">Select start date</span>
                                <button type="button" class="filter-button" id="startDateBtn" onclick="toggleFilterPopup('startDate')">
                                    <i class="fas fa-calendar-alt"></i>
                                    <span>Start Date</span>
                                </button>
                                <div class="filter-popup" id="startDatePopup">
                                    <div class="filter-popup-header">Select Start Date</div>
                                    <input type="date" id="startDateInput" class="form-input w-full text-sm" onchange="onStartDateChange(); closeFilterPopup('startDate');">
                                    <p class="filter-popup-hint">
                                        <i class="fas fa-info-circle mr-1"></i>
                                        Fixed start date for the dataset
                                    </p>
                                </div>
                            </div>

                            <!-- Refresh Dataset Button -->
                            <div class="filter-button-wrapper">
                                <span class="filter-button-label">&nbsp;</span>
                                <button type="button" class="filter-button filter-button-refresh filter-button-disabled" id="refreshDatasetBtn" onclick="refreshDatasetHistory()" disabled>
                                    <i class="fas fa-sync-alt"></i>
                                    <span>Refresh Dataset</span>
                                </button>
                            </div>
                        </div>

                        <!-- Summary Line -->
                        <div class="filter-summary-line" id="datesFilterSummary">
                            <span class="filter-summary-text" id="datesFilterSummaryText">No filters selected</span>
                        </div>
                    </div>
                </div>

                <!-- Sub-chapter 2: Customers -->
                <div class="filter-subchapter" id="customersSubchapter">
                    <div class="subchapter-header-tablet" onclick="toggleSubchapter('customers')">
                        <span class="subchapter-title">Customers</span>
                        <i id="customersChevron" class="fas fa-chevron-right subchapter-chevron"></i>
                    </div>
                    <div id="customersContent" class="subchapter-content-outside hidden">
                        <div class="subchapter-body-outside">
                            <!-- Min Transactions Filter -->
                            <div class="flex items-center gap-3 mb-3">
                                <input type="checkbox" id="enableMinTransactions" onchange="toggleMinTransactionsInput()">
                                <label class="text-sm text-gray-700">Minimum</label>
                                <input type="number" id="minTransactions" value="2" min="1"
                                       class="form-input w-20 text-sm" disabled>
                                <span class="text-sm text-gray-700">transactions per customer</span>
                            </div>
                            <p class="wizard-field-hint">
                                <i class="fas fa-info-circle mr-1"></i>
                                Customers with very few transactions don't provide enough signal for recommendations
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Sub-chapter 3: Products -->
                <div class="filter-subchapter" id="productsSubchapter">
                    <div class="subchapter-header-tablet" onclick="toggleSubchapter('products')">
                        <span class="subchapter-title">Products</span>
                        <span class="subchapter-filter-status" id="productsFilterStatus"></span>
                        <i id="productsChevron" class="fas fa-chevron-right subchapter-chevron"></i>
                    </div>
                    <div id="productsContent" class="subchapter-content-outside hidden">
                        <div class="subchapter-body">
                            <!-- 3-Button Navigation Row (matching Dates sub-chapter style) -->
                            <div class="filter-buttons-row">
                                <div class="filter-button-wrapper">
                                    <span class="filter-button-label">Filter by revenue</span>
                                    <button type="button" class="filter-button" onclick="openTopProductsModal()">
                                        <i class="fas fa-chart-line"></i>
                                        Top Products
                                    </button>
                                </div>
                                <div class="filter-button-wrapper">
                                    <span class="filter-button-label">Filter by columns</span>
                                    <button type="button" class="filter-button" onclick="openFilterColumnsModal()">
                                        <i class="fas fa-filter"></i>
                                        Filter Columns
                                    </button>
                                </div>
                                <div class="filter-button-wrapper">
                                    <span class="filter-button-label">&nbsp;</span>
                                    <button type="button" class="filter-button filter-button-refresh filter-button-disabled" onclick="refreshProductFilters()" id="refreshProductFiltersBtn" disabled>
                                        <i class="fas fa-sync-alt"></i>
                                        Refresh Dataset
                                    </button>
                                </div>
                            </div>

                            <!-- Summary Line -->
                            <div class="filter-summary-line" id="productsFilterSummary">
                                <span class="filter-summary-text" id="productsFilterSummaryText">No filters selected</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Products Modal -->
                <div class="modal-overlay hidden" id="topProductsModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-chart-line"></i>
                            </div>
                            <h3 class="modal-header-title">Top Products by Revenue</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Hidden checkbox to maintain state compatibility -->
                            <input type="checkbox" id="enableTopProducts" style="display: none;">

                            <!-- Top Products Configuration (always visible) -->
                            <div id="topProductsConfig">
                                <!-- Row: Product ID, Revenue Column, Analyze Button -->
                                <div class="top-products-config-row">
                                    <div class="top-products-field">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">Product ID Column</label>
                                        <select id="productIdColumn" class="form-select text-sm" onchange="onProductColumnChange()">
                                            <option value="">Select column...</option>
                                        </select>
                                    </div>
                                    <div class="top-products-field">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">Revenue Column</label>
                                        <select id="revenueColumn" class="form-select text-sm" onchange="onRevenueColumnChange()">
                                            <option value="">Select column...</option>
                                        </select>
                                    </div>
                                    <div class="top-products-field top-products-field-btn">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">&nbsp;</label>
                                        <button type="button" id="analyzeProductsBtn" onclick="analyzeProductRevenue()"
                                                class="btn btn-secondary" disabled>
                                            <i class="fas fa-sync-alt mr-2"></i>
                                            Analyze
                                        </button>
                                    </div>
                                </div>

                                <!-- Analysis Results (hidden until analyzed) -->
                                <div id="productAnalysisResults" class="hidden">
                                    <!-- Revenue Distribution Chart -->
                                    <div class="wizard-field-group">
                                        <label class="text-xs font-medium text-gray-600 mb-2 block">Cumulative Revenue Distribution</label>
                                        <div id="revenueChartContainer" class="revenue-chart-container">
                                            <svg id="revenueDistributionChart"></svg>
                                        </div>
                                    </div>

                                    <!-- Threshold Input -->
                                    <div class="wizard-field-group">
                                        <label class="text-xs font-medium text-gray-600 mb-1 block">Revenue Threshold</label>
                                        <div class="flex items-center gap-2">
                                            <span class="text-sm text-gray-600">Include products up to</span>
                                            <input type="number" id="revenueThreshold" value="80" min="1" max="100"
                                                   class="form-input w-20 text-sm" onchange="onThresholdChange()">
                                            <span class="text-sm text-gray-600">% of cumulative revenue</span>
                                        </div>
                                    </div>

                                    <!-- Analysis Summary -->
                                    <div id="productAnalysisSummary" class="analysis-summary-box">
                                        <div class="analysis-summary-header">
                                            <i class="fas fa-chart-pie mr-2"></i>
                                            Analysis Results
                                        </div>
                                        <div class="analysis-summary-content">
                                            <div class="analysis-stat">
                                                <span class="stat-label">Total products:</span>
                                                <span id="totalProductsCount" class="stat-value">-</span>
                                            </div>
                                            <div class="analysis-stat">
                                                <span class="stat-label">Selected products:</span>
                                                <span id="selectedProductsCount" class="stat-value">-</span>
                                                <span id="selectedProductsPercent" class="stat-percent"></span>
                                            </div>
                                            <div class="analysis-stat">
                                                <span class="stat-label">Revenue coverage:</span>
                                                <span id="revenueCoverage" class="stat-value">-</span>
                                                <span id="revenueCoverageAmount" class="stat-amount"></span>
                                            </div>
                                        </div>
                                        <div class="analysis-summary-footer">
                                            <i class="fas fa-info-circle mr-1"></i>
                                            Product list computed dynamically at training time
                                        </div>
                                    </div>
                                </div>

                                <!-- Analysis Error -->
                                <div id="productAnalysisError" class="hidden">
                                    <div class="wizard-info-box error">
                                        <i class="fas fa-exclamation-circle"></i>
                                        <span id="productAnalysisErrorText">Analysis failed</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="applyTopProductsFilter()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Apply</span>
                                </button>
                                <button onclick="closeTopProductsModal()" class="btn-neu btn-neu-action btn-neu-cancel">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Filter Columns Modal -->
                <div class="modal-overlay hidden" id="filterColumnsModal">
                    <div class="modal-container modal-container-lg">
                        <div class="modal-header">
                            <div class="modal-header-icon info">
                                <i class="fas fa-filter"></i>
                            </div>
                            <h3 class="modal-header-title">Filter Columns</h3>
                        </div>
                        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                            <!-- Existing Filters List -->
                            <div id="existingFiltersSection" class="hidden">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Existing Filters</label>
                                <div class="existing-filters-list" id="existingFiltersList">
                                    <!-- Filter items will be inserted here dynamically -->
                                </div>
                                <div class="existing-filters-divider"></div>
                            </div>

                            <!-- Add New Filter Section -->
                            <div id="addFilterSection">
                                <label class="text-xs font-medium text-gray-600 mb-2 block">Add New Filter</label>
                                <div class="add-filter-form-group">
                                    <select id="filterColumnSelect" class="form-select w-full text-sm" onchange="onFilterColumnSelect()">
                                        <option value="">Select column...</option>
                                    </select>
                                </div>

                                <!-- Inline Filter Configuration (appears based on column type) -->
                                <div id="filterConfigContainer" class="hidden">
                                    <!-- Category Filter Config -->
                                    <div id="categoryFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="categoryFilterColumnName" class="filter-config-column-name"></span>
                                            <span class="filter-config-type-badge">STRING</span>
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="category-filter-mode" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="newCategoryMode" value="include" checked>
                                                    Include selected
                                                </label>
                                                <label>
                                                    <input type="radio" name="newCategoryMode" value="exclude">
                                                    Exclude selected
                                                </label>
                                            </div>
                                            <div class="category-filter-values-container" id="newCategoryValuesContainer">
                                                <!-- List mode or autocomplete will be rendered here -->
                                            </div>
                                        </div>
                                        <div class="filter-config-footer">
                                            <button type="button" class="btn btn-primary btn-sm" onclick="addCategoryFilterFromModal()">
                                                Add Filter
                                            </button>
                                        </div>
                                    </div>

                                    <!-- Numeric Filter Config -->
                                    <div id="numericFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="numericFilterColumnName" class="filter-config-column-name"></span>
                                            <span id="numericFilterTypeBadge" class="filter-config-type-badge">INTEGER</span>
                                        </div>
                                        <div class="filter-config-stats" id="numericFilterStats">
                                            <!-- Range: X - Y | Nulls: Z% -->
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="numeric-filter-type" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="newNumericType" value="range" checked onchange="updateNumericFilterInputs()">
                                                    Range
                                                </label>
                                                <label>
                                                    <input type="radio" name="newNumericType" value="equals" onchange="updateNumericFilterInputs()">
                                                    Equals
                                                </label>
                                                <label>
                                                    <input type="radio" name="newNumericType" value="not_equals" onchange="updateNumericFilterInputs()">
                                                    Not Equals
                                                </label>
                                            </div>
                                            <div class="numeric-filter-inputs" id="newNumericInputs">
                                                <div class="numeric-filter-input-group">
                                                    <label class="numeric-filter-input-label">Min</label>
                                                    <input type="number" class="numeric-filter-input" id="newNumericMin" placeholder="">
                                                </div>
                                                <div class="numeric-filter-input-group">
                                                    <label class="numeric-filter-input-label">Max</label>
                                                    <input type="number" class="numeric-filter-input" id="newNumericMax" placeholder="">
                                                </div>
                                            </div>
                                            <div class="numeric-filter-null-handling" id="newNumericNullHandling">
                                                <label>
                                                    <input type="checkbox" id="newNumericIncludeNulls" checked>
                                                    Include NULL values
                                                </label>
                                            </div>
                                        </div>
                                        <div class="filter-config-footer">
                                            <button type="button" class="btn btn-primary btn-sm" onclick="addNumericFilterFromModal()">
                                                Add Filter
                                            </button>
                                        </div>
                                    </div>

                                    <!-- Date Filter Config -->
                                    <div id="dateFilterConfig" class="filter-config-panel hidden">
                                        <div class="filter-config-header">
                                            <span id="dateFilterColumnName" class="filter-config-column-name"></span>
                                            <span class="filter-config-type-badge">DATE</span>
                                        </div>
                                        <div class="filter-config-stats" id="dateFilterStats">
                                            <!-- Range: YYYY-MM-DD - YYYY-MM-DD -->
                                        </div>
                                        <div class="filter-config-body">
                                            <div class="date-filter-type" style="margin-bottom: 12px;">
                                                <label>
                                                    <input type="radio" name="newDateType" value="relative" checked onchange="updateDateFilterInputs()">
                                                    Relative
                                                </label>
                                                <label>
                                                    <input type="radio" name="newDateType" value="range" onchange="updateDateFilterInputs()">
                                                    Date Range
                                                </label>
                                            </div>
                                            <!-- Relative Date Options -->
                                            <div class="date-filter-relative" id="newDateRelativeInputs">
                                                <select id="newDateRelativeOption" class="form-select w-full text-sm">
                                                    <option value="last_7_days">Last 7 days</option>
                                                    <option value="last_30_days" selected>Last 30 days</option>
                                                    <option value="last_90_days">Last 90 days</option>
                                                    <option value="this_month">This month</option>
                                                    <option value="this_quarter">This quarter</option>
                                                    <option value="this_year">This year</option>
                                                </select>
                                            </div>
                                            <!-- Date Range Inputs -->
                                            <div class="date-filter-range hidden" id="newDateRangeInputs">
                                                <div class="date-filter-input-group">
                                                    <label class="date-filter-input-label">Start Date</label>
                                                    <input type="date" class="form-input text-sm" id="newDateStart">
                                                </div>
                                                <div class="date-filter-input-group">
                                                    <label class="date-filter-input-label">End Date</label>
                                                    <input type="date" class="form-input text-sm" id="newDateEnd">
                                                </div>
                                            </div>
                                            <div class="date-filter-null-handling" id="newDateNullHandling" style="margin-top: 12px;">
                                                <label>
                                                    <input type="checkbox" id="newDateIncludeNulls" checked>
                                                    Include NULL values
                                                </label>
                                            </div>
                                        </div>
                                        <div class="filter-config-footer">
                                            <button type="button" class="btn btn-primary btn-sm" onclick="addDateFilterFromModal()">
                                                Add Filter
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer-wizard-neu">
                            <div class="footer-left"></div>
                            <div class="footer-right">
                                <button onclick="closeFilterColumnsModal()" class="btn-neu btn-neu-action btn-neu-save">
                                    <span class="btn-neu-inner">Done</span>
                                </button>
                                <button onclick="closeFilterColumnsModal()" class="btn-neu btn-neu-action btn-neu-secondary">
                                    <span class="btn-neu-inner">Cancel</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Dataset Summary Panel (always expanded) -->
                <div class="dataset-summary-panel" id="datasetSummaryPanel">
                    <div class="dataset-summary-header">
                        <i class="fas fa-chart-bar"></i>
                        <span>Dataset Summary</span>
                        <span class="dataset-summary-total-rows" id="summaryTotalRowsBadge"></span>
                    </div>
                    <div class="dataset-summary-content">
                        <!-- Empty state before refresh -->
                        <div id="datasetSummaryEmpty" class="dataset-summary-empty">
                            <i class="fas fa-info-circle"></i>
                            <span>Loading dataset statistics...</span>
                        </div>

                        <!-- Populated state after refresh -->
                        <div id="datasetSummaryData" class="dataset-summary-data hidden">
                            <!-- Filters Applied Row -->
                            <div class="dataset-filters-applied" id="filtersAppliedSection">
                                <div class="filter-badge" id="filterBadgeDates">
                                    <i class="fas fa-calendar-alt"></i>
                                    <span id="filterBadgeDatesText">All dates</span>
                                </div>
                                <div class="filter-badge" id="filterBadgeCustomers">
                                    <i class="fas fa-users"></i>
                                    <span id="filterBadgeCustomersText">All customers</span>
                                </div>
                                <div class="filter-badge" id="filterBadgeProducts">
                                    <i class="fas fa-box"></i>
                                    <span id="filterBadgeProductsText">All products</span>
                                </div>
                            </div>

                            <!-- Column Stats Table -->
                            <div class="column-stats-table-wrapper">
                                <table class="column-stats-table" id="columnStatsTable">
                                    <thead>
                                        <tr>
                                            <th>Column</th>
                                            <th>Data Type</th>
                                            <th>Statistics</th>
                                        </tr>
                                    </thead>
                                    <tbody id="columnStatsTableBody">
                                        <!-- Populated by JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 5: Train/Eval Split -->
            <div id="step5" class="wizard-step">
                <h4 class="wizard-section-title">Train/Eval Split</h4>
                <p class="wizard-section-subtitle">Configure how to split data for model training and evaluation.</p>

                <!-- Train/Eval Split -->
                <div class="wizard-field-group">
                    <label class="wizard-field-label">Split Strategy</label>
                    <div class="space-y-2">
                        <label class="wizard-selection-card">
                            <input type="radio" name="splitStrategy" value="time_based" checked onchange="onSplitStrategyChange()">
                            <div class="card-content">
                                <div class="card-title">Time-Based Split</div>
                                <div class="card-description">Use last N days for evaluation</div>
                            </div>
                        </label>
                        <label class="wizard-selection-card">
                            <input type="radio" name="splitStrategy" value="random" onchange="onSplitStrategyChange()">
                            <div class="card-content">
                                <div class="card-title">Random Split</div>
                                <div class="card-description">Random percentage for train/eval</div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Time-Based Split Config -->
                <div id="timeBasedConfig" class="wizard-field-group">
                    <label class="text-xs font-medium text-gray-600 mb-1 block">Evaluation Days</label>
                    <select id="evalDays" class="form-select w-full text-sm">
                        <option value="7">Last 7 days for evaluation</option>
                        <option value="14" selected>Last 14 days for evaluation</option>
                        <option value="30">Last 30 days for evaluation</option>
                    </select>
                </div>

                <!-- Random Split Config -->
                <div id="randomSplitConfig" class="wizard-field-group hidden">
                    <label class="text-xs font-medium text-gray-600 mb-1 block">Training Percentage</label>
                    <div class="flex items-center gap-3">
                        <input type="range" id="trainPercent" min="50" max="95" value="80"
                               class="flex-1" oninput="updateTrainPercentLabel()">
                        <span id="trainPercentLabel" class="text-sm font-medium text-gray-700 w-24">80% train</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal Footer (Neumorphic Style) -->
        <div class="modal-footer-wizard-neu">
            <div class="footer-left">
                <button onclick="prevStep()" class="btn-neu btn-neu-nav hidden" id="prevButton">
                    <span class="btn-neu-inner"><i class="fas fa-chevron-left"></i></span>
                </button>
                <button onclick="nextStep()" class="btn-neu btn-neu-nav" id="nextButton" disabled>
                    <span class="btn-neu-inner"><i class="fas fa-chevron-right"></i></span>
                </button>
            </div>
            <div class="footer-right">
                <button onclick="saveDataset()" class="btn-neu btn-neu-action btn-neu-save hidden" id="saveButton">
                    <span class="btn-neu-inner">Save</span>
                </button>
                <button onclick="closeWizard()" class="btn-neu btn-neu-action btn-neu-cancel">
                    <span class="btn-neu-inner">Cancel</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="deleteModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-sm">
        <div class="modal-header">
            <div class="modal-header-icon danger">
                <i class="fas fa-trash-alt"></i>
            </div>
            <h3 class="modal-header-title">Delete Dataset</h3>
        </div>
        <div class="modal-body">
            <p>Are you sure you want to delete "<strong id="deleteDatasetName"></strong>"?</p>
            <p class="text-sm text-gray-500 mt-2">This action cannot be undone.</p>
            <div id="deleteWarning" class="hidden mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                <p class="text-sm text-yellow-800">
                    <i class="fas fa-exclamation-triangle mr-1"></i>
                    This dataset has version history and may have been used in training.
                </p>
            </div>
        </div>
        <div class="modal-footer-wizard-neu">
            <div class="footer-left"></div>
            <div class="footer-right">
                <button onclick="confirmDelete()" class="btn-neu btn-neu-action btn-neu-cancel" id="confirmDeleteBtn">
                    <span class="btn-neu-inner">Delete</span>
                </button>
                <button onclick="closeDeleteModal()" class="btn-neu btn-neu-action btn-neu-secondary">
                    <span class="btn-neu-inner">Cancel</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Dataset Detail Modal -->
<div id="detailModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-lg">
        <div class="modal-header">
            <div class="modal-header-icon info">
                <i class="fas fa-table"></i>
            </div>
            <h3 class="modal-header-title" id="detailModalTitle">Dataset Details</h3>
        </div>
        <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
            <div id="detailContent">
                <p class="text-center text-gray-500 py-8">
                    <i class="fas fa-spinner fa-spin mr-2"></i>Loading...
                </p>
            </div>
        </div>
        <div class="modal-footer-wizard-neu">
            <div class="footer-left"></div>
            <div class="footer-right">
                <button onclick="viewGeneratedQuery()" class="btn-neu btn-neu-action btn-neu-nav-wide">
                    <span class="btn-neu-inner"><i class="fas fa-code mr-1"></i>View SQL</span>
                </button>
                <button onclick="editDatasetFromDetail()" class="btn-neu btn-neu-action btn-neu-save">
                    <span class="btn-neu-inner"><i class="fas fa-edit mr-1"></i>Edit</span>
                </button>
                <button onclick="closeDetailModal()" class="btn-neu btn-neu-action btn-neu-secondary">
                    <span class="btn-neu-inner">Close</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Query Preview Modal -->
<div id="queryModal" class="modal-overlay hidden">
    <div class="modal-container modal-container-lg">
        <div class="modal-header">
            <div class="modal-header-icon info">
                <i class="fas fa-code"></i>
            </div>
            <h3 class="modal-header-title">Generated SQL Query</h3>
        </div>
        <div class="modal-body">
            <div class="mb-3 flex gap-2">
                <button onclick="showQuery('full')" class="btn btn-sm btn-secondary query-tab active" data-tab="full">Full Query</button>
                <button onclick="showQuery('train')" class="btn btn-sm btn-secondary query-tab" data-tab="train">Train Query</button>
                <button onclick="showQuery('eval')" class="btn btn-sm btn-secondary query-tab" data-tab="eval">Eval Query</button>
            </div>
            <pre id="queryContent" class="bg-gray-900 text-green-400 p-4 rounded-lg text-sm overflow-x-auto" style="max-height: 400px;"></pre>
            <div id="queryValidation" class="mt-3 text-sm"></div>
        </div>
        <div class="modal-footer-wizard-neu">
            <div class="footer-left"></div>
            <div class="footer-right">
                <button onclick="copyQuery()" class="btn-neu btn-neu-action btn-neu-nav-wide">
                    <span class="btn-neu-inner"><i class="fas fa-copy mr-1"></i>Copy SQL</span>
                </button>
                <button onclick="closeQueryModal()" class="btn-neu btn-neu-action btn-neu-secondary">
                    <span class="btn-neu-inner">Close</span>
                </button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<!-- D3.js for charts -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// ============================================================================
// GLOBAL STATE
// ============================================================================
const modelId = {{ model.id }};
const csrftoken = document.querySelector('[name=csrfmiddleware-token]')?.value || '{{ csrf_token }}';

let currentWizardStep = 1;
let wizardEditMode = false;
let wizardEditDatasetId = null;
let searchTimeout = null;

// Wizard data state
let wizardData = {
    name: '',
    description: '',
    primaryTable: null,
    secondaryTables: [],
    joinConfig: {},
    selectedColumns: {},
    filters: {},
    splitConfig: {}
};

// Cached data
let availableTables = [];
let tableSchemas = {};
let currentDatasetId = null;
let currentQueries = {};

// Schema Builder State
let schemaBuilderState = {
    sessionId: null,
    tables: {},           // table metadata from load-samples
    selectedColumns: {},  // table -> [columns]
    joins: [],            // [{leftTable, leftCol, rightTable, rightCol, type}]
    connectMode: null,    // {table, column} when awaiting second click
    previewData: null,    // cached preview response
    selectedJoinIndex: null // for join popover
};

// Debounce timer for preview updates
let previewDebounceTimer = null;
const PREVIEW_DEBOUNCE_MS = 300;

// ============================================================================
// PAGE INITIALIZATION
// ============================================================================
document.addEventListener('DOMContentLoaded', function() {
    loadDatasets();
});

// ============================================================================
// DATASET LIST FUNCTIONS
// ============================================================================
function loadDatasets(page = 1) {
    const status = document.getElementById('statusFilter').value;
    const search = document.getElementById('searchInput').value;

    let url = `/api/models/${modelId}/datasets/?page=${page}&per_page=10`;
    if (status) url += `&status=${status}`;
    if (search) url += `&search=${encodeURIComponent(search)}`;

    fetch(url, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            renderDatasetsList(data.datasets);
            renderPagination(data.pagination);
        } else {
            showNotification(data.message || 'Failed to load datasets', 'error');
        }
    })
    .catch(error => {
        console.error('Error loading datasets:', error);
        showNotification('Failed to load datasets', 'error');
    });
}

function renderDatasetsList(datasets) {
    const container = document.getElementById('datasetsList');

    if (!datasets || datasets.length === 0) {
        container.innerHTML = `
            <div class="card-empty-state">
                <p class="card-empty-state-title">No datasets found</p>
                <p class="card-empty-state-text">Create your first dataset to define training data for your ML models</p>
            </div>
        `;
        return;
    }

    container.innerHTML = datasets.map(ds => `
        <div class="card">
            <div class="card-container-5col">
                <!-- Column 1: Dataset Info -->
                <div class="card-content">
                    <div class="card-header">
                        <span class="status-dot ${ds.status === 'active' ? 'green' : 'gray'}"></span>
                        <h4 class="card-title">${escapeHtml(ds.name)}</h4>
                    </div>
                    <div class="card-body">
                        <span class="card-value"><span class="card-label">Primary:</span> ${ds.primary_table ? ds.primary_table.replace('raw_data.', '') : 'Not set'}</span>
                        ${ds.description ? `<span class="card-value text-gray-500 text-xs truncate">${escapeHtml(ds.description.substring(0, 50))}${ds.description.length > 50 ? '...' : ''}</span>` : ''}
                    </div>
                </div>

                <!-- Column 2: Tables & Status -->
                <div class="card-meta-column">
                    <span class="card-label">Tables:</span>
                    <span class="card-schedule-info">${ds.table_count} table${ds.table_count !== 1 ? 's' : ''}</span>
                    <span class="card-label">Status:</span>
                    <span class="card-schedule-info">
                        <span class="px-2 py-0.5 rounded text-xs font-medium ${ds.status === 'active' ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'}">
                            ${ds.status.charAt(0).toUpperCase() + ds.status.slice(1)}
                        </span>
                    </span>
                </div>

                <!-- Column 3: Estimates -->
                <div class="card-meta-column">
                    <span class="card-label">Est. Rows:</span>
                    <span class="card-schedule-info">${ds.row_count_estimate ? formatNumber(ds.row_count_estimate) : ''}</span>
                    <span class="card-label">Users/Products:</span>
                    <span class="card-schedule-info">${ds.unique_users_estimate ? formatNumber(ds.unique_users_estimate) : ''} / ${ds.unique_products_estimate ? formatNumber(ds.unique_products_estimate) : ''}</span>
                </div>

                <!-- Column 4: Actions - Analyze & Activate -->
                <div class="card-run-actions">
                    <button onclick="analyzeDataset(${ds.id})" class="card-action-btn run" title="Analyze dataset">
                        <i class="fas fa-chart-bar"></i>
                    </button>
                    ${ds.status === 'draft' ? `
                    <button onclick="activateDataset(${ds.id})" class="card-action-btn resume-large" title="Activate dataset">
                        <i class="fas fa-check-circle"></i>
                    </button>
                    ` : ''}
                </div>

                <!-- Column 5: Edit & Delete -->
                <div class="card-actions">
                    <button onclick="viewDataset(${ds.id})" class="card-action-btn edit" title="View details">
                        <i class="fas fa-eye"></i>
                    </button>
                    <button onclick="editDataset(${ds.id})" class="card-action-btn edit" title="Edit dataset">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button onclick="deleteDataset(${ds.id}, '${escapeHtml(ds.name)}')" class="card-action-btn delete" title="Delete dataset">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        </div>
    `).join('');
}

function renderPagination(pagination) {
    const container = document.getElementById('paginationContainer');
    const infoEl = document.getElementById('paginationInfo');
    const buttonsEl = document.getElementById('paginationButtons');

    if (pagination.total_pages <= 1) {
        container.classList.add('hidden');
        return;
    }

    container.classList.remove('hidden');

    const start = (pagination.page - 1) * pagination.per_page + 1;
    const end = Math.min(pagination.page * pagination.per_page, pagination.total);
    infoEl.textContent = `Showing ${start}-${end} of ${pagination.total} datasets`;

    let buttons = '';
    if (pagination.has_previous) {
        buttons += `<button onclick="loadDatasets(${pagination.page - 1})" class="btn btn-secondary btn-sm">Previous</button>`;
    }

    for (let i = 1; i <= pagination.total_pages; i++) {
        if (i === pagination.page) {
            buttons += `<button class="btn btn-primary btn-sm">${i}</button>`;
        } else if (i === 1 || i === pagination.total_pages || Math.abs(i - pagination.page) <= 1) {
            buttons += `<button onclick="loadDatasets(${i})" class="btn btn-secondary btn-sm">${i}</button>`;
        } else if (Math.abs(i - pagination.page) === 2) {
            buttons += `<span class="px-2 text-gray-500">...</span>`;
        }
    }

    if (pagination.has_next) {
        buttons += `<button onclick="loadDatasets(${pagination.page + 1})" class="btn btn-secondary btn-sm">Next</button>`;
    }

    buttonsEl.innerHTML = buttons;
}

function refreshDatasets() {
    loadDatasets();
    showNotification('Datasets refreshed', 'success');
}

function filterDatasets() {
    loadDatasets();
}

function debounceSearch() {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => loadDatasets(), 300);
}

// ============================================================================
// WIZARD FUNCTIONS
// ============================================================================
function openWizard(datasetId = null) {
    wizardEditMode = !!datasetId;
    wizardEditDatasetId = datasetId;

    // Reset wizard state
    currentWizardStep = 1;
    wizardData = {
        name: '',
        description: '',
        primaryTable: null,
        secondaryTables: [],
        joinConfig: {},
        selectedColumns: {},
        filters: {},
        splitConfig: {}
    };

    // Update UI
    document.getElementById('wizardTitle').textContent = wizardEditMode ? 'Edit Dataset' : 'Create Dataset';
    document.getElementById('saveButton').querySelector('.btn-neu-inner').textContent = 'Save';

    // Reset form fields
    document.getElementById('datasetName').value = '';
    document.getElementById('datasetDescription').value = '';
    document.getElementById('nameError').classList.add('hidden');
    document.getElementById('nameSuccess').classList.add('hidden');

    // Show modal
    document.getElementById('datasetWizardModal').classList.remove('hidden');

    // Load tables
    loadBqTables();

    // If editing, load dataset data
    if (wizardEditMode) {
        loadDatasetForEdit(datasetId);
    }

    showStep(1);
}

function closeWizard() {
    document.getElementById('datasetWizardModal').classList.add('hidden');
    resetWizard();
}

function resetWizard() {
    currentWizardStep = 1;
    wizardEditMode = false;
    wizardEditDatasetId = null;
    wizardData = {
        name: '',
        description: '',
        primaryTable: null,
        secondaryTables: [],
        joinConfig: {},
        selectedColumns: {},
        filters: {},
        splitConfig: {}
    };

    // Reset schema builder state
    schemaBuilderState = {
        sessionId: null,
        tables: {},
        selectedColumns: {},
        joins: [],
        connectMode: null,
        previewData: null,
        selectedJoinIndex: null
    };

    // Reset card positions
    cardPositions = {};

    // Reset product analysis state
    productAnalysisData = null;

    // Reset filter UI elements
    const timestampSelect = document.getElementById('timestampColumn');
    if (timestampSelect) timestampSelect.selectedIndex = 0;

    const productSelect = document.getElementById('productIdColumn');
    if (productSelect) productSelect.selectedIndex = 0;

    const revenueSelect = document.getElementById('revenueColumn');
    if (revenueSelect) revenueSelect.selectedIndex = 0;

    const rollingDaysInput = document.getElementById('rollingDays');
    if (rollingDaysInput) rollingDaysInput.value = 30;

    const thresholdInput = document.getElementById('revenueThreshold');
    if (thresholdInput) thresholdInput.value = 80;

    // Reset sub-chapter summaries
    const historySummary = document.getElementById('historySummary');
    if (historySummary) historySummary.textContent = 'Last 30 days';

    const productsSummary = document.getElementById('productsSummary');
    if (productsSummary) productsSummary.textContent = 'All products included';

    const advancedSummary = document.getElementById('advancedSummary');
    if (advancedSummary) advancedSummary.textContent = 'No filters';

    // Hide analysis results
    const analysisResults = document.getElementById('productAnalysisResults');
    if (analysisResults) analysisResults.classList.add('hidden');

    const analysisError = document.getElementById('productAnalysisError');
    if (analysisError) analysisError.classList.add('hidden');

    // Clear chart
    const svg = document.getElementById('revenueDistributionChart');
    if (svg) svg.innerHTML = '';
}

function showStep(step) {
    // Hide all steps
    document.querySelectorAll('.wizard-step').forEach(s => s.classList.remove('active'));

    // Show target step
    document.getElementById(`step${step}`).classList.add('active');

    // Update step counter
    document.getElementById('currentStep').textContent = step;

    // Update progress bar - pill style classes
    for (let i = 1; i <= 5; i++) {
        const pill = document.getElementById(`progress${i}`);
        pill.classList.remove('current', 'completed', 'future');
        if (i < step) {
            pill.classList.add('completed');
        } else if (i === step) {
            pill.classList.add('current');
        } else {
            pill.classList.add('future');
        }
    }

    // Update navigation buttons
    updateNavigationButtons(step);

    currentWizardStep = step;
}

function updateNavigationButtons(step) {
    const prevBtn = document.getElementById('prevButton');
    const nextBtn = document.getElementById('nextButton');
    const saveBtn = document.getElementById('saveButton');

    // Previous button
    if (step > 1) {
        prevBtn.classList.remove('hidden');
    } else {
        prevBtn.classList.add('hidden');
    }

    // Next/Save buttons
    if (step === 5) {
        nextBtn.classList.add('hidden');
        saveBtn.classList.remove('hidden');
    } else {
        nextBtn.classList.remove('hidden');
        saveBtn.classList.add('hidden');
    }

    // Enable/disable next based on validation
    validateCurrentStep();
}

function validateCurrentStep() {
    const nextBtn = document.getElementById('nextButton');
    const saveBtn = document.getElementById('saveButton');
    let isValid = false;

    switch (currentWizardStep) {
        case 1:
            const name = document.getElementById('datasetName').value.trim();
            isValid = name.length > 0;
            break;
        case 2:
            isValid = wizardData.primaryTable !== null;
            break;
        case 3:
            // At least one column must be selected (schema builder)
            const hasSelectedColumns = Object.values(schemaBuilderState.selectedColumns)
                .some(cols => cols && cols.length > 0);
            isValid = hasSelectedColumns;
            break;
        case 4:
            // Step 4 validation:
            // - Timestamp column must be selected (Define History)
            // - Product ID and Revenue columns must be selected (Select Products)
            // - Product analysis must have been run successfully
            const timestampCol = document.getElementById('timestampColumn')?.value;
            const productCol = document.getElementById('productIdColumn')?.value;
            const revenueCol = document.getElementById('revenueColumn')?.value;

            // All required columns must be selected and analysis must be successful
            isValid = timestampCol && productCol && revenueCol && productAnalysisData && productAnalysisData.status === 'success';
            break;
        case 5:
            isValid = true; // Split config has defaults
            break;
    }

    nextBtn.disabled = !isValid;
    saveBtn.disabled = !isValid;
}

function nextStep() {
    if (currentWizardStep >= 5) return;

    // Collect data from current step
    collectStepData(currentWizardStep);

    // Perform step-specific actions
    if (currentWizardStep === 1) {
        // Moving to step 2 - tables should already be loaded
    } else if (currentWizardStep === 2) {
        // Moving to step 3 - load schema builder with samples
        loadSchemaBuilder();
    } else if (currentWizardStep === 3) {
        // Moving to step 4 - collect columns and joins from schema builder
        collectSchemaBuilderData();
        // Populate filter dropdowns with selected columns
        populateFilterColumnDropdowns();
        // Fetch initial dataset stats (unfiltered) for the Dataset Summary panel
        fetchDatasetStats(false);
    }

    showStep(currentWizardStep + 1);
}

function prevStep() {
    if (currentWizardStep <= 1) return;
    collectStepData(currentWizardStep);
    showStep(currentWizardStep - 1);
}

function collectStepData(step) {
    switch (step) {
        case 1:
            wizardData.name = document.getElementById('datasetName').value.trim();
            wizardData.description = document.getElementById('datasetDescription').value.trim();
            break;
        case 2:
            // Primary and secondary tables already tracked via selection
            break;
        case 3:
            // Schema builder data is collected via collectSchemaBuilderData()
            break;
        case 4:
            // Data Filters - New structure with sub-chapters

            // History filter (rolling window)
            const timestampCol = document.getElementById('timestampColumn')?.value;
            const rollingDays = parseInt(document.getElementById('rollingDays')?.value) || 30;

            if (timestampCol) {
                wizardData.filters.history = {
                    timestamp_column: timestampCol,
                    rolling_days: rollingDays
                };
            }

            // Products filter
            const productCol = document.getElementById('productIdColumn')?.value;
            const revenueCol = document.getElementById('revenueColumn')?.value;
            const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

            if (productCol && revenueCol && productAnalysisData) {
                wizardData.filters.products = {
                    product_column: productCol,
                    revenue_column: revenueCol,
                    threshold_type: 'cumulative_revenue',
                    threshold_percent: threshold,
                    cached_analysis: {
                        analyzed_at: new Date().toISOString(),
                        total_products: productAnalysisData.total_products,
                        selected_products: productAnalysisData.thresholds?.[String(threshold)]?.products ||
                            productAnalysisData.thresholds?.['80']?.products,
                        total_revenue: productAnalysisData.total_revenue,
                        selected_revenue: productAnalysisData.total_revenue * threshold / 100
                    }
                };
            }

            // Customer filter (advanced)
            if (document.getElementById('enableMinTransactions')?.checked) {
                wizardData.filters.customer_filter = {
                    type: 'min_transactions',
                    value: parseInt(document.getElementById('minTransactions').value)
                };
            }
            break;
        case 5:
            // Train/Eval Split config
            const splitStrategy = document.querySelector('input[name="splitStrategy"]:checked')?.value;
            if (splitStrategy === 'time_based') {
                wizardData.splitConfig = {
                    strategy: 'time_based',
                    eval_days: parseInt(document.getElementById('evalDays').value)
                };
            } else if (splitStrategy === 'random') {
                wizardData.splitConfig = {
                    strategy: 'random',
                    train_percent: parseInt(document.getElementById('trainPercent').value)
                };
            }
            break;
    }
}

// ============================================================================
// STEP 1: NAME VALIDATION
// ============================================================================
let nameCheckTimeout = null;

function validateDatasetName() {
    const name = document.getElementById('datasetName').value.trim();
    const errorEl = document.getElementById('nameError');
    const successEl = document.getElementById('nameSuccess');

    errorEl.classList.add('hidden');
    successEl.classList.add('hidden');

    if (!name) {
        validateCurrentStep();
        return;
    }

    // Debounce the API call
    clearTimeout(nameCheckTimeout);
    nameCheckTimeout = setTimeout(() => {
        fetch(`/api/models/${modelId}/datasets/check-name/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                name: name,
                exclude_id: wizardEditDatasetId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.available) {
                successEl.classList.remove('hidden');
            } else {
                errorEl.textContent = data.message || 'Name already exists';
                errorEl.classList.remove('hidden');
            }
            validateCurrentStep();
        })
        .catch(error => {
            console.error('Error checking name:', error);
        });
    }, 300);

    validateCurrentStep();
}

// ============================================================================
// STEP 2: TABLE SELECTION
// ============================================================================
function loadBqTables() {
    fetch(`/api/models/${modelId}/bq-tables/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            availableTables = data.tables;
            renderPrimaryTableList();
        } else {
            showNotification(data.message || 'Failed to load tables', 'error');
        }
    })
    .catch(error => {
        console.error('Error loading tables:', error);
        document.getElementById('primaryTableList').innerHTML = `
            <p class="text-center text-red-500 py-4">
                <i class="fas fa-exclamation-circle mr-2"></i>Failed to load tables
            </p>
        `;
    });
}

function renderPrimaryTableList() {
    const container = document.getElementById('primaryTableList');

    if (!availableTables || availableTables.length === 0) {
        container.innerHTML = `
            <p class="text-center text-gray-500 py-4">
                No tables found in raw_data dataset.<br>
                <span class="text-sm">Run an ETL job first to populate data.</span>
            </p>
        `;
        return;
    }

    container.innerHTML = availableTables.map(table => `
        <label class="wizard-selection-card mb-2 ${wizardData.primaryTable === table.full_name ? 'selected' : ''}">
            <input type="radio" name="primaryTable" value="${table.full_name}"
                   ${wizardData.primaryTable === table.full_name ? 'checked' : ''}
                   onchange="onPrimaryTableSelect('${table.full_name}')">
            <div class="card-content">
                <div class="card-title">${table.table_id}</div>
                <div class="card-description">
                    ${formatNumber(table.row_count)} rows | ${table.column_count} columns | ${formatBytes(table.size_bytes)}
                </div>
            </div>
        </label>
    `).join('');
}

function onPrimaryTableSelect(tableName) {
    wizardData.primaryTable = tableName;

    // Update selection styling
    document.querySelectorAll('#primaryTableList .wizard-selection-card').forEach(card => {
        card.classList.remove('selected');
    });
    document.querySelector(`#primaryTableList input[value="${tableName}"]`)?.closest('.wizard-selection-card')?.classList.add('selected');

    // Update secondary tables list
    renderSecondaryTableList();

    // Load schema for primary table
    loadTableSchema(tableName);

    validateCurrentStep();
}

function renderSecondaryTableList() {
    const container = document.getElementById('secondaryTableList');

    const otherTables = availableTables.filter(t => t.full_name !== wizardData.primaryTable);

    if (otherTables.length === 0) {
        container.innerHTML = `<p class="text-center text-gray-500 py-4">No additional tables available</p>`;
        return;
    }

    container.innerHTML = otherTables.map(table => `
        <label class="wizard-selection-card mb-2 ${wizardData.secondaryTables.includes(table.full_name) ? 'selected' : ''}">
            <input type="checkbox" value="${table.full_name}"
                   ${wizardData.secondaryTables.includes(table.full_name) ? 'checked' : ''}
                   onchange="onSecondaryTableToggle('${table.full_name}', this.checked)">
            <div class="card-content">
                <div class="card-title">${table.table_id}</div>
                <div class="card-description">
                    ${formatNumber(table.row_count)} rows | ${table.column_count} columns
                </div>
            </div>
        </label>
    `).join('');
}

function onSecondaryTableToggle(tableName, isChecked) {
    if (isChecked) {
        if (!wizardData.secondaryTables.includes(tableName)) {
            wizardData.secondaryTables.push(tableName);
            loadTableSchema(tableName);
        }
    } else {
        wizardData.secondaryTables = wizardData.secondaryTables.filter(t => t !== tableName);
        delete wizardData.joinConfig[tableName];
    }

    // Update selection styling
    const card = document.querySelector(`#secondaryTableList input[value="${tableName}"]`)?.closest('.wizard-selection-card');
    if (card) {
        card.classList.toggle('selected', isChecked);
    }

    // Show/hide join config section
    const joinSection = document.getElementById('joinConfigSection');
    if (wizardData.secondaryTables.length > 0) {
        joinSection.classList.remove('hidden');
        renderJoinConfig();
    } else {
        joinSection.classList.add('hidden');
    }
}

function renderJoinConfig() {
    const container = document.getElementById('joinConfigList');

    container.innerHTML = wizardData.secondaryTables.map(tableName => {
        const shortName = tableName.replace('raw_data.', '');
        const config = wizardData.joinConfig[tableName] || {};
        const primarySchema = tableSchemas[wizardData.primaryTable] || [];
        const secondarySchema = tableSchemas[tableName] || [];

        return `
            <div class="p-3 border border-gray-200 rounded-lg bg-gray-50">
                <div class="font-medium text-sm mb-2">${shortName}</div>
                <div class="grid grid-cols-3 gap-2">
                    <div>
                        <label class="text-xs text-gray-600">Primary Key</label>
                        <select class="form-select w-full text-xs" onchange="updateJoinConfig('${tableName}', 'primary_key', this.value)">
                            <option value="">Select...</option>
                            ${primarySchema.map(col => `<option value="${col.name}" ${config.primary_key === col.name ? 'selected' : ''}>${col.name}</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label class="text-xs text-gray-600">Join Key</label>
                        <select class="form-select w-full text-xs" onchange="updateJoinConfig('${tableName}', 'join_key', this.value)">
                            <option value="">Select...</option>
                            ${secondarySchema.map(col => `<option value="${col.name}" ${config.join_key === col.name ? 'selected' : ''}>${col.name}</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label class="text-xs text-gray-600">Join Type</label>
                        <select class="form-select w-full text-xs" onchange="updateJoinConfig('${tableName}', 'join_type', this.value)">
                            <option value="LEFT" ${config.join_type === 'LEFT' ? 'selected' : ''}>LEFT JOIN</option>
                            <option value="INNER" ${config.join_type === 'INNER' ? 'selected' : ''}>INNER JOIN</option>
                        </select>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

function updateJoinConfig(tableName, field, value) {
    if (!wizardData.joinConfig[tableName]) {
        wizardData.joinConfig[tableName] = { join_type: 'LEFT' };
    }
    wizardData.joinConfig[tableName][field] = value;
}

function detectJoins() {
    const tables = [wizardData.primaryTable, ...wizardData.secondaryTables];

    fetch(`/api/models/${modelId}/detect-joins/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({ tables: tables })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success' && data.detected_joins) {
            // Apply detected joins
            data.detected_joins.forEach(join => {
                if (wizardData.secondaryTables.includes(join.table2)) {
                    wizardData.joinConfig[join.table2] = {
                        primary_key: join.column1,
                        join_key: join.column2,
                        join_type: 'LEFT'
                    };
                }
            });
            renderJoinConfig();
            showNotification('Joins detected successfully', 'success');
        } else {
            showNotification('No obvious joins detected. Please configure manually.', 'warning');
        }
    })
    .catch(error => {
        console.error('Error detecting joins:', error);
        showNotification('Failed to detect joins', 'error');
    });
}

function loadTableSchema(tableName) {
    if (tableSchemas[tableName]) return; // Already loaded

    fetch(`/api/models/${modelId}/bq-tables/${encodeURIComponent(tableName.replace('raw_data.', ''))}/schema/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            tableSchemas[tableName] = data.schema;
            // Re-render join config if needed
            if (wizardData.secondaryTables.length > 0) {
                renderJoinConfig();
            }
        }
    })
    .catch(error => {
        console.error('Error loading schema:', error);
    });
}

// ============================================================================
// STEP 3: VISUAL SCHEMA BUILDER
// ============================================================================

function loadSchemaBuilder() {
    const allTables = [wizardData.primaryTable, ...wizardData.secondaryTables].filter(Boolean);

    if (allTables.length === 0) {
        document.getElementById('schemaLoading').innerHTML = 'No tables selected. Go back to Step 2.';
        return;
    }

    // Show loading state
    document.getElementById('schemaLoading').style.display = 'flex';
    document.getElementById('schemaCardsContainer').innerHTML = `
        <div class="schema-loading" id="schemaLoading">
            <i class="fas fa-spinner fa-spin"></i>
            Loading table samples...
        </div>
    `;

    // Reset schema builder state
    schemaBuilderState = {
        sessionId: null,
        tables: {},
        selectedColumns: {},
        joins: [],
        connectMode: null,
        previewData: null,
        selectedJoinIndex: null
    };

    // Load samples from backend
    fetch(`/api/models/${modelId}/datasets/load-samples/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({ tables: allTables })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            schemaBuilderState.sessionId = data.session_id;
            schemaBuilderState.tables = data.tables;

            // Initialize selected columns (all by default)
            Object.keys(data.tables).forEach(table => {
                const columns = data.tables[table].columns || [];
                schemaBuilderState.selectedColumns[table] = columns.map(c => c.name);
            });

            // Render table cards
            renderTableCards();

            // Refresh preview
            refreshPreview();
        } else {
            document.getElementById('schemaCardsContainer').innerHTML = `
                <div class="schema-preview-empty">
                    <i class="fas fa-exclamation-triangle"></i>
                    Error loading samples: ${data.message}
                </div>
            `;
        }
    })
    .catch(error => {
        console.error('Error loading schema builder:', error);
        document.getElementById('schemaCardsContainer').innerHTML = `
            <div class="schema-preview-empty">
                <i class="fas fa-exclamation-triangle"></i>
                Failed to load table samples
            </div>
        `;
    });
}

// Store card positions
let cardPositions = {};

function renderTableCards() {
    const container = document.getElementById('schemaCardsContainer');
    const allTables = [wizardData.primaryTable, ...wizardData.secondaryTables].filter(Boolean);

    let html = '';

    allTables.forEach((table, index) => {
        const tableData = schemaBuilderState.tables[table] || {};
        const columns = tableData.columns || [];
        const isPrimary = index === 0;
        const shortName = table.replace('raw_data.', '');
        const selectedCols = schemaBuilderState.selectedColumns[table] || [];
        const showLimit = 10;
        const hasMore = columns.length > showLimit;

        html += `
            <div class="schema-table-card ${isPrimary ? 'primary' : ''}" data-table="${table}" id="card_${shortName}">
                <div class="schema-card-header" onmousedown="startDrag(event, '${table}')">
                    <div class="schema-card-title">
                        <i class="fas fa-table"></i>
                        ${shortName}
                    </div>
                    <span class="schema-card-badge ${isPrimary ? 'primary' : 'secondary'}">
                        ${isPrimary ? 'Primary' : 'Secondary'}
                    </span>
                </div>
                <div class="schema-column-list ${hasMore ? 'collapsed' : ''}" id="columnList_${shortName}">
                    ${columns.slice(0, showLimit).map(col => renderColumnItem(table, col, selectedCols, isPrimary)).join('')}
                </div>
                ${hasMore ? `
                    <div class="schema-column-expander" id="expander_${shortName}" onclick="toggleColumnExpander('${table}', '${shortName}')">
                        Show ${columns.length - showLimit} more...
                    </div>
                ` : ''}
            </div>
        `;
    });

    container.innerHTML = html;

    // Position cards: primary in center, secondary around it
    positionCardsInitially(allTables);

    // Setup drag handlers
    setupDragHandlers();

    // Setup scroll handlers for column lists to update connection lines
    setupColumnScrollHandlers();

    // Update connection lines after a short delay to ensure cards are positioned
    setTimeout(updateConnectionLines, 50);
}

// Setup scroll event listeners on column lists to update connection lines when scrolling
function setupColumnScrollHandlers() {
    document.querySelectorAll('.schema-column-list').forEach(list => {
        list.addEventListener('scroll', () => {
            updateConnectionLines();
        });
    });
}

function positionCardsInitially(allTables) {
    const container = document.getElementById('schemaCardsContainer');
    const containerRect = container.getBoundingClientRect();

    // Use fixed dimensions based on CSS if container not yet sized
    const containerWidth = Math.max(containerRect.width, 900);
    const containerHeight = Math.max(containerRect.height, 300);

    const cardWidth = 220;
    const cardHeight = 220; // Approximate card height

    // Calculate positions for all tables first
    const numTables = allTables.length;

    allTables.forEach((table, index) => {
        const shortName = table.replace('raw_data.', '');
        const card = document.getElementById(`card_${shortName}`);
        if (!card) return;

        let x, y;

        // Check if we have saved positions
        if (cardPositions[table]) {
            x = cardPositions[table].x;
            y = cardPositions[table].y;
        } else if (index === 0) {
            // Primary table: center of container
            x = (containerWidth - cardWidth) / 2;
            y = (containerHeight - cardHeight) / 2;
        } else {
            // Secondary tables: position to the left and right of primary
            const numSecondary = numTables - 1;

            if (numSecondary === 1) {
                // Single secondary: place to the right
                x = (containerWidth / 2) + cardWidth / 2 + 80;
                y = (containerHeight - cardHeight) / 2;
            } else if (numSecondary === 2) {
                // Two secondaries: one left, one right
                if (index === 1) {
                    x = (containerWidth / 2) - cardWidth - 80;
                    y = (containerHeight - cardHeight) / 2;
                } else {
                    x = (containerWidth / 2) + cardWidth / 2 + 80;
                    y = (containerHeight - cardHeight) / 2;
                }
            } else {
                // Multiple secondaries: distribute around the primary
                const angle = ((index - 1) / numSecondary) * Math.PI * 2 - Math.PI / 2;
                const radiusX = containerWidth * 0.35;
                const radiusY = containerHeight * 0.30;

                const centerX = containerWidth / 2;
                const centerY = containerHeight / 2;

                x = centerX + Math.cos(angle) * radiusX - cardWidth / 2;
                y = centerY + Math.sin(angle) * radiusY - cardHeight / 2;
            }

            // Keep within bounds
            x = Math.max(10, Math.min(x, containerWidth - cardWidth - 10));
            y = Math.max(10, Math.min(y, containerHeight - cardHeight - 10));
        }

        card.style.left = x + 'px';
        card.style.top = y + 'px';

        // Save position
        cardPositions[table] = { x, y };
    });
}

// Drag state
let dragState = {
    isDragging: false,
    table: null,
    startX: 0,
    startY: 0,
    cardStartX: 0,
    cardStartY: 0
};

function setupDragHandlers() {
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);
}

function startDrag(event, table) {
    // Don't start drag if clicking on checkbox or other interactive elements
    if (event.target.tagName === 'INPUT' || event.target.closest('.schema-connection-dot')) {
        return;
    }

    event.preventDefault();

    const shortName = table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    if (!card) return;

    dragState = {
        isDragging: true,
        table: table,
        startX: event.clientX,
        startY: event.clientY,
        cardStartX: parseInt(card.style.left) || 0,
        cardStartY: parseInt(card.style.top) || 0
    };

    card.classList.add('dragging');
}

function onDragMove(event) {
    if (!dragState.isDragging) return;

    const shortName = dragState.table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    if (!card) return;

    const container = document.getElementById('schemaCardsContainer');
    const containerRect = container.getBoundingClientRect();

    const deltaX = event.clientX - dragState.startX;
    const deltaY = event.clientY - dragState.startY;

    let newX = dragState.cardStartX + deltaX;
    let newY = dragState.cardStartY + deltaY;

    // Keep within container bounds
    const cardRect = card.getBoundingClientRect();
    const maxX = containerRect.width - cardRect.width;
    const maxY = containerRect.height - cardRect.height;

    newX = Math.max(0, Math.min(newX, maxX));
    newY = Math.max(0, Math.min(newY, maxY));

    card.style.left = newX + 'px';
    card.style.top = newY + 'px';

    // Save position
    cardPositions[dragState.table] = { x: newX, y: newY };

    // Update connection lines while dragging
    updateConnectionLines();
}

function onDragEnd(event) {
    if (!dragState.isDragging) return;

    const shortName = dragState.table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    if (card) {
        card.classList.remove('dragging');
    }

    dragState.isDragging = false;
    dragState.table = null;

    // Final update of connection lines
    updateConnectionLines();
}

function renderColumnItem(table, col, selectedCols, isPrimary) {
    const shortTable = table.replace('raw_data.', '');
    const isSelected = selectedCols.includes(col.name);

    // Determine if column is a recommended join key based on schema flag OR naming patterns
    const colLower = col.name.toLowerCase();
    const keyPatterns = ['_id', 'id_', '_key', 'key_', '_code', 'code_'];
    const isRecommendedJoinKey = col.is_potential_join_key ||
                      keyPatterns.some(p => colLower.includes(p)) ||
                      colLower === 'id';

    const isConnected = schemaBuilderState.joins.some(j =>
        (j.leftCol === col.name && wizardData.primaryTable === table) ||
        (j.rightCol === col.name && j.rightTable === table)
    );

    // Determine what to show in the connection area:
    // - Connected: colored dot (always visible)
    // - Recommended but not connected: empty dot (always visible)
    // - Not recommended and not connected: "+" on hover
    let connectionElement;
    if (isConnected) {
        // Connected column - show colored dot
        connectionElement = `
            <div class="schema-connection-dot connected"
                 data-table="${table}" data-column="${col.name}"
                 onclick="onConnectionDotClick('${table}', '${col.name}', event)"></div>
        `;
    } else if (isRecommendedJoinKey) {
        // Recommended join key - show empty dot
        connectionElement = `
            <div class="schema-connection-dot recommended"
                 data-table="${table}" data-column="${col.name}"
                 onclick="onConnectionDotClick('${table}', '${col.name}', event)"></div>
        `;
    } else {
        // Regular column - show "+" on hover
        connectionElement = `
            <div class="schema-connection-plus"
                 data-table="${table}" data-column="${col.name}"
                 onclick="onConnectionDotClick('${table}', '${col.name}', event)">+</div>
        `;
    }

    return `
        <div class="schema-column-item ${isConnected ? 'connected' : ''}" data-table="${table}" data-column="${col.name}"
             data-type="${col.type || 'unknown'}">
            <input type="checkbox" ${isSelected ? 'checked' : ''}
                   onchange="onColumnCheckChange('${table}', '${col.name}', this.checked)">
            <span class="schema-column-name">${col.name}</span>
            <span class="schema-column-type">${col.type?.substring(0, 3)?.toLowerCase() || ''}</span>
            ${connectionElement}
        </div>
    `;
}

function toggleColumnExpander(table, shortName) {
    const columnList = document.getElementById(`columnList_${shortName}`);
    const expander = document.getElementById(`expander_${shortName}`);
    const tableData = schemaBuilderState.tables[table] || {};
    const columns = tableData.columns || [];
    const selectedCols = schemaBuilderState.selectedColumns[table] || [];
    const isPrimary = table === wizardData.primaryTable;

    if (columnList.classList.contains('collapsed')) {
        // Expand - show all columns
        columnList.classList.remove('collapsed');
        columnList.innerHTML = columns.map(col => renderColumnItem(table, col, selectedCols, isPrimary)).join('');
        expander.textContent = 'Show less';
    } else {
        // Collapse - show first 10
        columnList.classList.add('collapsed');
        columnList.innerHTML = columns.slice(0, 10).map(col => renderColumnItem(table, col, selectedCols, isPrimary)).join('');
        expander.textContent = `Show ${columns.length - 10} more...`;
    }

    updateConnectionLines();
}

function onColumnCheckChange(table, column, isChecked) {
    if (!schemaBuilderState.selectedColumns[table]) {
        schemaBuilderState.selectedColumns[table] = [];
    }

    if (isChecked) {
        if (!schemaBuilderState.selectedColumns[table].includes(column)) {
            schemaBuilderState.selectedColumns[table].push(column);
        }
    } else {
        schemaBuilderState.selectedColumns[table] = schemaBuilderState.selectedColumns[table].filter(c => c !== column);
    }

    validateCurrentStep();
    debouncedRefreshPreview();
}

// Connection dot/plus click handling
function onConnectionDotClick(table, column, event) {
    // Get click position for popover
    const clickX = event ? event.clientX : 0;
    const clickY = event ? event.clientY : 0;

    const connectMode = schemaBuilderState.connectMode;

    if (!connectMode) {
        // Start connect mode
        schemaBuilderState.connectMode = { table, column };

        // Show source column info popover
        showColumnInfoPopover(table, column, clickX, clickY, true);

        // Highlight source element and valid targets
        highlightConnectModeElements(table, column);

        // Add event listeners for cancel actions
        document.addEventListener('keydown', handleConnectModeKeydown);
        document.addEventListener('click', handleConnectModeOutsideClick, true);

    } else {
        // Complete or cancel connection
        if (connectMode.table === table && connectMode.column === column) {
            // Clicked same element - cancel
            exitConnectMode();
        } else if (connectMode.table !== table) {
            // Valid target - create join
            createJoin(connectMode.table, connectMode.column, table, column);
            exitConnectMode();
        }
        // If same table but different column - ignore
    }
}

// Highlight elements during connect mode
function highlightConnectModeElements(sourceTable, sourceColumn) {
    // Highlight source dot/plus
    document.querySelectorAll('.schema-connection-dot, .schema-connection-plus').forEach(el => {
        if (el.dataset.table === sourceTable && el.dataset.column === sourceColumn) {
            el.classList.add('connect-mode');
        } else if (el.dataset.table !== sourceTable) {
            // Highlight valid targets (different table)
            el.classList.add('connect-mode-target');
        }
    });

    // Add hover listeners for target columns
    document.querySelectorAll('.schema-column-item').forEach(item => {
        if (item.dataset.table !== sourceTable) {
            item.addEventListener('mouseenter', handleTargetColumnHover);
            item.addEventListener('mouseleave', handleTargetColumnLeave);
        }
    });
}

// Handle hover on target column during connect mode
function handleTargetColumnHover(event) {
    const item = event.currentTarget;
    const table = item.dataset.table;
    const column = item.dataset.column;

    if (!schemaBuilderState.connectMode || table === schemaBuilderState.connectMode.table) {
        return;
    }

    // Get column type for compatibility check
    const sourceType = getColumnType(schemaBuilderState.connectMode.table, schemaBuilderState.connectMode.column);
    const targetType = getColumnType(table, column);
    const isCompatible = checkTypeCompatibility(sourceType, targetType);

    // Show target popover near cursor
    showColumnInfoPopover(table, column, event.clientX + 15, event.clientY + 15, false, sourceType, isCompatible);
}

// Handle mouse leave on target column
function handleTargetColumnLeave(event) {
    // Hide target info but keep source info
    if (schemaBuilderState.connectMode) {
        const popover = document.getElementById('columnInfoPopover');
        // Reset to source info
        showColumnInfoPopover(
            schemaBuilderState.connectMode.table,
            schemaBuilderState.connectMode.column,
            parseInt(popover.style.left),
            parseInt(popover.style.top),
            true
        );
    }
}

// Get column type from state
function getColumnType(table, column) {
    const tableData = schemaBuilderState.tables[table];
    if (!tableData || !tableData.columns) return 'unknown';

    const col = tableData.columns.find(c => c.name === column);
    return col ? col.type : 'unknown';
}

// Get sample values for a column
function getColumnSamples(table, column) {
    const tableData = schemaBuilderState.tables[table];
    if (!tableData || !tableData.sample_preview) return [];

    return tableData.sample_preview
        .map(row => row[column])
        .filter(v => v !== null && v !== undefined)
        .slice(0, 5);
}

// Format sample values for display
function formatSampleValues(samples) {
    if (!samples || samples.length === 0) return 'No samples';

    return samples.map(v => {
        if (typeof v === 'string') {
            // Truncate long strings
            return v.length > 15 ? `"${v.substring(0, 15)}..."` : `"${v}"`;
        }
        return String(v);
    }).join(', ');
}

// Check if two types are compatible for joining
function checkTypeCompatibility(type1, type2) {
    if (!type1 || !type2 || type1 === 'unknown' || type2 === 'unknown') {
        return true; // Allow if unknown
    }

    // Normalize types
    const normalize = (t) => {
        t = t.toUpperCase();
        if (t.includes('INT')) return 'INTEGER';
        if (t.includes('FLOAT') || t.includes('NUMERIC') || t.includes('DECIMAL')) return 'NUMERIC';
        if (t.includes('STRING') || t.includes('VARCHAR') || t.includes('CHAR')) return 'STRING';
        if (t.includes('DATE') || t.includes('TIME')) return 'DATETIME';
        if (t.includes('BOOL')) return 'BOOLEAN';
        return t;
    };

    const n1 = normalize(type1);
    const n2 = normalize(type2);

    // Same normalized type
    if (n1 === n2) return true;

    // Numeric types can join together
    if ((n1 === 'INTEGER' || n1 === 'NUMERIC') && (n2 === 'INTEGER' || n2 === 'NUMERIC')) {
        return true;
    }

    return false;
}

// Show column info popover
function showColumnInfoPopover(table, column, x, y, isSource, sourceType = null, isCompatible = true) {
    const popover = document.getElementById('columnInfoPopover');
    const type = getColumnType(table, column);
    const samples = getColumnSamples(table, column);

    // Update popover content
    document.getElementById('columnInfoName').textContent = column;
    document.getElementById('columnInfoTypeValue').textContent = type || 'unknown';
    document.getElementById('columnInfoSamplesValue').textContent = formatSampleValues(samples);

    // Show/hide hint, warning, compatible messages
    const hintEl = document.getElementById('columnInfoHint');
    const warningEl = document.getElementById('columnInfoWarning');
    const compatibleEl = document.getElementById('columnInfoCompatible');

    if (isSource) {
        hintEl.classList.remove('hidden');
        warningEl.classList.add('hidden');
        compatibleEl.classList.add('hidden');
    } else {
        hintEl.classList.add('hidden');

        if (!isCompatible) {
            warningEl.classList.remove('hidden');
            compatibleEl.classList.add('hidden');
            document.getElementById('columnInfoWarningText').textContent =
                `Type mismatch: ${sourceType}  ${type}`;
        } else {
            warningEl.classList.add('hidden');
            compatibleEl.classList.remove('hidden');
        }
    }

    // Position popover
    popover.style.left = `${x + 10}px`;
    popover.style.top = `${y + 10}px`;

    // Ensure popover stays within viewport
    const rect = popover.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    if (rect.right > viewportWidth) {
        popover.style.left = `${x - rect.width - 10}px`;
    }
    if (rect.bottom > viewportHeight) {
        popover.style.top = `${y - rect.height - 10}px`;
    }

    popover.classList.remove('hidden');
}

// Hide column info popover
function hideColumnInfoPopover() {
    document.getElementById('columnInfoPopover').classList.add('hidden');
}

// Handle Escape key to cancel connect mode
function handleConnectModeKeydown(event) {
    if (event.key === 'Escape') {
        exitConnectMode();
    }
}

// Handle click outside to cancel connect mode
function handleConnectModeOutsideClick(event) {
    // Check if click is on a connection element
    const isConnectionElement = event.target.closest('.schema-connection-dot, .schema-connection-plus');
    const isColumnItem = event.target.closest('.schema-column-item');

    if (!isConnectionElement && !isColumnItem) {
        exitConnectMode();
    }
}

function exitConnectMode() {
    schemaBuilderState.connectMode = null;

    // Remove highlight classes
    document.querySelectorAll('.schema-connection-dot, .schema-connection-plus').forEach(el => {
        el.classList.remove('connect-mode', 'connect-mode-target');
    });

    // Remove hover listeners
    document.querySelectorAll('.schema-column-item').forEach(item => {
        item.removeEventListener('mouseenter', handleTargetColumnHover);
        item.removeEventListener('mouseleave', handleTargetColumnLeave);
    });

    // Remove event listeners
    document.removeEventListener('keydown', handleConnectModeKeydown);
    document.removeEventListener('click', handleConnectModeOutsideClick, true);

    // Hide popover
    hideColumnInfoPopover();
}

function createJoin(leftTable, leftCol, rightTable, rightCol) {
    // Ensure primary table is always on the left
    if (leftTable !== wizardData.primaryTable && rightTable === wizardData.primaryTable) {
        [leftTable, leftCol, rightTable, rightCol] = [rightTable, rightCol, leftTable, leftCol];
    }

    // Check if join already exists
    const existingIndex = schemaBuilderState.joins.findIndex(j =>
        j.rightTable === rightTable
    );

    if (existingIndex >= 0) {
        // Update existing join
        schemaBuilderState.joins[existingIndex] = {
            leftTable,
            leftCol,
            rightTable,
            rightCol,
            type: 'left'
        };
    } else {
        // Add new join
        schemaBuilderState.joins.push({
            leftTable,
            leftCol,
            rightTable,
            rightCol,
            type: 'left'
        });
    }

    renderTableCards();
    refreshPreview();
}

function removeJoin(index) {
    schemaBuilderState.joins.splice(index, 1);
    renderTableCards();
    refreshPreview();
    hideJoinPopover();
}

function setJoinType(type) {
    if (schemaBuilderState.selectedJoinIndex !== null) {
        schemaBuilderState.joins[schemaBuilderState.selectedJoinIndex].type = type;
        refreshPreview();
        hideJoinPopover();
    }
}

function removeSelectedJoin() {
    if (schemaBuilderState.selectedJoinIndex !== null) {
        removeJoin(schemaBuilderState.selectedJoinIndex);
    }
}

function showJoinPopover(index, x, y) {
    schemaBuilderState.selectedJoinIndex = index;
    const popover = document.getElementById('joinPopover');
    const join = schemaBuilderState.joins[index];

    // Update active state for join type options
    popover.querySelectorAll('.join-popover-option[data-type]').forEach(opt => {
        opt.classList.toggle('active', opt.dataset.type === join.type);
    });

    popover.style.left = x + 'px';
    popover.style.top = y + 'px';
    popover.classList.remove('hidden');
}

function hideJoinPopover() {
    schemaBuilderState.selectedJoinIndex = null;
    document.getElementById('joinPopover').classList.add('hidden');
}

// Color palette for connection lines
const JOIN_COLORS = [
    '#2563eb', // Blue
    '#16a34a', // Green
    '#dc2626', // Red
    '#9333ea', // Purple
    '#ea580c', // Orange
    '#0891b2', // Cyan
    '#c026d3', // Fuchsia
    '#ca8a04', // Yellow
];

// Get anchor point for a column, handling scrolled/clipped columns
function getColumnAnchorPoint(table, column, side, areaRect, cardsArea) {
    const shortName = table.replace('raw_data.', '');
    const card = document.getElementById(`card_${shortName}`);
    const columnEl = document.querySelector(`.schema-column-item[data-table="${table}"][data-column="${column}"]`);

    if (!card || !columnEl) {
        return null;
    }

    const cardRect = card.getBoundingClientRect();
    const columnRect = columnEl.getBoundingClientRect();

    // Find the scrollable column list container
    const columnList = card.querySelector('.schema-column-list');
    const listRect = columnList ? columnList.getBoundingClientRect() : cardRect;

    // Determine X coordinate based on which side to connect
    const x = side === 'right' ? cardRect.right : cardRect.left;

    // Calculate column's vertical center
    const columnCenterY = columnRect.top + columnRect.height / 2;

    // Check if column is visible within the scrollable area
    let y = columnCenterY;
    let isClipped = false;
    let clipDirection = null;

    if (columnList) {
        if (columnRect.bottom < listRect.top) {
            // Column is scrolled above visible area
            y = listRect.top + 10;
            isClipped = true;
            clipDirection = 'up';
        } else if (columnRect.top > listRect.bottom) {
            // Column is scrolled below visible area
            y = listRect.bottom - 10;
            isClipped = true;
            clipDirection = 'down';
        } else if (columnRect.top < listRect.top) {
            // Column is partially clipped at top
            y = listRect.top + 5;
            isClipped = true;
            clipDirection = 'up';
        } else if (columnRect.bottom > listRect.bottom) {
            // Column is partially clipped at bottom
            y = listRect.bottom - 5;
            isClipped = true;
            clipDirection = 'down';
        }
    }

    // Convert to SVG coordinates (relative to cards area)
    return {
        x: x - areaRect.left + cardsArea.scrollLeft,
        y: y - areaRect.top + cardsArea.scrollTop,
        isClipped,
        clipDirection
    };
}

// Determine which side each card should connect from based on relative positions
function getConnectionSides(leftCard, rightCard) {
    const leftRect = leftCard.getBoundingClientRect();
    const rightRect = rightCard.getBoundingClientRect();

    const leftCenterX = leftRect.left + leftRect.width / 2;
    const rightCenterX = rightRect.left + rightRect.width / 2;

    if (leftCenterX < rightCenterX) {
        // Left card is actually on the left
        return { leftSide: 'right', rightSide: 'left' };
    } else {
        // Left card is actually on the right
        return { leftSide: 'left', rightSide: 'right' };
    }
}

function updateConnectionLines() {
    const svg = document.getElementById('connectionsSvg');
    const cardsArea = document.getElementById('schemaCardsArea');

    // Clear existing lines
    svg.innerHTML = '';

    // Reset all connection dot colors first
    document.querySelectorAll('.schema-connection-dot.connected').forEach(dot => {
        dot.style.borderColor = '';
        dot.style.backgroundColor = '';
    });

    // Draw lines for each join
    schemaBuilderState.joins.forEach((join, index) => {
        // Get the card elements
        const leftCard = document.querySelector(`.schema-table-card[data-table="${join.leftTable}"]`);
        const rightCard = document.querySelector(`.schema-table-card[data-table="${join.rightTable}"]`);

        if (leftCard && rightCard) {
            const areaRect = cardsArea.getBoundingClientRect();

            // Determine which side each card should connect from
            const sides = getConnectionSides(leftCard, rightCard);

            // Get column-level anchor points
            const leftAnchor = getColumnAnchorPoint(join.leftTable, join.leftCol, sides.leftSide, areaRect, cardsArea);
            const rightAnchor = getColumnAnchorPoint(join.rightTable, join.rightCol, sides.rightSide, areaRect, cardsArea);

            // If we couldn't find the columns, fall back to card-level connection
            if (!leftAnchor || !rightAnchor) {
                const leftCardRect = leftCard.getBoundingClientRect();
                const rightCardRect = rightCard.getBoundingClientRect();
                const connection = calculateBestConnectionPoints(leftCardRect, rightCardRect, areaRect, cardsArea);
                drawConnectionLine(svg, connection.x1, connection.y1, connection.x2, connection.y2, index, areaRect, false, false, null, null);
                return;
            }

            // Get color for this join
            const color = JOIN_COLORS[index % JOIN_COLORS.length];

            // Draw the connection line
            drawConnectionLine(svg, leftAnchor.x, leftAnchor.y, rightAnchor.x, rightAnchor.y, index, areaRect,
                leftAnchor.isClipped, rightAnchor.isClipped, leftAnchor.clipDirection, rightAnchor.clipDirection);

            // Color the connection dots
            const leftDot = document.querySelector(`.schema-connection-dot[data-table="${join.leftTable}"][data-column="${join.leftCol}"]`);
            const rightDot = document.querySelector(`.schema-connection-dot[data-table="${join.rightTable}"][data-column="${join.rightCol}"]`);

            if (leftDot) {
                leftDot.style.borderColor = color;
                leftDot.style.backgroundColor = color;
            }
            if (rightDot) {
                rightDot.style.borderColor = color;
                rightDot.style.backgroundColor = color;
            }
        }
    });
}

// Draw a connection line with optional arrow indicators for clipped columns
function drawConnectionLine(svg, x1, y1, x2, y2, index, areaRect, leftClipped, rightClipped, leftClipDir, rightClipDir) {
    const color = JOIN_COLORS[index % JOIN_COLORS.length];
    const cardsArea = document.getElementById('schemaCardsArea');

    // Create a curved path for better visibility
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = createCurvedPath(x1, y1, x2, y2);
    path.setAttribute('d', d);
    path.setAttribute('class', 'join-line');
    path.setAttribute('stroke', color);
    path.setAttribute('fill', 'none');
    path.style.pointerEvents = 'stroke';
    path.onclick = (e) => {
        e.stopPropagation();
        showJoinPopover(index, e.clientX - areaRect.left, e.clientY - areaRect.top);
    };

    svg.appendChild(path);

    // Add circles or arrows at connection points
    if (leftClipped && leftClipDir) {
        drawClipArrow(svg, x1, y1, leftClipDir, color);
    } else {
        const circle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle1.setAttribute('cx', x1);
        circle1.setAttribute('cy', y1);
        circle1.setAttribute('r', 4);
        circle1.setAttribute('fill', color);
        svg.appendChild(circle1);
    }

    if (rightClipped && rightClipDir) {
        drawClipArrow(svg, x2, y2, rightClipDir, color);
    } else {
        const circle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle2.setAttribute('cx', x2);
        circle2.setAttribute('cy', y2);
        circle2.setAttribute('r', 4);
        circle2.setAttribute('fill', color);
        svg.appendChild(circle2);
    }
}

// Draw an arrow indicator for clipped columns
function drawClipArrow(svg, x, y, direction, color) {
    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const size = 6;

    let d;
    if (direction === 'up') {
        // Upward arrow ()
        d = `M ${x} ${y - size} L ${x - size} ${y + size} L ${x + size} ${y + size} Z`;
    } else {
        // Downward arrow ()
        d = `M ${x} ${y + size} L ${x - size} ${y - size} L ${x + size} ${y - size} Z`;
    }

    arrow.setAttribute('d', d);
    arrow.setAttribute('fill', color);
    arrow.setAttribute('class', 'clip-arrow');
    svg.appendChild(arrow);
}

function calculateBestConnectionPoints(rect1, rect2, areaRect, cardsArea) {
    // Calculate centers of each card
    const center1 = {
        x: rect1.left + rect1.width / 2,
        y: rect1.top + rect1.height / 2
    };
    const center2 = {
        x: rect2.left + rect2.width / 2,
        y: rect2.top + rect2.height / 2
    };

    // Determine which edges to connect based on relative positions
    let x1, y1, x2, y2;

    // Horizontal distance vs vertical distance
    const dx = center2.x - center1.x;
    const dy = center2.y - center1.y;

    if (Math.abs(dx) > Math.abs(dy)) {
        // Cards are more horizontal - connect left/right edges
        if (dx > 0) {
            // Card 2 is to the right of Card 1
            x1 = rect1.right;
            y1 = center1.y;
            x2 = rect2.left;
            y2 = center2.y;
        } else {
            // Card 2 is to the left of Card 1
            x1 = rect1.left;
            y1 = center1.y;
            x2 = rect2.right;
            y2 = center2.y;
        }
    } else {
        // Cards are more vertical - connect top/bottom edges
        if (dy > 0) {
            // Card 2 is below Card 1
            x1 = center1.x;
            y1 = rect1.bottom;
            x2 = center2.x;
            y2 = rect2.top;
        } else {
            // Card 2 is above Card 1
            x1 = center1.x;
            y1 = rect1.top;
            x2 = center2.x;
            y2 = rect2.bottom;
        }
    }

    // Convert to SVG coordinates (relative to cards area)
    return {
        x1: x1 - areaRect.left + cardsArea.scrollLeft,
        y1: y1 - areaRect.top + cardsArea.scrollTop,
        x2: x2 - areaRect.left + cardsArea.scrollLeft,
        y2: y2 - areaRect.top + cardsArea.scrollTop
    };
}

function createCurvedPath(x1, y1, x2, y2) {
    // Create a smooth bezier curve between the two points
    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2;

    // Calculate control points for a smooth curve
    const dx = x2 - x1;
    const dy = y2 - y1;

    // Curve amount based on distance
    const curveAmount = Math.min(Math.abs(dx), Math.abs(dy)) * 0.3;

    let cx1, cy1, cx2, cy2;

    if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal connection - curve vertically
        cx1 = x1 + dx * 0.3;
        cy1 = y1;
        cx2 = x2 - dx * 0.3;
        cy2 = y2;
    } else {
        // Vertical connection - curve horizontally
        cx1 = x1;
        cy1 = y1 + dy * 0.3;
        cx2 = x2;
        cy2 = y2 - dy * 0.3;
    }

    return `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
}

function debouncedRefreshPreview() {
    if (previewDebounceTimer) {
        clearTimeout(previewDebounceTimer);
    }
    previewDebounceTimer = setTimeout(refreshPreview, PREVIEW_DEBOUNCE_MS);
}

function refreshPreview() {
    if (!schemaBuilderState.sessionId) return;

    const joins = schemaBuilderState.joins.map(j => ({
        table: j.rightTable,
        left_col: j.leftCol,
        right_col: j.rightCol,
        type: j.type
    }));

    fetch(`/api/models/${modelId}/datasets/preview/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({
            session_id: schemaBuilderState.sessionId,
            primary_table: wizardData.primaryTable,
            joins: joins,
            selected_columns: schemaBuilderState.selectedColumns
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            schemaBuilderState.previewData = data;
            renderPreview(data);
        } else {
            renderPreviewError(data.message);
        }
    })
    .catch(error => {
        console.error('Error generating preview:', error);
        renderPreviewError('Failed to generate preview');
    });
}

function renderPreview(data) {
    // Update stats
    document.getElementById('previewRowCount').textContent = data.stats?.total_rows || 0;
    document.getElementById('previewColCount').textContent = data.column_order?.length || 0;

    // Show warnings if any
    const warningsEl = document.getElementById('previewWarnings');
    const warningTextEl = document.getElementById('previewWarningText');
    if (data.stats?.warnings?.length > 0) {
        warningsEl.style.display = 'flex';
        warningTextEl.textContent = data.stats.warnings[0];
    } else if (Object.keys(data.stats?.null_counts || {}).length > 0) {
        const nullCounts = data.stats.null_counts;
        const firstNull = Object.entries(nullCounts)[0];
        warningsEl.style.display = 'flex';
        warningTextEl.textContent = `${firstNull[1]} nulls in ${firstNull[0]}`;
    } else {
        warningsEl.style.display = 'none';
    }

    // Render table
    const table = document.getElementById('previewTable');
    const thead = document.getElementById('previewTableHead');
    const tbody = document.getElementById('previewTableBody');
    const empty = document.getElementById('previewEmpty');

    if (!data.preview_rows || data.preview_rows.length === 0) {
        table.style.display = 'none';
        empty.style.display = 'block';
        return;
    }

    table.style.display = 'table';
    empty.style.display = 'none';

    // Headers
    thead.innerHTML = '<tr>' + (data.column_order || []).map(col =>
        `<th>${col}</th>`
    ).join('') + '</tr>';

    // Rows
    tbody.innerHTML = data.preview_rows.map(row => {
        return '<tr>' + (data.column_order || []).map(col => {
            const val = row[col];
            if (val === null || val === undefined) {
                return `<td class="null-value">NULL</td>`;
            }
            return `<td title="${val}">${val}</td>`;
        }).join('') + '</tr>';
    }).join('');

    validateCurrentStep();
}

function renderPreviewError(message) {
    document.getElementById('previewRowCount').textContent = '-';
    document.getElementById('previewColCount').textContent = '-';
    document.getElementById('previewWarnings').style.display = 'none';
    document.getElementById('previewTable').style.display = 'none';
    document.getElementById('previewEmpty').style.display = 'block';
    document.getElementById('previewEmpty').innerHTML = `
        <i class="fas fa-exclamation-triangle"></i>
        ${message || 'Failed to generate preview'}
    `;
}

function collectSchemaBuilderData() {
    // Transfer schema builder state to wizard data
    wizardData.selectedColumns = { ...schemaBuilderState.selectedColumns };

    // Convert joins to the format expected by the backend
    wizardData.joinConfig = {};
    schemaBuilderState.joins.forEach(join => {
        wizardData.joinConfig[join.rightTable] = {
            join_key: join.leftCol,
            secondary_column: join.rightCol,
            join_type: join.type
        };
    });
}

function getTypeAbbrev(type) {
    const abbrevs = {
        'STRING': 'str',
        'INTEGER': 'int',
        'INT64': 'int',
        'FLOAT': 'flt',
        'FLOAT64': 'flt',
        'BOOLEAN': 'bool',
        'TIMESTAMP': 'ts',
        'DATE': 'date',
        'DATETIME': 'dt'
    };
    return abbrevs[type?.toUpperCase()] || type?.substring(0, 3)?.toLowerCase() || '';
}

// Close join popover when clicking outside
document.addEventListener('click', function(e) {
    const popover = document.getElementById('joinPopover');
    if (popover && !popover.contains(e.target) && !e.target.classList.contains('join-line')) {
        hideJoinPopover();
    }
});

// ============================================================================
// STEP 4: FILTERS
// ============================================================================

// State for product revenue analysis
let productAnalysisData = null;
let usedFilterColumns = new Set(); // Track columns used in filters to prevent reuse

// Product Filters State Management
let productFiltersState = {
    pending: {
        topRevenue: {
            enabled: false,
            productColumn: null,
            revenueColumn: null,
            thresholdPercent: 80
        },
        categoryFilters: [],  // [{column, mode, values, colInfo}]
        numericFilters: [],   // [{column, type, min, max, value, includeNulls, colInfo}]
        dateFilters: []       // [{column, filterType, relativeOption, startDate, endDate, includeNulls, colInfo}]
    },
    committed: {
        topRevenue: {
            enabled: false,
            productColumn: null,
            revenueColumn: null,
            thresholdPercent: 80
        },
        categoryFilters: [],
        numericFilters: [],
        dateFilters: []
    },
    columnAnalysis: {},  // Cached column analysis data
    selectedFilterColumn: null  // Currently selected column in Filter Columns modal
};

// --- Sub-chapter Toggle ---
function toggleSubchapter(name) {
    const content = document.getElementById(`${name}Content`);
    const chevron = document.getElementById(`${name}Chevron`);

    if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        chevron.classList.remove('fa-chevron-right');
        chevron.classList.add('fa-chevron-down');

        // Update button states when opening sub-chapter
        if (name === 'products') {
            updateProductsRefreshButtonState();
        }
    } else {
        content.classList.add('hidden');
        chevron.classList.remove('fa-chevron-down');
        chevron.classList.add('fa-chevron-right');
    }
}

// --- Product Filter Section Toggles ---
function toggleProductFilterSection(sectionName) {
    const content = document.getElementById(`${sectionName}Content`);
    const header = content.previousElementSibling;
    const chevron = header.querySelector('.product-filter-chevron');

    if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        header.classList.remove('collapsed');
    } else {
        content.classList.add('hidden');
        header.classList.add('collapsed');
    }
}

function toggleTopProductsFilter() {
    // Legacy function - kept for compatibility
    // Top products filter is now auto-enabled when modal opens
    const enabled = document.getElementById('enableTopProducts').checked;
    productFiltersState.pending.topRevenue.enabled = enabled;
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

// ============================================================================
// TOP PRODUCTS MODAL
// ============================================================================

function openTopProductsModal() {
    const modal = document.getElementById('topProductsModal');
    modal.classList.remove('hidden');

    // Auto-enable top products filter when modal opens
    document.getElementById('enableTopProducts').checked = true;
    productFiltersState.pending.topRevenue.enabled = true;
}

function closeTopProductsModal() {
    const modal = document.getElementById('topProductsModal');
    modal.classList.add('hidden');
}

function applyTopProductsFilter() {
    // State is already updated by toggleTopProductsFilter() and other handlers
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
    closeTopProductsModal();
}

// ============================================================================
// FILTER COLUMNS MODAL
// ============================================================================

function openFilterColumnsModal() {
    const modal = document.getElementById('filterColumnsModal');

    // Populate existing filters list
    renderExistingFiltersList();

    // Populate column dropdown
    populateFilterColumnDropdown();

    // Reset filter config area
    resetFilterConfigArea();

    modal.classList.remove('hidden');
}

function closeFilterColumnsModal() {
    const modal = document.getElementById('filterColumnsModal');
    modal.classList.add('hidden');
    resetFilterConfigArea();
}

function renderExistingFiltersList() {
    const section = document.getElementById('existingFiltersSection');
    const list = document.getElementById('existingFiltersList');
    const pending = productFiltersState.pending;

    const allFilters = [
        ...pending.categoryFilters.map(f => ({ ...f, filterType: 'category' })),
        ...pending.numericFilters.map(f => ({ ...f, filterType: 'numeric' })),
        ...pending.dateFilters.map(f => ({ ...f, filterType: 'date' }))
    ];

    if (allFilters.length === 0) {
        section.classList.add('hidden');
        return;
    }

    section.classList.remove('hidden');
    list.innerHTML = allFilters.map((filter, index) => {
        let valueDisplay = '';
        let typeBadge = filter.colInfo?.type || 'STRING';

        if (filter.filterType === 'category') {
            const mode = filter.mode === 'include' ? 'Include' : 'Exclude';
            const valueCount = filter.values?.length || 0;
            valueDisplay = `${mode}: ${valueCount} value${valueCount !== 1 ? 's' : ''} selected`;
        } else if (filter.filterType === 'numeric') {
            if (filter.type === 'range') {
                const min = filter.min !== null && filter.min !== '' ? filter.min : '...';
                const max = filter.max !== null && filter.max !== '' ? filter.max : '...';
                valueDisplay = `Range: ${min} - ${max}`;
            } else if (filter.type === 'equals') {
                valueDisplay = `Equals: ${filter.value}`;
            } else {
                valueDisplay = `Not Equals: ${filter.value}`;
            }
        } else if (filter.filterType === 'date') {
            typeBadge = 'DATE';
            if (filter.dateFilterType === 'relative') {
                const relativeLabels = {
                    'last_7_days': 'Last 7 days',
                    'last_30_days': 'Last 30 days',
                    'last_90_days': 'Last 90 days',
                    'this_month': 'This month',
                    'this_quarter': 'This quarter',
                    'this_year': 'This year'
                };
                valueDisplay = relativeLabels[filter.relativeOption] || filter.relativeOption;
            } else {
                valueDisplay = `${filter.startDate || '...'} to ${filter.endDate || '...'}`;
            }
        }

        return `
            <div class="existing-filter-item" data-filter-type="${filter.filterType}" data-filter-index="${index}">
                <div class="existing-filter-info">
                    <div class="existing-filter-column">
                        <span class="existing-filter-column-name">${filter.column}</span>
                        <span class="existing-filter-type-badge">${typeBadge}</span>
                    </div>
                    <div class="existing-filter-value">${valueDisplay}</div>
                </div>
                <div class="existing-filter-actions">
                    <button class="existing-filter-btn delete" onclick="removeExistingFilter('${filter.filterType}', '${filter.column}')" title="Remove filter">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

function removeExistingFilter(filterType, columnName) {
    const pending = productFiltersState.pending;

    if (filterType === 'category') {
        pending.categoryFilters = pending.categoryFilters.filter(f => f.column !== columnName);
    } else if (filterType === 'numeric') {
        pending.numericFilters = pending.numericFilters.filter(f => f.column !== columnName);
    } else if (filterType === 'date') {
        pending.dateFilters = pending.dateFilters.filter(f => f.column !== columnName);
    }

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

function populateFilterColumnDropdown() {
    const select = document.getElementById('filterColumnSelect');
    select.innerHTML = '<option value="">Select column...</option>';

    // Get available columns (excluding already used ones)
    const availableColumns = getAvailableFilterColumns();

    availableColumns.forEach(col => {
        const option = document.createElement('option');
        option.value = col.fullName;
        option.textContent = `${col.fullName} (${col.type || 'unknown'})`;
        select.appendChild(option);
    });
}

function getAvailableFilterColumns() {
    const allColumns = [];

    // Get columns from schema builder
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            const fullName = `${shortTable}.${col}`;
            // Get column type from metadata if available
            const colInfo = productFiltersState.columnAnalysis[fullName];
            allColumns.push({
                table: shortTable,
                column: col,
                fullName,
                type: colInfo?.type || 'unknown'
            });
        });
    });

    // Filter out columns already used in filters
    return allColumns.filter(col => !isColumnUsedInFilters(col.fullName));
}

async function onFilterColumnSelect() {
    const select = document.getElementById('filterColumnSelect');
    const columnName = select.value;

    productFiltersState.selectedFilterColumn = columnName;

    if (!columnName) {
        resetFilterConfigArea();
        return;
    }

    // Fetch column analysis if not cached
    if (!productFiltersState.columnAnalysis[columnName]) {
        await fetchColumnAnalysis();
    }

    const colInfo = productFiltersState.columnAnalysis[columnName];
    if (!colInfo) {
        resetFilterConfigArea();
        return;
    }

    showFilterConfigForType(columnName, colInfo);
}

function showFilterConfigForType(columnName, colInfo) {
    const container = document.getElementById('filterConfigContainer');
    const categoryConfig = document.getElementById('categoryFilterConfig');
    const numericConfig = document.getElementById('numericFilterConfig');
    const dateConfig = document.getElementById('dateFilterConfig');

    // Hide all configs first
    categoryConfig.classList.add('hidden');
    numericConfig.classList.add('hidden');
    dateConfig.classList.add('hidden');
    container.classList.remove('hidden');

    if (colInfo.filter_type === 'category') {
        showCategoryFilterConfig(columnName, colInfo);
    } else if (colInfo.filter_type === 'numeric') {
        showNumericFilterConfig(columnName, colInfo);
    } else if (colInfo.filter_type === 'date') {
        showDateFilterConfig(columnName, colInfo);
    }
}

function showCategoryFilterConfig(columnName, colInfo) {
    const config = document.getElementById('categoryFilterConfig');
    document.getElementById('categoryFilterColumnName').textContent = `${columnName} - ${colInfo.unique_count} unique values`;

    // Render values list
    const valuesContainer = document.getElementById('newCategoryValuesContainer');
    // Backend returns 'values' as array of {value, count} objects in list mode
    if (colInfo.display_mode === 'list' && colInfo.values) {
        valuesContainer.innerHTML = `
            <div class="category-filter-search">
                <input type="text" placeholder="Search values..." oninput="filterCategoryValues(this.value)">
            </div>
            <div class="category-filter-list" id="newCategoryValuesList">
                ${colInfo.values.map(item => `
                    <div class="category-filter-item" onclick="toggleCategoryValue(this, '${item.value.replace(/'/g, "\\'")}')">
                        <label class="category-filter-item-label">
                            <input type="checkbox" value="${item.value}">
                            ${item.value}
                        </label>
                        <span class="category-filter-item-count">(${item.count})</span>
                    </div>
                `).join('')}
            </div>
        `;
    } else {
        // Autocomplete mode for >100 values
        valuesContainer.innerHTML = `
            <div class="category-autocomplete-container">
                <input type="text" class="category-autocomplete-input" placeholder="Type to search values..."
                       oninput="searchCategoryValues(this.value, '${columnName}')" id="categoryAutocompleteInput">
                <div class="category-autocomplete-dropdown hidden" id="categoryAutocompleteDropdown"></div>
            </div>
            <div class="category-selected-tags" id="categorySelectedTags"></div>
        `;
    }

    // Reset mode selection
    document.querySelector('input[name="newCategoryMode"][value="include"]').checked = true;

    config.classList.remove('hidden');
}

function showNumericFilterConfig(columnName, colInfo) {
    const config = document.getElementById('numericFilterConfig');
    document.getElementById('numericFilterColumnName').textContent = columnName;
    document.getElementById('numericFilterTypeBadge').textContent = colInfo.type;
    document.getElementById('numericFilterStats').textContent =
        `Range: ${colInfo.min} - ${colInfo.max} | Nulls: ${colInfo.null_percent || 0}%`;

    // Reset inputs
    document.querySelector('input[name="newNumericType"][value="range"]').checked = true;
    document.getElementById('newNumericMin').value = '';
    document.getElementById('newNumericMax').value = '';
    document.getElementById('newNumericMin').placeholder = colInfo.min;
    document.getElementById('newNumericMax').placeholder = colInfo.max;
    document.getElementById('newNumericIncludeNulls').checked = true;

    updateNumericFilterInputs();
    config.classList.remove('hidden');
}

function showDateFilterConfig(columnName, colInfo) {
    const config = document.getElementById('dateFilterConfig');
    document.getElementById('dateFilterColumnName').textContent = columnName;
    document.getElementById('dateFilterStats').textContent =
        `Range: ${colInfo.min_date || 'N/A'} - ${colInfo.max_date || 'N/A'}`;

    // Reset inputs
    document.querySelector('input[name="newDateType"][value="relative"]').checked = true;
    document.getElementById('newDateRelativeOption').value = 'last_30_days';
    document.getElementById('newDateStart').value = '';
    document.getElementById('newDateEnd').value = '';
    document.getElementById('newDateIncludeNulls').checked = true;

    updateDateFilterInputs();
    config.classList.remove('hidden');
}

function resetFilterConfigArea() {
    document.getElementById('filterConfigContainer').classList.add('hidden');
    document.getElementById('categoryFilterConfig').classList.add('hidden');
    document.getElementById('numericFilterConfig').classList.add('hidden');
    document.getElementById('dateFilterConfig').classList.add('hidden');
    document.getElementById('filterColumnSelect').value = '';
    productFiltersState.selectedFilterColumn = null;
}

function updateNumericFilterInputs() {
    const filterType = document.querySelector('input[name="newNumericType"]:checked').value;
    const inputsDiv = document.getElementById('newNumericInputs');

    if (filterType === 'range') {
        inputsDiv.innerHTML = `
            <div class="numeric-filter-input-group">
                <label class="numeric-filter-input-label">Min</label>
                <input type="number" class="numeric-filter-input" id="newNumericMin" placeholder="">
            </div>
            <div class="numeric-filter-input-group">
                <label class="numeric-filter-input-label">Max</label>
                <input type="number" class="numeric-filter-input" id="newNumericMax" placeholder="">
            </div>
        `;
    } else {
        inputsDiv.innerHTML = `
            <div class="numeric-filter-input-group" style="flex: 1;">
                <label class="numeric-filter-input-label">Value</label>
                <input type="number" class="numeric-filter-input" id="newNumericValue" placeholder="">
            </div>
        `;
    }
}

function updateDateFilterInputs() {
    const filterType = document.querySelector('input[name="newDateType"]:checked').value;
    const relativeInputs = document.getElementById('newDateRelativeInputs');
    const rangeInputs = document.getElementById('newDateRangeInputs');

    if (filterType === 'relative') {
        relativeInputs.classList.remove('hidden');
        rangeInputs.classList.add('hidden');
    } else {
        relativeInputs.classList.add('hidden');
        rangeInputs.classList.remove('hidden');
    }
}

// --- Add filters from modal ---
function addCategoryFilterFromModal() {
    const columnName = productFiltersState.selectedFilterColumn;
    const colInfo = productFiltersState.columnAnalysis[columnName];
    const mode = document.querySelector('input[name="newCategoryMode"]:checked').value;

    // Get selected values
    let selectedValues = [];
    if (colInfo.display_mode === 'list') {
        const checkboxes = document.querySelectorAll('#newCategoryValuesList input[type="checkbox"]:checked');
        selectedValues = Array.from(checkboxes).map(cb => cb.value);
    } else {
        // Get from tags for autocomplete mode
        const tags = document.querySelectorAll('#categorySelectedTags .category-selected-tag');
        selectedValues = Array.from(tags).map(tag => tag.dataset.value);
    }

    if (selectedValues.length === 0) {
        alert('Please select at least one value');
        return;
    }

    const filterData = {
        column: columnName,
        mode: mode,
        values: selectedValues,
        colInfo: colInfo
    };

    productFiltersState.pending.categoryFilters.push(filterData);

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    resetFilterConfigArea();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

function addNumericFilterFromModal() {
    const columnName = productFiltersState.selectedFilterColumn;
    const colInfo = productFiltersState.columnAnalysis[columnName];
    const filterType = document.querySelector('input[name="newNumericType"]:checked').value;
    const includeNulls = document.getElementById('newNumericIncludeNulls').checked;

    const filterData = {
        column: columnName,
        type: filterType,
        includeNulls: includeNulls,
        colInfo: colInfo
    };

    if (filterType === 'range') {
        filterData.min = document.getElementById('newNumericMin').value || null;
        filterData.max = document.getElementById('newNumericMax').value || null;
        if (!filterData.min && !filterData.max) {
            alert('Please specify at least a min or max value');
            return;
        }
    } else {
        filterData.value = document.getElementById('newNumericValue')?.value;
        if (!filterData.value) {
            alert('Please specify a value');
            return;
        }
    }

    productFiltersState.pending.numericFilters.push(filterData);

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    resetFilterConfigArea();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

function addDateFilterFromModal() {
    const columnName = productFiltersState.selectedFilterColumn;
    const colInfo = productFiltersState.columnAnalysis[columnName];
    const dateFilterType = document.querySelector('input[name="newDateType"]:checked').value;
    const includeNulls = document.getElementById('newDateIncludeNulls').checked;

    const filterData = {
        column: columnName,
        dateFilterType: dateFilterType,
        includeNulls: includeNulls,
        colInfo: colInfo
    };

    if (dateFilterType === 'relative') {
        filterData.relativeOption = document.getElementById('newDateRelativeOption').value;
    } else {
        filterData.startDate = document.getElementById('newDateStart').value || null;
        filterData.endDate = document.getElementById('newDateEnd').value || null;
        if (!filterData.startDate && !filterData.endDate) {
            alert('Please specify at least a start or end date');
            return;
        }
    }

    productFiltersState.pending.dateFilters.push(filterData);

    renderExistingFiltersList();
    populateFilterColumnDropdown();
    resetFilterConfigArea();
    updateProductsFilterSummary();
    updateProductsNavBadges();
    updateProductsRefreshButtonState();
}

// --- Category filter helpers ---
function toggleCategoryValue(element, value) {
    const checkbox = element.querySelector('input[type="checkbox"]');
    checkbox.checked = !checkbox.checked;
    element.classList.toggle('selected', checkbox.checked);
}

function filterCategoryValues(searchTerm) {
    const items = document.querySelectorAll('#newCategoryValuesList .category-filter-item');
    const search = searchTerm.toLowerCase();

    items.forEach(item => {
        const label = item.querySelector('.category-filter-item-label').textContent.toLowerCase();
        item.style.display = label.includes(search) ? '' : 'none';
    });
}

async function searchCategoryValues(searchTerm, columnName) {
    const dropdown = document.getElementById('categoryAutocompleteDropdown');

    if (searchTerm.length < 2) {
        dropdown.classList.add('hidden');
        return;
    }

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/search-category-values/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                session_id: schemaBuilderState.sessionId,
                column_name: columnName,
                search_term: searchTerm,
                limit: 20
            })
        });

        const data = await response.json();
        if (data.status === 'success' && data.values) {
            dropdown.innerHTML = data.values.map(v => `
                <div class="category-autocomplete-item" onclick="selectAutocompleteValue('${v.value.replace(/'/g, "\\'")}', ${v.count})">
                    <span>${v.value}</span>
                    <span style="color: #9ca3af; font-size: 11px;">(${v.count})</span>
                </div>
            `).join('');
            dropdown.classList.remove('hidden');
        }
    } catch (error) {
        console.error('Error searching category values:', error);
    }
}

function selectAutocompleteValue(value, count) {
    const tagsContainer = document.getElementById('categorySelectedTags');
    const dropdown = document.getElementById('categoryAutocompleteDropdown');
    const input = document.getElementById('categoryAutocompleteInput');

    // Check if already selected
    const existing = tagsContainer.querySelector(`[data-value="${value}"]`);
    if (existing) return;

    // Add tag
    const tag = document.createElement('span');
    tag.className = 'category-selected-tag';
    tag.dataset.value = value;
    tag.innerHTML = `${value} <span class="category-selected-tag-remove" onclick="this.parentElement.remove()">&times;</span>`;
    tagsContainer.appendChild(tag);

    // Clear input and hide dropdown
    input.value = '';
    dropdown.classList.add('hidden');
}

// --- Summary and Badge Updates ---
// Track if product filters have been applied (via Refresh Dataset click)
let productFiltersApplied = false;

// Update the Products summary line (shows pending filter details)
function updateProductsFilterSummary() {
    const summaryDiv = document.getElementById('productsFilterSummary');
    const summaryText = document.getElementById('productsFilterSummaryText');
    const pending = productFiltersState.pending;

    const filterDetails = [];

    // Top products
    if (pending.topRevenue.enabled) {
        filterDetails.push(`Top ${pending.topRevenue.thresholdPercent}% products`);
    }

    // Category filters
    pending.categoryFilters.forEach(f => {
        const shortName = f.column.split('.').pop();
        filterDetails.push(shortName);
    });

    // Numeric filters
    pending.numericFilters.forEach(f => {
        const shortName = f.column.split('.').pop();
        filterDetails.push(shortName);
    });

    // Date filters
    pending.dateFilters.forEach(f => {
        const shortName = f.column.split('.').pop();
        filterDetails.push(shortName);
    });

    if (filterDetails.length === 0) {
        summaryText.textContent = 'No filters selected';
        summaryDiv.classList.remove('has-pending');
    } else {
        summaryText.textContent = filterDetails.join('  ');
        summaryDiv.classList.add('has-pending');
    }
}

// Update the Products sub-chapter header badge (shows "X filters applied" after Refresh)
function updateProductsFilterStatus() {
    const statusEl = document.getElementById('productsFilterStatus');

    // Only show badge if filters have been applied via Refresh Dataset
    if (!productFiltersApplied) {
        statusEl.textContent = '';
        return;
    }

    const committed = productFiltersState.committed;
    let filterCount = 0;

    if (committed.topRevenue.enabled) filterCount++;
    filterCount += committed.categoryFilters.length;
    filterCount += committed.numericFilters.length;
    filterCount += committed.dateFilters.length;

    if (filterCount === 0) {
        statusEl.textContent = '';
    } else {
        statusEl.textContent = `${filterCount} filter${filterCount !== 1 ? 's' : ''} applied`;
    }
}

// Legacy function - kept for compatibility, now does nothing
function updateProductsNavBadges() {
    // Badges removed - now using summary line instead
}

// Update Products Refresh Dataset button state
function updateProductsRefreshButtonState() {
    const refreshBtn = document.getElementById('refreshProductFiltersBtn');
    if (!refreshBtn) return;

    const pending = productFiltersState.pending;

    // Check if there are any pending filters to apply
    const hasFilters = pending.topRevenue.enabled ||
                       pending.categoryFilters.length > 0 ||
                       pending.numericFilters.length > 0 ||
                       pending.dateFilters.length > 0;

    refreshBtn.disabled = !hasFilters;
    refreshBtn.classList.toggle('filter-button-disabled', !hasFilters);
}

// --- Legacy Add Filter Modal (keeping for backwards compatibility) ---
function openAddFilterModal() {
    const modal = document.getElementById('addFilterModal');
    const select = document.getElementById('addFilterColumnSelect');

    // Populate column dropdown with filterable columns
    select.innerHTML = '<option value="">Choose a column...</option>';

    // Get selected columns from schema builder
    const allColumns = [];
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            const fullName = `${shortTable}.${col}`;
            // Exclude columns already used in filters
            if (!isColumnUsedInFilters(fullName)) {
                allColumns.push({ table: shortTable, column: col, fullName });
            }
        });
    });

    allColumns.forEach(c => {
        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        select.appendChild(option);
    });

    // Reset modal state
    document.getElementById('addFilterColumnInfo').classList.add('hidden');
    document.getElementById('addFilterConfirmBtn').disabled = true;

    modal.classList.remove('hidden');
}

function closeAddFilterModal() {
    document.getElementById('addFilterModal').classList.add('hidden');
}

function isColumnUsedInFilters(columnName) {
    const pending = productFiltersState.pending;

    // Check top revenue columns
    if (pending.topRevenue.enabled) {
        if (pending.topRevenue.productColumn === columnName) return true;
        if (pending.topRevenue.revenueColumn === columnName) return true;
    }

    // Check category filters
    if (pending.categoryFilters.some(f => f.column === columnName)) return true;

    // Check numeric filters
    if (pending.numericFilters.some(f => f.column === columnName)) return true;

    // Check date filters
    if (pending.dateFilters.some(f => f.column === columnName)) return true;

    return false;
}

async function onAddFilterColumnChange() {
    const select = document.getElementById('addFilterColumnSelect');
    const columnName = select.value;
    const infoDiv = document.getElementById('addFilterColumnInfo');
    const confirmBtn = document.getElementById('addFilterConfirmBtn');

    if (!columnName) {
        infoDiv.classList.add('hidden');
        confirmBtn.disabled = true;
        return;
    }

    // Fetch column analysis if not cached
    if (!productFiltersState.columnAnalysis[columnName]) {
        await fetchColumnAnalysis();
    }

    const colInfo = productFiltersState.columnAnalysis[columnName];
    if (colInfo) {
        // Show column type and info
        let infoHtml = `<strong>Type:</strong> ${colInfo.type}<br>`;
        if (colInfo.filter_type === 'category') {
            infoHtml += `<strong>Unique values:</strong> ${colInfo.unique_count}`;
            if (colInfo.display_mode === 'autocomplete') {
                infoHtml += ' (autocomplete mode)';
            }
        } else if (colInfo.filter_type === 'numeric') {
            infoHtml += `<strong>Range:</strong> ${colInfo.min} - ${colInfo.max}`;
            if (colInfo.null_percent > 0) {
                infoHtml += `<br><strong>Nulls:</strong> ${colInfo.null_percent}%`;
            }
        }
        infoDiv.innerHTML = infoHtml;
        infoDiv.classList.remove('hidden');
        confirmBtn.disabled = !colInfo.filterable;
    } else {
        infoDiv.innerHTML = 'Column analysis not available';
        infoDiv.classList.remove('hidden');
        confirmBtn.disabled = true;
    }
}

async function fetchColumnAnalysis() {
    if (!schemaBuilderState.sessionId) return;

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/analyze-columns/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                session_id: schemaBuilderState.sessionId,
                selected_columns: schemaBuilderState.selectedColumns
            })
        });

        const data = await response.json();
        if (data.status === 'success') {
            productFiltersState.columnAnalysis = data.columns;
        }
    } catch (error) {
        console.error('Error fetching column analysis:', error);
    }
}

function confirmAddFilter() {
    const columnName = document.getElementById('addFilterColumnSelect').value;
    const colInfo = productFiltersState.columnAnalysis[columnName];

    if (!columnName || !colInfo || !colInfo.filterable) return;

    if (colInfo.filter_type === 'category') {
        addCategoryFilter(columnName, colInfo);
    } else if (colInfo.filter_type === 'numeric') {
        addNumericFilter(columnName, colInfo);
    }

    closeAddFilterModal();
}

// --- Category Filter Functions ---
function addCategoryFilter(columnName, colInfo) {
    const filterData = {
        column: columnName,
        mode: 'include',
        values: [],
        colInfo: colInfo
    };

    productFiltersState.pending.categoryFilters.push(filterData);
    renderCategoryFilters();
    updateProductFilterBadges();

    // Open the category filters section
    const content = document.getElementById('categoryFiltersContent');
    const header = content.previousElementSibling;
    content.classList.remove('hidden');
    header.classList.remove('collapsed');
}

function renderCategoryFilters() {
    const container = document.getElementById('categoryFilterCards');
    const emptyState = document.getElementById('categoryFiltersEmpty');
    const filters = productFiltersState.pending.categoryFilters;

    if (filters.length === 0) {
        container.innerHTML = '';
        emptyState.classList.remove('hidden');
        return;
    }

    emptyState.classList.add('hidden');
    container.innerHTML = filters.map((filter, index) => renderCategoryFilterCard(filter, index)).join('');
}

function renderCategoryFilterCard(filter, index) {
    const colInfo = filter.colInfo;
    const isAutocomplete = colInfo.display_mode === 'autocomplete';

    let valuesHtml = '';
    if (isAutocomplete) {
        // Autocomplete mode
        valuesHtml = `
            <div class="category-autocomplete-container">
                <input type="text" class="category-autocomplete-input"
                       placeholder="Search values..."
                       oninput="searchCategoryValues(${index}, this.value)"
                       onfocus="showAutocompleteDropdown(${index})">
                <div class="category-autocomplete-dropdown hidden" id="categoryAutocomplete_${index}">
                    <!-- Dropdown items inserted dynamically -->
                </div>
            </div>
            <div class="category-selected-tags" id="categoryTags_${index}">
                ${filter.values.map(v => `
                    <span class="category-selected-tag">
                        ${escapeHtml(v)}
                        <span class="category-selected-tag-remove" onclick="removeCategoryValue(${index}, '${escapeHtml(v)}')">&times;</span>
                    </span>
                `).join('')}
            </div>
        `;
    } else {
        // List mode with checkboxes
        const values = colInfo.values || [];
        valuesHtml = `
            <div class="category-filter-search">
                <input type="text" placeholder="Search..." oninput="filterCategoryList(${index}, this.value)">
            </div>
            <div class="category-filter-list" id="categoryList_${index}">
                ${values.map(v => `
                    <div class="category-filter-item ${filter.values.includes(v.value) ? 'selected' : ''}"
                         onclick="toggleCategoryValue(${index}, '${escapeHtml(v.value)}')">
                        <span class="category-filter-item-label">
                            <input type="checkbox" ${filter.values.includes(v.value) ? 'checked' : ''} readonly>
                            ${escapeHtml(v.value)}
                        </span>
                        <span class="category-filter-item-count">${v.count.toLocaleString()}</span>
                    </div>
                `).join('')}
            </div>
        `;
    }

    return `
        <div class="filter-card" id="categoryFilter_${index}">
            <div class="filter-card-header">
                <div class="filter-card-title">
                    <span class="filter-card-column-name">${filter.column}</span>
                    <span class="filter-card-type-badge">STRING</span>
                </div>
                <button class="filter-card-remove" onclick="removeCategoryFilter(${index})">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="filter-card-body">
                <div class="category-filter-mode">
                    <label>
                        <input type="radio" name="categoryMode_${index}" value="include"
                               ${filter.mode === 'include' ? 'checked' : ''}
                               onchange="setCategoryFilterMode(${index}, 'include')">
                        Include selected
                    </label>
                    <label>
                        <input type="radio" name="categoryMode_${index}" value="exclude"
                               ${filter.mode === 'exclude' ? 'checked' : ''}
                               onchange="setCategoryFilterMode(${index}, 'exclude')">
                        Exclude selected
                    </label>
                </div>
                ${valuesHtml}
                <div class="category-filter-selected-count">
                    Selected: ${filter.values.length} of ${colInfo.unique_count} values
                </div>
            </div>
        </div>
    `;
}

function setCategoryFilterMode(index, mode) {
    productFiltersState.pending.categoryFilters[index].mode = mode;
}

function toggleCategoryValue(index, value) {
    const filter = productFiltersState.pending.categoryFilters[index];
    const valueIndex = filter.values.indexOf(value);

    if (valueIndex === -1) {
        filter.values.push(value);
    } else {
        filter.values.splice(valueIndex, 1);
    }

    renderCategoryFilters();
}

function removeCategoryValue(index, value) {
    const filter = productFiltersState.pending.categoryFilters[index];
    const valueIndex = filter.values.indexOf(value);
    if (valueIndex !== -1) {
        filter.values.splice(valueIndex, 1);
        renderCategoryFilters();
    }
}

function removeCategoryFilter(index) {
    productFiltersState.pending.categoryFilters.splice(index, 1);
    renderCategoryFilters();
    updateProductFilterBadges();
}

function filterCategoryList(index, searchTerm) {
    const list = document.getElementById(`categoryList_${index}`);
    const items = list.querySelectorAll('.category-filter-item');
    const searchLower = searchTerm.toLowerCase();

    items.forEach(item => {
        const label = item.querySelector('.category-filter-item-label').textContent.toLowerCase();
        item.style.display = label.includes(searchLower) ? '' : 'none';
    });
}

async function searchCategoryValues(index, searchTerm) {
    const dropdown = document.getElementById(`categoryAutocomplete_${index}`);
    const filter = productFiltersState.pending.categoryFilters[index];

    if (searchTerm.length < 2) {
        dropdown.classList.add('hidden');
        return;
    }

    // Get table and column from column name
    const [tableName, colName] = filter.column.split('.');
    const fullTableName = `raw_data.${tableName}`;

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/search-category-values/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                session_id: schemaBuilderState.sessionId,
                table_name: fullTableName,
                column_name: colName,
                search_term: searchTerm,
                limit: 20
            })
        });

        const data = await response.json();
        if (data.status === 'success' && data.values.length > 0) {
            dropdown.innerHTML = data.values
                .filter(v => !filter.values.includes(v.value))
                .map(v => `
                    <div class="category-autocomplete-item" onclick="addAutocompleteValue(${index}, '${escapeHtml(v.value)}')">
                        <span>${escapeHtml(v.value)}</span>
                        <span class="category-filter-item-count">${v.count.toLocaleString()}</span>
                    </div>
                `).join('');
            dropdown.classList.remove('hidden');
        } else {
            dropdown.classList.add('hidden');
        }
    } catch (error) {
        console.error('Error searching category values:', error);
        dropdown.classList.add('hidden');
    }
}

function addAutocompleteValue(index, value) {
    const filter = productFiltersState.pending.categoryFilters[index];
    if (!filter.values.includes(value)) {
        filter.values.push(value);
        renderCategoryFilters();
    }
}

function showAutocompleteDropdown(index) {
    // Could show recent/top values here
}

// --- Numeric Filter Functions ---
function addNumericFilter(columnName, colInfo) {
    const filterData = {
        column: columnName,
        type: 'range',
        min: null,
        max: null,
        value: null,
        includeNulls: true,
        colInfo: colInfo
    };

    productFiltersState.pending.numericFilters.push(filterData);
    renderNumericFilters();
    updateProductFilterBadges();

    // Open the numeric filters section
    const content = document.getElementById('numericFiltersContent');
    const header = content.previousElementSibling;
    content.classList.remove('hidden');
    header.classList.remove('collapsed');
}

function renderNumericFilters() {
    const container = document.getElementById('numericFilterCards');
    const emptyState = document.getElementById('numericFiltersEmpty');
    const filters = productFiltersState.pending.numericFilters;

    if (filters.length === 0) {
        container.innerHTML = '';
        emptyState.classList.remove('hidden');
        return;
    }

    emptyState.classList.add('hidden');
    container.innerHTML = filters.map((filter, index) => renderNumericFilterCard(filter, index)).join('');
}

function renderNumericFilterCard(filter, index) {
    const colInfo = filter.colInfo;
    const isRange = filter.type === 'range';

    return `
        <div class="filter-card" id="numericFilter_${index}">
            <div class="filter-card-header">
                <div class="filter-card-title">
                    <span class="filter-card-column-name">${filter.column}</span>
                    <span class="filter-card-type-badge">${colInfo.type}</span>
                </div>
                <button class="filter-card-remove" onclick="removeNumericFilter(${index})">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="filter-card-body">
                <div class="numeric-filter-stats">
                    <span class="numeric-filter-stat">
                        <span class="numeric-filter-stat-label">Range:</span>
                        ${colInfo.min} - ${colInfo.max}
                    </span>
                    ${colInfo.null_percent > 0 ? `
                    <span class="numeric-filter-stat">
                        <span class="numeric-filter-stat-label">Nulls:</span>
                        ${colInfo.null_percent}%
                    </span>
                    ` : ''}
                </div>

                <div class="numeric-filter-type">
                    <label>
                        <input type="radio" name="numericType_${index}" value="range"
                               ${filter.type === 'range' ? 'checked' : ''}
                               onchange="setNumericFilterType(${index}, 'range')">
                        Range
                    </label>
                    <label>
                        <input type="radio" name="numericType_${index}" value="equals"
                               ${filter.type === 'equals' ? 'checked' : ''}
                               onchange="setNumericFilterType(${index}, 'equals')">
                        Equals
                    </label>
                    <label>
                        <input type="radio" name="numericType_${index}" value="not_equals"
                               ${filter.type === 'not_equals' ? 'checked' : ''}
                               onchange="setNumericFilterType(${index}, 'not_equals')">
                        Not equals
                    </label>
                </div>

                <div class="numeric-filter-inputs">
                    ${isRange ? `
                        <div class="numeric-filter-input-group">
                            <label class="numeric-filter-input-label">Min</label>
                            <input type="number" class="numeric-filter-input"
                                   value="${filter.min !== null ? filter.min : ''}"
                                   placeholder="${colInfo.min}"
                                   onchange="setNumericFilterValue(${index}, 'min', this.value)">
                        </div>
                        <div class="numeric-filter-input-group">
                            <label class="numeric-filter-input-label">Max</label>
                            <input type="number" class="numeric-filter-input"
                                   value="${filter.max !== null ? filter.max : ''}"
                                   placeholder="${colInfo.max}"
                                   onchange="setNumericFilterValue(${index}, 'max', this.value)">
                        </div>
                    ` : `
                        <div class="numeric-filter-input-group">
                            <label class="numeric-filter-input-label">Value</label>
                            <input type="number" class="numeric-filter-input"
                                   value="${filter.value !== null ? filter.value : ''}"
                                   onchange="setNumericFilterValue(${index}, 'value', this.value)">
                        </div>
                    `}
                </div>

                ${colInfo.null_count > 0 ? `
                <div class="numeric-filter-null-handling">
                    <label>
                        <input type="radio" name="numericNulls_${index}" value="include"
                               ${filter.includeNulls ? 'checked' : ''}
                               onchange="setNumericNullHandling(${index}, true)">
                        Include NULLs
                    </label>
                    <label>
                        <input type="radio" name="numericNulls_${index}" value="exclude"
                               ${!filter.includeNulls ? 'checked' : ''}
                               onchange="setNumericNullHandling(${index}, false)">
                        Exclude NULLs
                    </label>
                </div>
                ` : ''}
            </div>
        </div>
    `;
}

function setNumericFilterType(index, type) {
    productFiltersState.pending.numericFilters[index].type = type;
    renderNumericFilters();
}

function setNumericFilterValue(index, field, value) {
    const filter = productFiltersState.pending.numericFilters[index];
    filter[field] = value === '' ? null : parseFloat(value);
}

function setNumericNullHandling(index, includeNulls) {
    productFiltersState.pending.numericFilters[index].includeNulls = includeNulls;
}

function removeNumericFilter(index) {
    productFiltersState.pending.numericFilters.splice(index, 1);
    renderNumericFilters();
    updateProductFilterBadges();
}

// --- Product Filter Badges ---
function updateProductFilterBadges() {
    const pending = productFiltersState.pending;

    // Top Products badge
    const topBadge = document.getElementById('topProductsBadge');
    if (pending.topRevenue.enabled) {
        topBadge.textContent = `${pending.topRevenue.thresholdPercent}%`;
        topBadge.classList.remove('inactive');
    } else {
        topBadge.textContent = 'Disabled';
        topBadge.classList.add('inactive');
    }

    // Category Filters badge
    const catBadge = document.getElementById('categoryFiltersBadge');
    const catCount = pending.categoryFilters.length;
    catBadge.textContent = `${catCount} filter${catCount !== 1 ? 's' : ''}`;
    if (catCount > 0) {
        catBadge.classList.remove('inactive');
    } else {
        catBadge.classList.add('inactive');
    }

    // Numeric Filters badge
    const numBadge = document.getElementById('numericFiltersBadge');
    const numCount = pending.numericFilters.length;
    numBadge.textContent = `${numCount} filter${numCount !== 1 ? 's' : ''}`;
    if (numCount > 0) {
        numBadge.classList.remove('inactive');
    } else {
        numBadge.classList.add('inactive');
    }

    // Products sub-chapter status
    updateProductsFilterStatus();
}

// --- Reset and Refresh ---
function resetProductFilters() {
    // Copy committed state back to pending
    productFiltersState.pending = JSON.parse(JSON.stringify(productFiltersState.committed));

    // Re-render UI
    const enableCheckbox = document.getElementById('enableTopProducts');
    enableCheckbox.checked = productFiltersState.pending.topRevenue.enabled;
    toggleTopProductsFilter();

    renderCategoryFilters();
    renderNumericFilters();
    updateProductFilterBadges();

    showNotification('Product filters reset to last saved state', 'info');
}

async function refreshProductFilters() {
    // Commit pending state
    productFiltersState.committed = JSON.parse(JSON.stringify(productFiltersState.pending));

    // Mark filters as applied and update header status
    productFiltersApplied = true;
    updateProductsFilterStatus();

    // Build the product_filter object for the API
    const productFilter = buildProductFilterForApi();

    // Update wizardData.filters
    wizardData.filters = wizardData.filters || {};
    wizardData.filters.product_filter = productFilter;

    // Call the dataset stats API
    await updateDatasetSummary();

    showNotification('Dataset refreshed with product filters', 'success');
}

function buildProductFilterForApi() {
    const pending = productFiltersState.pending;
    const result = {};

    // Top revenue filter
    if (pending.topRevenue.enabled) {
        result.top_revenue = {
            enabled: true,
            product_column: pending.topRevenue.productColumn,
            revenue_column: pending.topRevenue.revenueColumn,
            threshold_percent: pending.topRevenue.thresholdPercent
        };
    }

    // Category filters
    if (pending.categoryFilters.length > 0) {
        result.category_filters = pending.categoryFilters
            .filter(f => f.values.length > 0)
            .map(f => ({
                column: f.column,
                mode: f.mode,
                values: f.values
            }));
    }

    // Numeric filters
    if (pending.numericFilters.length > 0) {
        result.numeric_filters = pending.numericFilters
            .filter(f => f.min !== null || f.max !== null || f.value !== null)
            .map(f => ({
                column: f.column,
                type: f.type,
                min: f.min,
                max: f.max,
                value: f.value,
                include_nulls: f.includeNulls
            }));
    }

    return result;
}

// --- Column Dropdown Population ---
function populateFilterColumnDropdowns() {
    // Get all selected columns from schema builder
    const allColumns = [];
    Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
        const shortTable = table.replace('raw_data.', '');
        cols.forEach(col => {
            allColumns.push({
                table: shortTable,
                column: col,
                fullName: `${shortTable}.${col}`
            });
        });
    });

    // Populate timestamp column dropdown (only date/timestamp types)
    const timestampSelect = document.getElementById('timestampColumn');
    timestampSelect.innerHTML = '<option value="">Select column...</option>';
    allColumns.forEach(c => {
        // Note: In production, filter by column type (DATE, TIMESTAMP, DATETIME)
        // For now, include all columns
        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        timestampSelect.appendChild(option);
    });

    // Populate product ID and revenue column dropdowns
    populateProductFilterDropdowns(allColumns);

    // Reset analysis state when columns change
    resetProductAnalysis();

    // Note: Don't reset dataset summary here - fetchDatasetStats() is called
    // from nextStep() when entering Step 4 to load initial unfiltered stats

    // Update button states (disable buttons until timestamp selected)
    updateHistoryButtonStates();
}

function populateProductFilterDropdowns(allColumns = null) {
    if (!allColumns) {
        allColumns = [];
        Object.entries(schemaBuilderState.selectedColumns).forEach(([table, cols]) => {
            const shortTable = table.replace('raw_data.', '');
            cols.forEach(col => {
                allColumns.push({
                    table: shortTable,
                    column: col,
                    fullName: `${shortTable}.${col}`
                });
            });
        });
    }

    // Get the timestamp column that's already selected
    const timestampCol = document.getElementById('timestampColumn')?.value;

    // Filter out columns already used
    const availableColumns = allColumns.filter(c => {
        if (timestampCol && c.fullName === timestampCol) return false;
        return true;
    });

    // Populate product ID dropdown
    const productSelect = document.getElementById('productIdColumn');
    const currentProduct = productSelect?.value;
    productSelect.innerHTML = '<option value="">Select column...</option>';
    availableColumns.forEach(c => {
        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        if (c.fullName === currentProduct) option.selected = true;
        productSelect.appendChild(option);
    });

    // Populate revenue column dropdown (exclude product column)
    const revenueSelect = document.getElementById('revenueColumn');
    const currentRevenue = revenueSelect?.value;
    const productCol = productSelect?.value;

    revenueSelect.innerHTML = '<option value="">Select column...</option>';
    availableColumns.forEach(c => {
        if (productCol && c.fullName === productCol) return;
        const option = document.createElement('option');
        option.value = c.fullName;
        option.textContent = c.fullName;
        if (c.fullName === currentRevenue) option.selected = true;
        revenueSelect.appendChild(option);
    });
}

// --- History Sub-chapter ---

// Track active filter mode: 'rolling' or 'startDate'
let historyFilterMode = 'rolling';
let activeFilterPopup = null;

function toggleFilterPopup(popupName) {
    const popup = document.getElementById(`${popupName}Popup`);
    const button = document.getElementById(`${popupName}Btn`);

    // Don't open popup if button is disabled
    if (button && button.disabled) {
        return;
    }

    // Close any other open popups
    document.querySelectorAll('.filter-popup.show').forEach(p => {
        if (p.id !== `${popupName}Popup`) {
            p.classList.remove('show');
        }
    });
    document.querySelectorAll('.filter-button.active').forEach(b => {
        if (b.id !== `${popupName}Btn`) {
            b.classList.remove('active');
        }
    });

    // Toggle current popup
    if (popup.classList.contains('show')) {
        popup.classList.remove('show');
        button.classList.remove('active');
        activeFilterPopup = null;
    } else {
        // Position popup below the button using fixed positioning
        const buttonRect = button.getBoundingClientRect();
        popup.style.top = (buttonRect.bottom + 8) + 'px';
        popup.style.left = buttonRect.left + 'px';

        popup.classList.add('show');
        button.classList.add('active');
        activeFilterPopup = popupName;

        // If opening start date popup, set default to today
        if (popupName === 'startDate') {
            const startDateInput = document.getElementById('startDateInput');
            if (!startDateInput.value) {
                startDateInput.value = new Date().toISOString().split('T')[0];
            }
        }
    }
}

// Close popups when clicking outside
document.addEventListener('click', function(e) {
    if (activeFilterPopup && !e.target.closest('.filter-button-wrapper')) {
        const popup = document.getElementById(`${activeFilterPopup}Popup`);
        const button = document.getElementById(`${activeFilterPopup}Btn`);
        if (popup) popup.classList.remove('show');
        if (button) button.classList.remove('active');
        activeFilterPopup = null;
    }
});

// Close a specific filter popup
function closeFilterPopup(popupName) {
    const popup = document.getElementById(`${popupName}Popup`);
    const button = document.getElementById(`${popupName}Btn`);
    if (popup) popup.classList.remove('show');
    if (button) button.classList.remove('active');
    if (activeFilterPopup === popupName) {
        activeFilterPopup = null;
    }
}

// Apply rolling window and close popup
function applyRollingWindow() {
    onRollingDaysChange();
    closeFilterPopup('rollingWindow');
}

// Track if date filters have been applied (via Refresh Dataset click)
let dateFiltersApplied = false;

// Update the Dates sub-chapter header badge (shows "1 filter applied" after Refresh)
function updateDatesFilterStatus() {
    const statusEl = document.getElementById('datesFilterStatus');

    // Only show badge if filters have been applied via Refresh Dataset
    if (!dateFiltersApplied) {
        statusEl.textContent = '';
        return;
    }

    const timestampCol = document.getElementById('timestampColumn')?.value;
    if (!timestampCol) {
        statusEl.textContent = '';
        return;
    }

    statusEl.textContent = '1 filter applied';
}

// Update the Dates summary line (shows pending filter details)
function updateDatesFilterSummary() {
    const summaryDiv = document.getElementById('datesFilterSummary');
    const summaryText = document.getElementById('datesFilterSummaryText');

    const timestampCol = document.getElementById('timestampColumn')?.value;
    const rollingDays = document.getElementById('rollingDays')?.value || 30;
    const startDate = document.getElementById('startDateInput')?.value;

    if (!timestampCol) {
        summaryText.textContent = 'No filters selected';
        summaryDiv.classList.remove('has-pending');
        return;
    }

    // Build summary text
    const colName = timestampCol.split('.').pop();
    let details = `Column: ${colName}`;

    if (historyFilterMode === 'startDate' && startDate) {
        details += `  Start date: ${startDate}`;
    } else {
        details += `  ${rollingDays} days rolling window`;
    }

    summaryText.textContent = details;
    summaryDiv.classList.add('has-pending');
}

// Reset the applied status when filters are changed (user needs to click Refresh again)
function resetDateFiltersApplied() {
    dateFiltersApplied = false;
    document.getElementById('datesFilterStatus').textContent = '';
}

function onTimestampColumnChange() {
    updateDatesFilterSummary();
    resetDateFiltersApplied();
    // Re-populate product dropdowns to exclude the timestamp column
    populateProductFilterDropdowns();
    // Update dependent button states
    updateHistoryButtonStates();
    validateCurrentStep();
}

function updateHistoryButtonStates() {
    const timestampCol = document.getElementById('timestampColumn')?.value;
    const hasTimestamp = !!timestampCol;

    // Enable/disable dependent buttons
    const rollingWindowBtn = document.getElementById('rollingWindowBtn');
    const startDateBtn = document.getElementById('startDateBtn');
    const refreshDatasetBtn = document.getElementById('refreshDatasetBtn');

    if (rollingWindowBtn) {
        rollingWindowBtn.disabled = !hasTimestamp;
        rollingWindowBtn.classList.toggle('filter-button-disabled', !hasTimestamp);
    }
    if (startDateBtn) {
        startDateBtn.disabled = !hasTimestamp;
        startDateBtn.classList.toggle('filter-button-disabled', !hasTimestamp);
    }
    if (refreshDatasetBtn) {
        refreshDatasetBtn.disabled = !hasTimestamp;
        refreshDatasetBtn.classList.toggle('filter-button-disabled', !hasTimestamp);
    }
}

function onRollingDaysChange() {
    historyFilterMode = 'rolling';
    updateDatesFilterSummary();
    resetDateFiltersApplied();
    // Reset product analysis when date range changes
    resetProductAnalysis();
    validateCurrentStep();
}

function onStartDateChange() {
    historyFilterMode = 'startDate';
    updateDatesFilterSummary();
    resetDateFiltersApplied();
    // Reset product analysis when date range changes
    resetProductAnalysis();
    validateCurrentStep();
}

function refreshDatasetHistory() {
    const timestampCol = document.getElementById('timestampColumn')?.value;
    const rollingDays = document.getElementById('rollingDays')?.value || 30;
    const startDate = document.getElementById('startDateInput')?.value;

    if (!timestampCol) {
        alert('Please select a timestamp column first');
        return;
    }

    // Mark filters as applied and update header status
    dateFiltersApplied = true;
    updateDatesFilterStatus();

    // Update Dataset Summary panel
    updateDatasetSummary();

    console.log('Refresh Dataset clicked:', {
        mode: historyFilterMode,
        timestampColumn: timestampCol,
        rollingDays: rollingDays,
        startDate: startDate
    });
}

// Store the latest dataset stats
let datasetStatsData = null;

async function fetchDatasetStats(withFilters = false) {
    /**
     * Fetch dataset statistics from the API.
     *
     * @param {boolean} withFilters - If true, include current filter settings.
     *                                If false, get unfiltered stats.
     */
    showDatasetStatsLoading();

    try {
        // Build the request payload
        const payload = {
            primary_table: wizardData.primaryTable,
            selected_columns: wizardData.selectedColumns || {},
            secondary_tables: wizardData.secondaryTables || [],
            join_config: wizardData.joinConfig || {}
        };

        // Add filters if requested
        if (withFilters) {
            const timestampCol = document.getElementById('timestampColumn')?.value;
            const rollingDays = parseInt(document.getElementById('rollingDays')?.value) || 30;
            const startDate = document.getElementById('startDateInput')?.value;
            const minTxEnabled = document.getElementById('enableMinTransactions')?.checked;
            const minTx = parseInt(document.getElementById('minTransactions')?.value) || 2;
            const productCol = document.getElementById('productIdColumn')?.value;
            const revenueCol = document.getElementById('revenueColumn')?.value;
            const revenueThreshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

            const filters = {};

            // Date filter
            if (timestampCol) {
                filters.timestamp_column = timestampCol;

                if (historyFilterMode === 'rolling') {
                    filters.date_filter = { type: 'rolling', days: rollingDays };
                } else if (historyFilterMode === 'startDate' && startDate) {
                    filters.date_filter = { type: 'fixed', start_date: startDate };
                }
            }

            // Customer filter (min transactions)
            if (minTxEnabled && timestampCol) {
                // Try to detect customer column from selected columns
                let customerCol = null;
                for (const [table, columns] of Object.entries(wizardData.selectedColumns || {})) {
                    for (const col of columns) {
                        const colLower = col.toLowerCase();
                        if (['customer_id', 'user_id', 'client_id', 'buyer_id'].includes(colLower)) {
                            customerCol = col;
                            break;
                        }
                    }
                    if (customerCol) break;
                }
                if (customerCol) {
                    filters.customer_filter = {
                        type: 'min_transactions',
                        column: customerCol,
                        value: minTx
                    };
                }
            }

            // Product filter (top N% revenue)
            if (productCol && revenueCol && productAnalysisData) {
                filters.product_filter = {
                    type: 'top_revenue',
                    product_column: productCol,
                    revenue_column: revenueCol,
                    percent: revenueThreshold
                };
            }

            if (Object.keys(filters).length > 0) {
                payload.filters = filters;
            }
        }

        const response = await fetch(`/api/models/${modelId}/datasets/stats/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(payload)
        });

        const data = await response.json();

        if (data.status === 'success') {
            datasetStatsData = data;
            populateDatasetSummary(data);
        } else {
            showDatasetStatsError(data.message || 'Failed to fetch dataset stats');
        }

    } catch (error) {
        console.error('Error fetching dataset stats:', error);
        showDatasetStatsError(error.message);
    }
}

function showDatasetStatsLoading() {
    document.getElementById('datasetSummaryEmpty').classList.remove('hidden');
    document.getElementById('datasetSummaryData').classList.add('hidden');

    // Show loading state
    const emptyEl = document.getElementById('datasetSummaryEmpty');
    emptyEl.innerHTML = `
        <i class="fas fa-spinner fa-spin"></i>
        <span>Loading dataset statistics...</span>
    `;

    // Clear total rows badge
    document.getElementById('summaryTotalRowsBadge').textContent = '';
}

function showDatasetStatsError(message) {
    document.getElementById('datasetSummaryEmpty').classList.remove('hidden');
    document.getElementById('datasetSummaryData').classList.add('hidden');

    const emptyEl = document.getElementById('datasetSummaryEmpty');
    emptyEl.innerHTML = `
        <i class="fas fa-exclamation-triangle" style="color: #dc2626;"></i>
        <span style="color: #dc2626;">Error: ${message}</span>
    `;

    // Clear total rows badge
    document.getElementById('summaryTotalRowsBadge').textContent = '';
}

function populateDatasetSummary(data) {
    document.getElementById('datasetSummaryEmpty').classList.add('hidden');
    document.getElementById('datasetSummaryData').classList.remove('hidden');

    const filters = data.filters_applied || {};
    const summary = data.summary || {};
    const columnStats = data.column_stats || {};

    // --- Total Rows Badge in Header ---
    const totalRowsBadge = document.getElementById('summaryTotalRowsBadge');
    if (summary.total_rows) {
        totalRowsBadge.textContent = `${summary.total_rows.toLocaleString()} rows`;
    } else {
        totalRowsBadge.textContent = '';
    }

    // --- Filter Badges ---
    const datesBadge = document.getElementById('filterBadgeDates');
    const customersBadge = document.getElementById('filterBadgeCustomers');
    const productsBadge = document.getElementById('filterBadgeProducts');

    // Dates filter
    if (filters.dates?.type === 'rolling') {
        document.getElementById('filterBadgeDatesText').textContent = `Last ${filters.dates.days} days`;
        datesBadge.classList.add('filter-active');
    } else if (filters.dates?.type === 'fixed') {
        document.getElementById('filterBadgeDatesText').textContent = `From ${filters.dates.start_date}`;
        datesBadge.classList.add('filter-active');
    } else {
        document.getElementById('filterBadgeDatesText').textContent = 'All dates';
        datesBadge.classList.remove('filter-active');
    }

    // Customers filter
    if (filters.customers?.type === 'min_transactions') {
        document.getElementById('filterBadgeCustomersText').textContent = `Min ${filters.customers.value} transactions`;
        customersBadge.classList.add('filter-active');
    } else {
        document.getElementById('filterBadgeCustomersText').textContent = 'All customers';
        customersBadge.classList.remove('filter-active');
    }

    // Products filter
    if (filters.products?.type === 'top_revenue') {
        document.getElementById('filterBadgeProductsText').textContent = `Top ${filters.products.percent}% revenue`;
        productsBadge.classList.add('filter-active');
    } else {
        document.getElementById('filterBadgeProductsText').textContent = 'All products';
        productsBadge.classList.remove('filter-active');
    }

    // --- Column Stats Table ---
    const tableBody = document.getElementById('columnStatsTableBody');
    tableBody.innerHTML = '';

    for (const [columnName, stats] of Object.entries(columnStats)) {
        const row = document.createElement('tr');

        // Column name cell
        const nameCell = document.createElement('td');
        nameCell.innerHTML = `<span class="column-name">${columnName}</span>`;
        row.appendChild(nameCell);

        // Data type cell
        const typeCell = document.createElement('td');
        typeCell.innerHTML = `<span class="column-type">${stats.type}</span>`;
        row.appendChild(typeCell);

        // Stats cell
        const statsCell = document.createElement('td');
        statsCell.innerHTML = formatColumnStats(stats);
        row.appendChild(statsCell);

        tableBody.appendChild(row);
    }
}

function formatColumnStats(stats) {
    const items = [];

    // Handle different column types
    if (stats.type === 'STRING' || stats.type === 'BYTES') {
        if (stats.unique_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">Unique:</span> <span class="stat-value">${stats.unique_count.toLocaleString()}</span></span>`);
        }
    } else if (['INT64', 'FLOAT64', 'NUMERIC', 'BIGNUMERIC', 'INTEGER', 'FLOAT'].includes(stats.type)) {
        if (stats.min !== undefined && stats.min !== null) {
            items.push(`<span class="stat-item"><span class="stat-label">Min:</span> <span class="stat-value">${formatNumber(stats.min)}</span></span>`);
        }
        if (stats.max !== undefined && stats.max !== null) {
            items.push(`<span class="stat-item"><span class="stat-label">Max:</span> <span class="stat-value">${formatNumber(stats.max)}</span></span>`);
        }
        if (stats.avg !== undefined && stats.avg !== null) {
            items.push(`<span class="stat-item"><span class="stat-label">Avg:</span> <span class="stat-value">${formatNumber(stats.avg)}</span></span>`);
        }
    } else if (['DATE', 'DATETIME', 'TIMESTAMP'].includes(stats.type)) {
        if (stats.min) {
            items.push(`<span class="stat-item"><span class="stat-label">Min:</span> <span class="stat-value">${stats.min}</span></span>`);
        }
        if (stats.max) {
            items.push(`<span class="stat-item"><span class="stat-label">Max:</span> <span class="stat-value">${stats.max}</span></span>`);
        }
        if (stats.unique_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">Unique:</span> <span class="stat-value">${stats.unique_count.toLocaleString()}</span></span>`);
        }
    } else if (stats.type === 'BOOL') {
        if (stats.true_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">True:</span> <span class="stat-value">${stats.true_count.toLocaleString()}</span></span>`);
        }
        if (stats.false_count !== undefined) {
            items.push(`<span class="stat-item"><span class="stat-label">False:</span> <span class="stat-value">${stats.false_count.toLocaleString()}</span></span>`);
        }
    }

    // Add null count if present
    if (stats.null_count !== undefined && stats.null_count > 0) {
        items.push(`<span class="stat-item"><span class="stat-label">Nulls:</span> <span class="stat-value">${stats.null_count.toLocaleString()} (${stats.null_percent}%)</span></span>`);
    }

    return `<div class="column-stats-details">${items.join('')}</div>`;
}

function formatNumber(num) {
    if (num === null || num === undefined) return '-';
    if (Number.isInteger(num)) {
        return num.toLocaleString();
    }
    // For floats, show up to 2 decimal places
    return num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
}

function updateDatasetSummary() {
    // Wrapper function for backward compatibility
    // Now calls fetchDatasetStats with filters
    fetchDatasetStats(true);
}

function resetDatasetSummary() {
    // Reset to empty state with proper message
    datasetStatsData = null;
    const emptyEl = document.getElementById('datasetSummaryEmpty');
    emptyEl.innerHTML = `
        <i class="fas fa-info-circle"></i>
        <span>Click "Refresh Dataset" to see summary statistics</span>
    `;
    emptyEl.classList.remove('hidden');
    document.getElementById('datasetSummaryData').classList.add('hidden');
}

function updateHistorySummary() {
    // Summary removed from header tablet design - this function kept for compatibility
    // Could be used in the future to update a status indicator if needed
}

// --- Products Sub-chapter ---
function onProductColumnChange() {
    // Update revenue dropdown to exclude selected product column
    populateProductFilterDropdowns();
    updateAnalyzeButtonState();
    resetProductAnalysis();
    validateCurrentStep();
}

function onRevenueColumnChange() {
    updateAnalyzeButtonState();
    resetProductAnalysis();
    validateCurrentStep();
}

function updateAnalyzeButtonState() {
    const productCol = document.getElementById('productIdColumn')?.value;
    const revenueCol = document.getElementById('revenueColumn')?.value;
    const analyzeBtn = document.getElementById('analyzeProductsBtn');

    analyzeBtn.disabled = !productCol || !revenueCol;
}

function resetProductAnalysis() {
    productAnalysisData = null;

    const resultsEl = document.getElementById('productAnalysisResults');
    const errorEl = document.getElementById('productAnalysisError');
    if (resultsEl) resultsEl.classList.add('hidden');
    if (errorEl) errorEl.classList.add('hidden');

    // Summary element removed from tablet header design
    const productsSummary = document.getElementById('productsSummary');
    if (productsSummary) productsSummary.textContent = 'All products included';

    // Clear chart
    const svg = document.getElementById('revenueDistributionChart');
    if (svg) svg.innerHTML = '';

    validateCurrentStep();
}

async function analyzeProductRevenue() {
    const productCol = document.getElementById('productIdColumn')?.value;
    const revenueCol = document.getElementById('revenueColumn')?.value;
    const timestampCol = document.getElementById('timestampColumn')?.value;
    const rollingDays = parseInt(document.getElementById('rollingDays')?.value) || 30;

    if (!productCol || !revenueCol) {
        showProductAnalysisError('Please select both Product ID and Revenue columns');
        return;
    }

    const analyzeBtn = document.getElementById('analyzeProductsBtn');
    analyzeBtn.disabled = true;
    analyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Analyzing';

    try {
        const response = await fetch(`/api/models/${modelId}/datasets/analyze-product-revenue/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                primary_table: wizardData.primaryTable,
                product_column: productCol,
                revenue_column: revenueCol,
                timestamp_column: timestampCol || null,
                rolling_days: timestampCol ? rollingDays : null
            })
        });

        const data = await response.json();

        if (data.status === 'success') {
            productAnalysisData = data;
            displayProductAnalysisResults(data);

            const resultsEl = document.getElementById('productAnalysisResults');
            const errorEl = document.getElementById('productAnalysisError');
            if (resultsEl) resultsEl.classList.remove('hidden');
            if (errorEl) errorEl.classList.add('hidden');

            // Update date range preview if available
            if (data.date_range) {
                const dateRangeEl = document.getElementById('dateRangePreview');
                const dateRangeTextEl = document.getElementById('dateRangePreviewText');
                if (dateRangeEl) dateRangeEl.classList.remove('hidden');
                if (dateRangeTextEl) {
                    dateRangeTextEl.textContent = `Data from ${data.date_range.start} to ${data.date_range.end}`;
                }
            }
        } else {
            showProductAnalysisError(data.message || 'Analysis failed');
        }
    } catch (error) {
        console.error('Error analyzing product revenue:', error);
        showProductAnalysisError('Failed to analyze product revenue');
    } finally {
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Analyze';
        validateCurrentStep();
    }
}

function displayProductAnalysisResults(data) {
    // Update summary stats
    document.getElementById('totalProductsCount').textContent = data.total_products.toLocaleString();

    const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;
    updateProductSelectionForThreshold(threshold, data);

    // Draw the chart after a small delay to ensure container is visible and has dimensions
    setTimeout(() => {
        drawRevenueDistributionChart(data.distribution, threshold);
    }, 50);

    // Update products summary
    updateProductsSummary();
}

function updateProductSelectionForThreshold(threshold, data = null) {
    if (!data) data = productAnalysisData;
    if (!data || !data.thresholds) return;

    // Find the closest threshold
    const thresholdKeys = Object.keys(data.thresholds).map(Number).sort((a, b) => a - b);
    let selectedThreshold = thresholdKeys.find(t => t >= threshold) || thresholdKeys[thresholdKeys.length - 1];

    const thresholdData = data.thresholds[String(selectedThreshold)];
    if (thresholdData) {
        document.getElementById('selectedProductsCount').textContent = thresholdData.products.toLocaleString();
        document.getElementById('selectedProductsPercent').textContent = `(${thresholdData.percent}%)`;
    }

    document.getElementById('revenueCoverage').textContent = `${threshold}%`;
    document.getElementById('revenueCoverageAmount').textContent =
        `($${(data.total_revenue * threshold / 100 / 1000000).toFixed(1)}M of $${(data.total_revenue / 1000000).toFixed(1)}M)`;

    updateProductsSummary();
}

function onThresholdChange() {
    const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

    if (productAnalysisData) {
        updateProductSelectionForThreshold(threshold);
        // Redraw chart with new threshold line
        drawRevenueDistributionChart(productAnalysisData.distribution, threshold);
    }

    validateCurrentStep();
}

function updateProductsSummary() {
    const threshold = parseInt(document.getElementById('revenueThreshold')?.value) || 80;

    if (productAnalysisData && productAnalysisData.thresholds) {
        const thresholdKeys = Object.keys(productAnalysisData.thresholds).map(Number).sort((a, b) => a - b);
        let selectedThreshold = thresholdKeys.find(t => t >= threshold) || thresholdKeys[thresholdKeys.length - 1];
        const thresholdData = productAnalysisData.thresholds[String(selectedThreshold)];

        if (thresholdData) {
            // Summary element removed from tablet header design
            const productsSummary = document.getElementById('productsSummary');
            if (productsSummary) {
                productsSummary.textContent = `${thresholdData.products.toLocaleString()} products at ${threshold}%`;
            }
        }
    }
}

function showProductAnalysisError(message) {
    const resultsEl = document.getElementById('productAnalysisResults');
    const errorEl = document.getElementById('productAnalysisError');
    const errorTextEl = document.getElementById('productAnalysisErrorText');

    if (resultsEl) resultsEl.classList.add('hidden');
    if (errorEl) errorEl.classList.remove('hidden');
    if (errorTextEl) errorTextEl.textContent = message;

    // Summary element removed from tablet header design
    const productsSummary = document.getElementById('productsSummary');
    if (productsSummary) productsSummary.textContent = 'Analysis failed';
}

// --- D3.js Revenue Distribution Chart ---
function drawRevenueDistributionChart(distribution, threshold = 80) {
    const container = document.getElementById('revenueChartContainer');
    const svg = d3.select('#revenueDistributionChart');

    // Clear previous chart
    svg.selectAll('*').remove();

    if (!distribution || distribution.length === 0) return;

    // Dimensions - use container width or fallback to reasonable default
    const margin = { top: 20, right: 30, bottom: 40, left: 60 };
    const containerWidth = container.clientWidth || container.offsetWidth || 600;
    const width = Math.max(containerWidth - margin.left - margin.right, 200);
    const height = 200 - margin.top - margin.bottom;

    svg.attr('width', width + margin.left + margin.right)
       .attr('height', height + margin.top + margin.bottom);

    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Scales
    const x = d3.scaleLinear()
        .domain([0, 100])
        .range([0, width]);

    const y = d3.scaleLinear()
        .domain([0, 100])
        .range([height, 0]);

    // Add grid lines
    g.append('g')
        .attr('class', 'grid')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickSize(-height).tickFormat('').ticks(10))
        .style('stroke-dasharray', '3,3')
        .style('stroke-opacity', 0.2);

    g.append('g')
        .attr('class', 'grid')
        .call(d3.axisLeft(y).tickSize(-width).tickFormat('').ticks(5))
        .style('stroke-dasharray', '3,3')
        .style('stroke-opacity', 0.2);

    // Line generator
    const line = d3.line()
        .x(d => x(d.percent_products))
        .y(d => y(d.cumulative_revenue_percent))
        .curve(d3.curveMonotoneX);

    // Draw the distribution line
    g.append('path')
        .datum(distribution)
        .attr('fill', 'none')
        .attr('stroke', '#3b82f6')
        .attr('stroke-width', 2)
        .attr('d', line);

    // Add area under the curve up to threshold
    const thresholdX = findThresholdX(distribution, threshold);

    const area = d3.area()
        .x(d => x(d.percent_products))
        .y0(height)
        .y1(d => y(d.cumulative_revenue_percent))
        .curve(d3.curveMonotoneX);

    // Filter data up to threshold
    const areaData = distribution.filter(d => d.cumulative_revenue_percent <= threshold);
    if (areaData.length > 0) {
        // Add the threshold point
        areaData.push({ percent_products: thresholdX, cumulative_revenue_percent: threshold });

        g.append('path')
            .datum(areaData)
            .attr('fill', '#3b82f6')
            .attr('fill-opacity', 0.1)
            .attr('d', area);
    }

    // Draw threshold line
    g.append('line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', y(threshold))
        .attr('y2', y(threshold))
        .attr('stroke', '#ef4444')
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '5,5');

    // Threshold label
    g.append('text')
        .attr('x', width - 5)
        .attr('y', y(threshold) - 5)
        .attr('text-anchor', 'end')
        .attr('fill', '#ef4444')
        .attr('font-size', '11px')
        .text(`${threshold}% revenue`);

    // Vertical line at threshold intersection
    if (thresholdX > 0) {
        g.append('line')
            .attr('x1', x(thresholdX))
            .attr('x2', x(thresholdX))
            .attr('y1', y(threshold))
            .attr('y2', height)
            .attr('stroke', '#ef4444')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '3,3');

        // Products label
        g.append('text')
            .attr('x', x(thresholdX))
            .attr('y', height + 30)
            .attr('text-anchor', 'middle')
            .attr('fill', '#ef4444')
            .attr('font-size', '10px')
            .text(`${thresholdX.toFixed(1)}% products`);
    }

    // X axis
    g.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickFormat(d => `${d}%`))
        .selectAll('text')
        .style('font-size', '10px');

    // Y axis
    g.append('g')
        .call(d3.axisLeft(y).tickFormat(d => `${d}%`))
        .selectAll('text')
        .style('font-size', '10px');

    // Axis labels
    g.append('text')
        .attr('x', width / 2)
        .attr('y', height + 35)
        .attr('text-anchor', 'middle')
        .attr('fill', '#666')
        .attr('font-size', '11px')
        .text('Products (ranked by revenue)');

    g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -40)
        .attr('text-anchor', 'middle')
        .attr('fill', '#666')
        .attr('font-size', '11px')
        .text('Cumulative Revenue');
}

function findThresholdX(distribution, threshold) {
    // Find the x value (percent_products) where cumulative_revenue reaches the threshold
    for (let i = 0; i < distribution.length - 1; i++) {
        if (distribution[i].cumulative_revenue_percent <= threshold &&
            distribution[i + 1].cumulative_revenue_percent >= threshold) {
            // Linear interpolation
            const ratio = (threshold - distribution[i].cumulative_revenue_percent) /
                (distribution[i + 1].cumulative_revenue_percent - distribution[i].cumulative_revenue_percent);
            return distribution[i].percent_products +
                ratio * (distribution[i + 1].percent_products - distribution[i].percent_products);
        }
    }
    return distribution[distribution.length - 1]?.percent_products || 100;
}

// --- Advanced Filters Sub-chapter ---
function toggleMinTransactionsInput() {
    const checkbox = document.getElementById('enableMinTransactions');
    document.getElementById('minTransactions').disabled = !checkbox.checked;
    updateAdvancedSummary();
    validateCurrentStep();
}

function updateAdvancedSummary() {
    // Summary element removed from tablet header design
    const advancedSummary = document.getElementById('advancedSummary');
    if (!advancedSummary) return;

    const minTxEnabled = document.getElementById('enableMinTransactions')?.checked;
    const minTx = document.getElementById('minTransactions')?.value || 2;

    let summary = 'No filters';
    if (minTxEnabled) {
        summary = `Min ${minTx} transactions`;
    }
    advancedSummary.textContent = summary;
}

// ============================================================================
// STEP 5: TRAIN/EVAL SPLIT
// ============================================================================
function onSplitStrategyChange() {
    const strategy = document.querySelector('input[name="splitStrategy"]:checked')?.value;
    document.getElementById('timeBasedConfig').classList.toggle('hidden', strategy !== 'time_based');
    document.getElementById('randomSplitConfig').classList.toggle('hidden', strategy !== 'random');
}

function updateTrainPercentLabel() {
    const value = document.getElementById('trainPercent').value;
    document.getElementById('trainPercentLabel').textContent = `${value}% train`;
}

// ============================================================================
// SAVE DATASET
// ============================================================================
function saveDataset() {
    // Collect all data from current step
    collectStepData(currentWizardStep);

    // Build payload
    const payload = {
        name: wizardData.name,
        description: wizardData.description,
        primary_table: wizardData.primaryTable,
        secondary_tables: wizardData.secondaryTables,
        join_config: wizardData.joinConfig,
        selected_columns: wizardData.selectedColumns,
        filters: wizardData.filters,
        split_config: wizardData.splitConfig
    };

    const url = wizardEditMode
        ? `/api/datasets/${wizardEditDatasetId}/update/`
        : `/api/models/${modelId}/datasets/create/`;

    document.getElementById('saveButton').disabled = true;
    document.getElementById('saveButton').querySelector('.btn-neu-inner').innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Saving...';

    fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            showNotification(wizardEditMode ? 'Dataset updated successfully' : 'Dataset created successfully', 'success');
            closeWizard();
            loadDatasets();
        } else {
            showNotification(data.message || 'Failed to save dataset', 'error');
            if (data.errors) {
                console.error('Validation errors:', data.errors);
            }
        }
    })
    .catch(error => {
        console.error('Error saving dataset:', error);
        showNotification('Failed to save dataset', 'error');
    })
    .finally(() => {
        document.getElementById('saveButton').disabled = false;
        document.getElementById('saveButton').querySelector('.btn-neu-inner').textContent = 'Save';
    });
}

// ============================================================================
// DATASET ACTIONS
// ============================================================================
function viewDataset(datasetId) {
    currentDatasetId = datasetId;
    document.getElementById('detailModal').classList.remove('hidden');
    document.getElementById('detailContent').innerHTML = '<p class="text-center text-gray-500 py-8"><i class="fas fa-spinner fa-spin mr-2"></i>Loading...</p>';

    fetch(`/api/datasets/${datasetId}/summary/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            renderDatasetDetail(data.summary);
        } else {
            document.getElementById('detailContent').innerHTML = `<p class="text-center text-red-500 py-8">${data.message || 'Failed to load details'}</p>`;
        }
    })
    .catch(error => {
        console.error('Error loading dataset:', error);
        document.getElementById('detailContent').innerHTML = '<p class="text-center text-red-500 py-8">Failed to load details</p>';
    });
}

function renderDatasetDetail(summary) {
    document.getElementById('detailModalTitle').textContent = summary.name;

    const html = `
        <div class="space-y-4">
            <!-- Status & Info -->
            <div class="flex items-center gap-3">
                <span class="px-3 py-1 rounded-full text-sm font-medium ${summary.status === 'active' ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'}">
                    ${summary.status.charAt(0).toUpperCase() + summary.status.slice(1)}
                </span>
                <span class="text-sm text-gray-500">Created ${new Date(summary.timestamps.created_at).toLocaleDateString()}</span>
            </div>

            ${summary.description ? `<p class="text-gray-600">${escapeHtml(summary.description)}</p>` : ''}

            <!-- Tables -->
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-2">Tables (${summary.tables.total_count})</h4>
                <div class="space-y-1">
                    <div class="flex items-center">
                        <span class="text-sm font-medium text-gray-700 w-24">Primary:</span>
                        <span class="text-sm text-gray-900">${summary.tables.primary?.replace('raw_data.', '') || 'Not set'}</span>
                    </div>
                    ${summary.tables.secondary.length > 0 ? `
                    <div class="flex items-start">
                        <span class="text-sm font-medium text-gray-700 w-24">Secondary:</span>
                        <span class="text-sm text-gray-900">${summary.tables.secondary.map(t => t.replace('raw_data.', '')).join(', ')}</span>
                    </div>
                    ` : ''}
                </div>
            </div>

            <!-- Column Mapping -->
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-2">ML Column Mapping</h4>
                <div class="grid grid-cols-2 gap-2 text-sm">
                    ${Object.entries(summary.columns.mapping || {}).map(([role, col]) => `
                        <div><span class="font-medium text-gray-700">${role}:</span> <span class="text-gray-900">${col}</span></div>
                    `).join('')}
                </div>
                <div class="mt-2 text-sm text-gray-500">${summary.columns.total_selected} columns selected</div>
            </div>

            <!-- Filters -->
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-2">Filters</h4>
                <ul class="list-disc list-inside text-sm text-gray-700">
                    ${summary.filters.summary.map(f => `<li>${f}</li>`).join('')}
                </ul>
            </div>

            <!-- Split -->
            <div class="bg-gray-50 rounded-lg p-4">
                <h4 class="font-semibold text-gray-900 mb-2">Train/Eval Split</h4>
                <p class="text-sm text-gray-700">${summary.split.summary}</p>
            </div>

            <!-- Cached Analysis -->
            ${summary.cached_analysis.has_analysis ? `
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <h4 class="font-semibold text-blue-900 mb-2">Analysis Results</h4>
                <div class="grid grid-cols-3 gap-4 text-sm">
                    <div>
                        <div class="text-blue-700 font-medium">Rows</div>
                        <div class="text-blue-900 text-lg font-bold">${formatNumber(summary.cached_analysis.row_count)}</div>
                    </div>
                    <div>
                        <div class="text-blue-700 font-medium">Unique Users</div>
                        <div class="text-blue-900 text-lg font-bold">${formatNumber(summary.cached_analysis.unique_users)}</div>
                    </div>
                    <div>
                        <div class="text-blue-700 font-medium">Unique Products</div>
                        <div class="text-blue-900 text-lg font-bold">${formatNumber(summary.cached_analysis.unique_products)}</div>
                    </div>
                </div>
                ${summary.cached_analysis.date_range_start ? `
                <div class="mt-2 text-sm text-blue-700">
                    Date range: ${summary.cached_analysis.date_range_start} to ${summary.cached_analysis.date_range_end}
                </div>
                ` : ''}
            </div>
            ` : `
            <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                <p class="text-sm text-yellow-800">
                    <i class="fas fa-info-circle mr-1"></i>
                    No analysis data yet. Click "Analyze" on the dataset card to run analysis.
                </p>
            </div>
            `}
        </div>
    `;

    document.getElementById('detailContent').innerHTML = html;
}

function editDataset(datasetId) {
    // Load dataset and open wizard in edit mode
    fetch(`/api/datasets/${datasetId}/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            openWizard(datasetId);
            loadDatasetForEdit(datasetId);
        } else {
            showNotification(data.message || 'Failed to load dataset', 'error');
        }
    })
    .catch(error => {
        console.error('Error loading dataset:', error);
        showNotification('Failed to load dataset', 'error');
    });
}

function loadDatasetForEdit(datasetId) {
    fetch(`/api/datasets/${datasetId}/`, {
        headers: { 'X-CSRFToken': csrftoken }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            const ds = data.dataset;

            // Populate wizard data
            wizardData.name = ds.name;
            wizardData.description = ds.description || '';
            wizardData.primaryTable = ds.primary_table;
            wizardData.secondaryTables = ds.secondary_tables || [];
            wizardData.joinConfig = ds.join_config || {};
            wizardData.selectedColumns = ds.selected_columns || {};
            wizardData.filters = ds.filters || {};
            wizardData.splitConfig = ds.split_config || {};

            // Update form fields
            document.getElementById('datasetName').value = ds.name;
            document.getElementById('datasetDescription').value = ds.description || '';

            // Update table selections
            renderPrimaryTableList();
            renderSecondaryTableList();

            validateCurrentStep();
        }
    })
    .catch(error => {
        console.error('Error loading dataset for edit:', error);
    });
}

function editDatasetFromDetail() {
    closeDetailModal();
    editDataset(currentDatasetId);
}

function deleteDataset(datasetId, name) {
    document.getElementById('deleteDatasetName').textContent = name;
    document.getElementById('deleteModal').classList.remove('hidden');
    document.getElementById('deleteModal').dataset.datasetId = datasetId;
    document.getElementById('deleteWarning').classList.add('hidden');
}

function closeDeleteModal() {
    document.getElementById('deleteModal').classList.add('hidden');
}

function confirmDelete() {
    const datasetId = document.getElementById('deleteModal').dataset.datasetId;

    document.getElementById('confirmDeleteBtn').disabled = true;
    document.getElementById('confirmDeleteBtn').innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Deleting...';

    fetch(`/api/datasets/${datasetId}/delete/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({ force: true })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            showNotification('Dataset deleted successfully', 'success');
            closeDeleteModal();
            loadDatasets();
        } else {
            showNotification(data.message || 'Failed to delete dataset', 'error');
        }
    })
    .catch(error => {
        console.error('Error deleting dataset:', error);
        showNotification('Failed to delete dataset', 'error');
    })
    .finally(() => {
        document.getElementById('confirmDeleteBtn').disabled = false;
        document.getElementById('confirmDeleteBtn').textContent = 'Delete';
    });
}

function analyzeDataset(datasetId) {
    showNotification('Analyzing dataset...', 'info');

    fetch(`/api/datasets/${datasetId}/analyze/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            showNotification('Analysis complete', 'success');
            loadDatasets(); // Refresh to show new stats

            // If detail modal is open, refresh it
            if (!document.getElementById('detailModal').classList.contains('hidden') && currentDatasetId === datasetId) {
                viewDataset(datasetId);
            }
        } else {
            showNotification(data.message || 'Analysis failed', 'error');
        }
    })
    .catch(error => {
        console.error('Error analyzing dataset:', error);
        showNotification('Analysis failed', 'error');
    });
}

function activateDataset(datasetId) {
    fetch(`/api/datasets/${datasetId}/activate/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            showNotification('Dataset activated', 'success');
            loadDatasets();
        } else {
            showNotification(data.message || 'Failed to activate dataset', 'error');
        }
    })
    .catch(error => {
        console.error('Error activating dataset:', error);
        showNotification('Failed to activate dataset', 'error');
    });
}

// ============================================================================
// QUERY PREVIEW
// ============================================================================
function viewGeneratedQuery() {
    if (!currentDatasetId) return;

    document.getElementById('queryModal').classList.remove('hidden');
    document.getElementById('queryContent').textContent = 'Loading...';

    // Load all queries
    Promise.all([
        fetch(`/api/datasets/${currentDatasetId}/query/`, { headers: { 'X-CSRFToken': csrftoken } }).then(r => r.json()),
        fetch(`/api/datasets/${currentDatasetId}/query/split/`, { headers: { 'X-CSRFToken': csrftoken } }).then(r => r.json())
    ])
    .then(([fullData, splitData]) => {
        currentQueries = {
            full: fullData.status === 'success' ? fullData.query : 'Error loading query',
            train: splitData.status === 'success' ? splitData.queries.train.query : 'Error loading query',
            eval: splitData.status === 'success' ? splitData.queries.eval.query : 'Error loading query'
        };

        showQuery('full');

        if (fullData.validation) {
            const validation = fullData.validation;
            document.getElementById('queryValidation').innerHTML = `
                <div class="flex items-center gap-4">
                    <span class="text-gray-600"><i class="fas fa-database mr-1"></i>${formatBytes(validation.total_bytes_processed || 0)} processed</span>
                    <span class="text-gray-600"><i class="fas fa-dollar-sign mr-1"></i>Est. $${(validation.estimated_cost_usd || 0).toFixed(4)}</span>
                    ${validation.is_valid ? '<span class="text-green-600"><i class="fas fa-check-circle mr-1"></i>Valid</span>' : '<span class="text-red-600"><i class="fas fa-times-circle mr-1"></i>Invalid</span>'}
                </div>
            `;
        }
    })
    .catch(error => {
        console.error('Error loading queries:', error);
        document.getElementById('queryContent').textContent = 'Error loading query';
    });
}

function showQuery(type) {
    document.getElementById('queryContent').textContent = currentQueries[type] || 'No query available';

    // Update tab styling
    document.querySelectorAll('.query-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === type);
        tab.classList.toggle('btn-primary', tab.dataset.tab === type);
        tab.classList.toggle('btn-secondary', tab.dataset.tab !== type);
    });
}

function copyQuery() {
    const query = document.getElementById('queryContent').textContent;
    navigator.clipboard.writeText(query).then(() => {
        showNotification('Query copied to clipboard', 'success');
    }).catch(() => {
        showNotification('Failed to copy query', 'error');
    });
}

function closeQueryModal() {
    document.getElementById('queryModal').classList.add('hidden');
}

function closeDetailModal() {
    document.getElementById('detailModal').classList.add('hidden');
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
function showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `fixed top-4 right-4 z-50 px-4 py-3 rounded-lg shadow-lg transform transition-all duration-300 translate-x-full`;

    const colors = {
        success: 'bg-green-500 text-white',
        error: 'bg-red-500 text-white',
        warning: 'bg-yellow-500 text-white',
        info: 'bg-blue-500 text-white'
    };

    notification.classList.add(...colors[type].split(' '));
    notification.innerHTML = `
        <div class="flex items-center">
            <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : type === 'warning' ? 'exclamation-triangle' : 'info-circle'} mr-2"></i>
            <span>${escapeHtml(message)}</span>
        </div>
    `;

    document.body.appendChild(notification);

    // Animate in
    setTimeout(() => notification.classList.remove('translate-x-full'), 10);

    // Remove after delay
    setTimeout(() => {
        notification.classList.add('translate-x-full');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatNumber(num) {
    if (!num) return '0';
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toLocaleString();
}

function formatBytes(bytes) {
    if (!bytes) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}
</script>
{% endblock %}
